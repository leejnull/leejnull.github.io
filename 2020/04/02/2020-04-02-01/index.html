<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  
  <title>简单了解iOS中的锁 | lee的博客</title>
  <meta name="author" content="Lee JJ">
  
  <meta name="description" content="人一旦有了梦想，怎么活都是有灵魂的">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="简单了解iOS中的锁"/>
  <meta property="og:site_name" content="lee的博客"/>

  
    <meta property="og:image" content=""/>
  

  <link rel="shortcut icon" href="/favicon.png">
  
  
<link rel="stylesheet" href="/css/style.css">

  <!--[if lt IE 9]><script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script><![endif]-->
  

<meta name="generator" content="Hexo 5.0.2"></head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">lee的博客</a></h1>
  <h2><a href="/">lee的博客</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/null">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article id="post-2020-04-02-01" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2020-04-02T07:13:22.000Z"><a href="/2020/04/02/2020-04-02-01/">2020-04-02</a></time>
      
      
  
    <h1 class="p-name title" itemprop="headline name">简单了解iOS中的锁</h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <h2 id="为什么会有线程不安全呢？"><a href="#为什么会有线程不安全呢？" class="headerlink" title="为什么会有线程不安全呢？"></a>为什么会有线程不安全呢？</h2><p>多个线程并发，就会出现同时访问一个资源的情况。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)ticketTest &#123;</span><br><span class="line">    <span class="keyword">self</span>.ticketsCount = <span class="number">50</span>;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                [<span class="keyword">self</span> sellingTickets];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sellingTickets &#123;</span><br><span class="line">    <span class="built_in">NSInteger</span> oldMoney = <span class="keyword">self</span>.ticketsCount;</span><br><span class="line">    sleep(<span class="number">.2</span>);</span><br><span class="line">    oldMoney -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">self</span>.ticketsCount = oldMoney;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;当前剩余票数-&gt; %ld&quot;</span>, oldMoney);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个经典的卖票demo。ticketsCount被多个线程同时访问，就有可能读取到的值是相同的，那么票就会显示少买。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2020-04-01 23:35:19.022896+0800 AwesomeOC[7740:2183272] 当前剩余票数-&gt; 7</span><br><span class="line">2020-04-01 23:35:19.023000+0800 AwesomeOC[7740:2183274] 当前剩余票数-&gt; 6</span><br><span class="line">2020-04-01 23:35:19.023170+0800 AwesomeOC[7740:2183275] 当前剩余票数-&gt; 5</span><br><span class="line">2020-04-01 23:35:19.023767+0800 AwesomeOC[7740:2183275] 当前剩余票数-&gt; 4</span><br></pre></td></tr></table></figure>
<p>最后打印结果就和实际不同。</p>
<h2 id="怎么解决呢？加锁！"><a href="#怎么解决呢？加锁！" class="headerlink" title="怎么解决呢？加锁！"></a>怎么解决呢？加锁！</h2><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>如果自旋锁已经被别的执行单元保持，那么调用者就一直循环在那里看是否该自旋锁的保持着已经释放了锁，所以称为“自旋”。自旋锁会一直循环，所以不会引起调用者睡眠，且自旋锁的效率远高于互斥锁。但是有缺点：1.由于一直循环，所以会一直占用CPU，如果不能在短时间内获得锁，会使CPU效率降低，CPU消耗是线性增长的；2.容易造成死锁，比如递归调用，调用其他函数</p>
<a id="more"></a>

<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>属于sleep-waiting类型的锁。例如在一个双核的机器上有线程A和线程B，分别运行在core0和core1上。假设A想通过<code>pthread_mutex_lock</code>操作去得到一个临界区的锁，而此时这个锁正被B所持有，那么A就会被阻塞(blocking)，Core0会在此时进行上下文切换(Context Switch)将线程A置于等待队列中，此时Core0就可以运行其他的任务不再等待。</p>
<p>所以和自旋锁一比，自旋锁属于“busy-waiting”类型的锁，如果线程A是使用<code>pthread_spin_lock</code>操作去请求锁，那么线程A就会一直在Core0上进行忙等并不停的进行锁请求，直到得到这个锁位置。</p>
<h3 id="两种锁的加锁原理"><a href="#两种锁的加锁原理" class="headerlink" title="两种锁的加锁原理"></a>两种锁的加锁原理</h3><p>互斥锁：线程会从sleep（加锁）-&gt;  running（解锁），过程会有上下文的切换，CPU的抢占，信号的发送等开销。<br>自旋锁：线程一直是running（加锁 -&gt; 解锁），死循环检测锁的标志位。</p>
<h3 id="两种锁的应用"><a href="#两种锁的应用" class="headerlink" title="两种锁的应用"></a>两种锁的应用</h3><p>互斥锁用于临界区持锁时间比较长的操作</p>
<ul>
<li>临界区有IO操作</li>
<li>临界区代码复杂或者循环量大</li>
<li>临界区竞争非常激烈</li>
<li>单核处理器</li>
</ul>
<p>自旋锁一般用于CPU资源比较充足，临界区持锁时间非常短的情况下，自旋锁一般用于多核的服务器。</p>
<h3 id="13种锁"><a href="#13种锁" class="headerlink" title="13种锁"></a>13种锁</h3><h4 id="OSSpinLock"><a href="#OSSpinLock" class="headerlink" title="OSSpinLock"></a>OSSpinLock</h4><p>这个已经被移除了，因为有一个关于优先级反转的bug。<br>当一个低优先级的线程持有自旋锁执行操作的时候，此时一个高优先级的线程也需要获取锁，此时会进入忙等状态，但是高优先级的线程会优先分配更多的CPU资源，此时又因为处于忙等状态会一直消耗CPU，就会导致低优先级的线程没有CPU资源可供调用，操作就没发完成下去或者执行很慢。而高优先级的线程就会一直等待。这就是优先级反转的问题。<br>所以从iOS10开始，就推荐使用os_unfair_lock。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;libkern/OSAtomic.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">OSSpinLockDemo</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) OSSpinLock ticketLock;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">OSSpinLockDemo</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _ticketLock = OS_SPINLOCK_INIT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)sellingTickets &#123;</span><br><span class="line">    OSSpinLockLock(&amp;_ticketLock);</span><br><span class="line">    [<span class="keyword">super</span> sellingTickets];</span><br><span class="line">    OSSpinLockUnlock(&amp;_ticketLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="os-unfair-lock"><a href="#os-unfair-lock" class="headerlink" title="os_unfair_lock"></a>os_unfair_lock</h4><p>等待os_unfair_lock锁的线程会处于休眠状态，并非忙等。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;os/lock.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">OSUnfairLockDemo</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) os_unfair_lock ticketLock;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">OSUnfairLockDemo</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _ticketLock = OS_UNFAIR_LOCK_INIT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)sellingTickets &#123;</span><br><span class="line">    os_unfair_lock_lock(&amp;_ticketLock);</span><br><span class="line">    [<span class="keyword">super</span> sellingTickets];</span><br><span class="line">    os_unfair_lock_unlock(&amp;_ticketLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="pthread-mutex"><a href="#pthread-mutex" class="headerlink" title="pthread_mutex"></a>pthread_mutex</h4><p>互斥锁</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PThreadLockDemo</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) pthread_mutex_t ticketLock;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">PThreadLockDemo</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// 初始化属性</span></span><br><span class="line">        pthread_mutexattr_t attr;</span><br><span class="line">        pthread_mutexattr_init(&amp;attr);</span><br><span class="line">        pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_DEFAULT);</span><br><span class="line">        <span class="comment">// 初始化锁</span></span><br><span class="line">        pthread_mutex_init(&amp;_ticketLock, &amp;attr);</span><br><span class="line">        <span class="comment">// 销毁属性</span></span><br><span class="line">        pthread_mutexattr_destroy(&amp;attr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)sellingTickets &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;_ticketLock);</span><br><span class="line">    [<span class="keyword">super</span> sellingTickets];</span><br><span class="line">    [<span class="keyword">self</span> sellingTickets2];   </span><br><span class="line">    pthread_mutex_unlock(&amp;_ticketLock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 假设有一种死锁情况</span></span><br><span class="line">- (<span class="keyword">void</span>)sellingTickets2 &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;_ticketLock);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);   </span><br><span class="line">    pthread_mutex_unlock(&amp;_ticketLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果碰到死锁的情况，在sellingTickets2中，又执行加锁操作，抢占ticketLock锁，此时出现死锁。我们都知道是因为sellingTickets在持有锁的情况下，sellingTickets2又去抢占。那么把sellingTickets2抢占的锁换一个对象就可以解除了。<br>这里还有一种办法，就是<code>pthread_mutex_t</code>里的属性可以解决：<code>PTHREAD_MUTEX_RECURSIVE</code><br>这个表示递归锁，允许同一个线程对同一把锁进行重复加锁。</p>
<p>假设：我们有一个数组，有两个线程，一个是添加数组，一个是删除数组，我们先调用删除数组，再调用添加数组，但是在数组为空的时候不调用删除数组。<br>这时候要用到<strong>条件</strong>这个接口<br>删除的线程需要等待添加的线程添加完数据之后，再执行删除操作。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PthreadMutexDemo1</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) pthread_mutex_t mutex;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) pthread_cond_t cond;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *data;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">PthreadMutexDemo1</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        pthread_mutexattr_t attr;</span><br><span class="line">        pthread_mutexattr_init(&amp;attr);</span><br><span class="line">        pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);</span><br><span class="line">        pthread_mutex_init(&amp;_mutex, &amp;attr);</span><br><span class="line">        pthread_mutexattr_destroy(&amp;attr);</span><br><span class="line">        pthread_cond_init(&amp;_cond, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">self</span>.data = @[].mutableCopy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)otherTest &#123;</span><br><span class="line">    [[[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(__remove) object:<span class="literal">nil</span>] start];</span><br><span class="line">    [[[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(__add) object:<span class="literal">nil</span>] start];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)__remove &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;_mutex); </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;__remove - begin&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.data.count == <span class="number">0</span>) &#123;</span><br><span class="line">        pthread_cond_wait(&amp;_cond, &amp;_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.data removeLastObject];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;删除了元素&quot;</span>);</span><br><span class="line">    pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)__add &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    [<span class="keyword">self</span>.data addObject:<span class="string">@&quot;Test&quot;</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;添加了元素&quot;</span>);</span><br><span class="line">    <span class="comment">// 激活一个等待该条件的线程 激活所有等待该条件的线程: pthread_cond_broadcast(&amp;_cond);</span></span><br><span class="line">    pthread_cond_signal(&amp;_cond);   </span><br><span class="line">    pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    pthread_mutex_destroy(&amp;_mutex);</span><br><span class="line">    pthread_cond_destroy(&amp;_cond);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="NSLock"><a href="#NSLock" class="headerlink" title="NSLock"></a>NSLock</h4><p>是对<code>mutex</code>普通锁的封装。<code>pthread_mutex_init(mutex, NULL)</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)sellingTickets &#123;</span><br><span class="line">    [<span class="keyword">self</span>.ticketLock lock];</span><br><span class="line">    [<span class="keyword">super</span> sellingTickets];</span><br><span class="line">    [<span class="keyword">self</span>.ticketLock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="NSRecursiveLock"><a href="#NSRecursiveLock" class="headerlink" title="NSRecursiveLock"></a>NSRecursiveLock</h4><p>是对<code>mutex</code>递归锁的封装，API跟NSLock基本一致</p>
<h4 id="NSCondition"><a href="#NSCondition" class="headerlink" title="NSCondition"></a>NSCondition</h4><p>是对<code>mutex</code>和<code>cond</code>的封装。上面操作数组的例子就变成下面这样</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)__remove &#123;</span><br><span class="line"><span class="comment">//    pthread_mutex_lock(&amp;_mutex);</span></span><br><span class="line">    [<span class="keyword">self</span>.condition lock];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;__remove - begin&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.data.count == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//        pthread_cond_wait(&amp;_cond, &amp;_mutex);</span></span><br><span class="line">        [<span class="keyword">self</span>.condition wait];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.data removeLastObject];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;删除了元素&quot;</span>);</span><br><span class="line"><span class="comment">//    pthread_mutex_unlock(&amp;_mutex);</span></span><br><span class="line">    [<span class="keyword">self</span>.condition unlock];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)__add &#123;</span><br><span class="line"><span class="comment">//    pthread_mutex_lock(&amp;_mutex);</span></span><br><span class="line">    [<span class="keyword">self</span>.condition lock];</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    [<span class="keyword">self</span>.data addObject:<span class="string">@&quot;Test&quot;</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;添加了元素&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 激活一个等待该条件的线程</span></span><br><span class="line"><span class="comment">//    pthread_cond_signal(&amp;_cond);</span></span><br><span class="line">    [<span class="keyword">self</span>.condition signal];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    pthread_mutex_unlock(&amp;_mutex);</span></span><br><span class="line">    [<span class="keyword">self</span>.condition unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="NSConditionLock"><a href="#NSConditionLock" class="headerlink" title="NSConditionLock"></a>NSConditionLock</h4><p>对NSCondition的进一步封装，可以设置具体的值。</p>
<ul>
<li>initWithCondition：初始化Condition，并且设置状态值</li>
<li>lockWhenCondition:(NSInteger)condition: 当状态值为condition的时候加锁</li>
<li>unlockWithCondition:(NSInteger)condition 当状态值为condition的时候解锁<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)otherTest &#123;</span><br><span class="line">    [[[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(__one) object:<span class="literal">nil</span>] start];</span><br><span class="line">    [[[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(__two) object:<span class="literal">nil</span>] start];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)__one &#123;</span><br><span class="line">    [<span class="keyword">self</span>.conditionLock lock];</span><br><span class="line">    <span class="built_in">NSLog</span>(@“__one”);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    [<span class="keyword">self</span>.conditionLock unlockWithCondition:<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)__two &#123;</span><br><span class="line">    [<span class="keyword">self</span>.conditionLock lockWhenCondition:<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(@“__two”);</span><br><span class="line">    [<span class="keyword">self</span>.conditionLock unlockWithCondition:<span class="number">3</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="dispatch-semaphore"><a href="#dispatch-semaphore" class="headerlink" title="dispatch_semaphore"></a>dispatch_semaphore</h4><p>信号量的初始值为1，代表同时只允许1条线程访问资源，保证线程同步。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示最多开启5个线程</span></span><br><span class="line">dispatch_semaphore_create(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 如果信号量的值 &gt;0，就让信号量的值减1，然后继续往下执行</span></span><br><span class="line"><span class="comment">// 如果信号量的值 &lt;=0，就会休眠等待，知道信号量的值变成&gt;0，就让信号量的值减1，然后继续往下执行代码</span></span><br><span class="line">dispatch_semaphore_wait(<span class="keyword">self</span>.semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line"><span class="comment">// 让信号量的值+1</span></span><br><span class="line">dispatch_semaphore_signal(<span class="keyword">self</span>.semaphore)</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.semaphore = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)otherTest &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        [[[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(test) object:<span class="literal">nil</span>] start];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)test &#123;</span><br><span class="line">    dispatch_semaphore_wait(<span class="keyword">self</span>.semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(@“test - %@“, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    </span><br><span class="line">    dispatch_semaphore_signal(<span class="keyword">self</span>.semaphore);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然同时开启了20个线程，但是信号量设置为1，每次只执行一个线程。</p>
<h4 id="dispatch-queue"><a href="#dispatch-queue" class="headerlink" title="dispatch_queue"></a>dispatch_queue</h4><p>使用GCD串行队列实现线程同步</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)otherTest &#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(“test”, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;1----%@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;2----%@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="synchronized"><a href="#synchronized" class="headerlink" title="@synchronized"></a>@synchronized</h4><p>是对<code>mutex</code>递归锁的封装，<code>@synchronized(obj)</code>内部会生成obj对应的递归锁，然后进行加锁、解锁操作</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)sellingTickets &#123;</span><br><span class="line">    <span class="keyword">@synchronized</span> ([<span class="keyword">self</span> <span class="keyword">class</span>]) &#123;</span><br><span class="line">        [<span class="keyword">super</span> sellingTickets];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以查看源码objc-sync.mm</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Begin synchronizing on ‘obj&#x27;. </span></span><br><span class="line"><span class="comment">// Allocates recursive mutex associated with ‘obj’ if needed.</span></span><br><span class="line"><span class="comment">// Returns OBJC_SYNC_SUCCESS once lock is acquired.  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">objc_sync_enter</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = OBJC_SYNC_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        SyncData* data = id2data(obj, ACQUIRE);</span><br><span class="line">        assert(data);</span><br><span class="line">        data-&gt;mutex.lock();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// @synchronized(nil) does nothing</span></span><br><span class="line">        <span class="keyword">if</span> (DebugNilSync) &#123;</span><br><span class="line">            _objc_inform(“NIL SYNC DEBUG: @synchronized(nil); <span class="built_in">set</span> a breakpoint on objc_sync_nil to debug”);</span><br><span class="line">        &#125;</span><br><span class="line">        objc_sync_nil();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// End synchronizing on &#x27;obj&#x27;. </span></span><br><span class="line"><span class="comment">// Returns OBJC_SYNC_SUCCESS or OBJC_SYNC_NOT_OWNING_THREAD_ERROR</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">objc_sync_exit</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = OBJC_SYNC_SUCCESS;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        SyncData* data = id2data(obj, RELEASE); </span><br><span class="line">        <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">            result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">bool</span> okay = data-&gt;mutex.tryUnlock();</span><br><span class="line">            <span class="keyword">if</span> (!okay) &#123;</span><br><span class="line">                result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// @synchronized(nil) does nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a>atomic</h4><p>用于保证属性setter、getter的原子性操作，就是在内部加了锁，可以在objc-accessors.mm中查看。<br>注意它并不能保证使用属性的过程是线程安全的。</p>
<h4 id="pthread-rwlock"><a href="#pthread-rwlock" class="headerlink" title="pthread_rwlock"></a>pthread_rwlock</h4><p>读写锁<br>经常用于文件等数据的读写操作，需要导入头文件<code>#import &lt;pthread.h&gt;</code><br>iOS中的读写安全方案需要注意一下场景</p>
<ol>
<li>同一时间，只能有一个线程进行写的操作</li>
<li>同一时间，允许有多个线程进行读的操作</li>
<li>同一时间，不允许既有写的操作，又有读的操作<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pthread_rwlock_init(&amp;_lock, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)read &#123;</span><br><span class="line">    pthread_rwlock_rdlock(&amp;_lock);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">    pthread_rwlock_unlock(&amp;_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)write &#123;</span><br><span class="line">    pthread_rwlock_wrlock(&amp;_lock);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(@“%s”, __func__);</span><br><span class="line">    pthread_rwlock_unlock(&amp;_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    pthread_rwlock_destroy(&amp;_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="dispatch-barrier-async"><a href="#dispatch-barrier-async" class="headerlink" title="dispatch_barrier_async"></a>dispatch_barrier_async</h4><p>传入的并发队列必须是自己通过dispatch_queue_create创建的，如果传入的是一个串行或是一个全局并发队列，这个函数就等同于dispatch_async函数的效果</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(“rw_queue”, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(@“读操作: %d”, i);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(@“写操作: %d”, i);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="锁的性能比较"><a href="#锁的性能比较" class="headerlink" title="锁的性能比较"></a>锁的性能比较</h3><ol>
<li>os_unfair_lock</li>
<li>OSSpinLock</li>
<li>dispatch_semaphore</li>
<li>pthread_mutex</li>
<li>dispatch_queue(DISPATCH_QUEUE_SERIAL)</li>
<li>NSLock</li>
<li>NSCondition</li>
<li>pthread_mutex(recursive)</li>
<li>NSRecursiveLock</li>
<li>NSConditionLock</li>
<li>@synchronized</li>
</ol>

      
    </div>
    <footer>
      
        
  
  <div class="categories">
    <a href="/categories/iOS/">iOS</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/iOS/">iOS</a>, <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a>, <a href="/tags/%E9%94%81/">锁</a>
  </div>

        
  <div class="addthis addthis_toolbox addthis_default_style">
    
      <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
      <a class="addthis_button_pinterest_pinit" pi:pinit:layout="horizontal"></a>
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script src="//s7.addthis.com/js/300/addthis_widget.js"></script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h1 class="title">留言</h1>

  
      <div id="fb-root"></div>
<script>
  (function(d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0];
    if (d.getElementById(id)) return;
    js = d.createElement(s); js.id = id;
    js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=123456789012345";
    fjs.parentNode.insertBefore(js, fjs);
  }(document, 'script', 'facebook-jssdk'));
</script>

<div class="fb-comments" data-href="https://leejnull.github.io/2020/04/02/2020-04-02-01/index.html" data-num-posts="5" data-width="840" data-colorscheme="light"></div>
      
  
</section>

</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="as_sitesearch" value="leejnull.github.io">
  </form>
</div>


  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/Git/">Git</a><small>1</small></li>
  
    <li><a href="/categories/Go/">Go</a><small>4</small></li>
  
    <li><a href="/categories/Python/">Python</a><small>3</small></li>
  
    <li><a href="/categories/iOS/">iOS</a><small>24</small></li>
  
    <li><a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><small>2</small></li>
  
    <li><a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a><small>10</small></li>
  
    <li><a href="/categories/%E6%97%A5%E5%B8%B8/">日常</a><small>2</small></li>
  
    <li><a href="/categories/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/">朝花夕拾</a><small>2</small></li>
  
    <li><a href="/categories/%E8%BF%90%E7%BB%B4/">运维</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/Codable/">Codable</a><small>1</small></li>
  
    <li><a href="/tags/Crash/">Crash</a><small>1</small></li>
  
    <li><a href="/tags/Django/">Django</a><small>3</small></li>
  
    <li><a href="/tags/Event/">Event</a><small>1</small></li>
  
    <li><a href="/tags/ISA/">ISA</a><small>1</small></li>
  
    <li><a href="/tags/KVC/">KVC</a><small>1</small></li>
  
    <li><a href="/tags/KVO/">KVO</a><small>1</small></li>
  
    <li><a href="/tags/Mac%E4%BD%BF%E7%94%A8/">Mac使用</a><small>2</small></li>
  
    <li><a href="/tags/MarkDown/">MarkDown</a><small>1</small></li>
  
    <li><a href="/tags/Mysql/">Mysql</a><small>1</small></li>
  
    <li><a href="/tags/Python/">Python</a><small>2</small></li>
  
    <li><a href="/tags/RunLoop/">RunLoop</a><small>1</small></li>
  
    <li><a href="/tags/Swift/">Swift</a><small>2</small></li>
  
    <li><a href="/tags/UITextView/">UITextView</a><small>1</small></li>
  
    <li><a href="/tags/Vue/">Vue</a><small>1</small></li>
  
    <li><a href="/tags/Xcode/">Xcode</a><small>1</small></li>
  
    <li><a href="/tags/Xib/">Xib</a><small>1</small></li>
  
    <li><a href="/tags/flag/">flag</a><small>1</small></li>
  
    <li><a href="/tags/iOS/">iOS</a><small>22</small></li>
  
    <li><a href="/tags/import/">import</a><small>1</small></li>
  
    <li><a href="/tags/nginx/">nginx</a><small>1</small></li>
  
    <li><a href="/tags/package/">package</a><small>1</small></li>
  
    <li><a href="/tags/pip/">pip</a><small>1</small></li>
  
    <li><a href="/tags/runtime/">runtime</a><small>1</small></li>
  
    <li><a href="/tags/sql/">sql</a><small>2</small></li>
  
    <li><a href="/tags/uwsgi/">uwsgi</a><small>1</small></li>
  
    <li><a href="/tags/%E4%BC%98%E5%8C%96/">优化</a><small>1</small></li>
  
    <li><a href="/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/">位运算</a><small>1</small></li>
  
    <li><a href="/tags/%E5%86%85%E5%AD%98/">内存</a><small>2</small></li>
  
    <li><a href="/tags/%E5%8A%A8%E7%94%BB/">动画</a><small>1</small></li>
  
    <li><a href="/tags/%E5%8E%9F%E7%90%86/">原理</a><small>1</small></li>
  
    <li><a href="/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/">哈希表</a><small>1</small></li>
  
    <li><a href="/tags/%E5%9B%BE%E5%B1%82/">图层</a><small>1</small></li>
  
    <li><a href="/tags/%E5%9F%BA%E7%A1%80/">基础</a><small>2</small></li>
  
    <li><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a><small>2</small></li>
  
    <li><a href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/">字符串</a><small>1</small></li>
  
    <li><a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a><small>14</small></li>
  
    <li><a href="/tags/%E5%AE%9A%E6%97%B6%E5%99%A8/">定时器</a><small>1</small></li>
  
    <li><a href="/tags/%E5%AF%8C%E6%96%87%E6%9C%AC/">富文本</a><small>1</small></li>
  
    <li><a href="/tags/%E5%B0%8F%E6%84%9F%E6%83%B3/">小感想</a><small>1</small></li>
  
    <li><a href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/">小技巧</a><small>1</small></li>
  
    <li><a href="/tags/%E5%B9%B6%E5%8F%91/">并发</a><small>1</small></li>
  
    <li><a href="/tags/%E5%BA%95%E5%B1%82/">底层</a><small>2</small></li>
  
    <li><a href="/tags/%E6%80%A7%E8%83%BD/">性能</a><small>1</small></li>
  
    <li><a href="/tags/%E6%8A%A5%E9%94%99/">报错</a><small>1</small></li>
  
    <li><a href="/tags/%E6%8E%92%E5%BA%8F/">排序</a><small>5</small></li>
  
    <li><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><small>2</small></li>
  
    <li><a href="/tags/%E6%97%A5%E5%B8%B8%E5%8F%8D%E6%80%9D/">日常反思</a><small>1</small></li>
  
    <li><a href="/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/">日常开发</a><small>2</small></li>
  
    <li><a href="/tags/%E6%9E%B6%E6%9E%84/">架构</a><small>1</small></li>
  
    <li><a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a><small>1</small></li>
  
    <li><a href="/tags/%E7%AE%97%E6%B3%95/">算法</a><small>8</small></li>
  
    <li><a href="/tags/%E7%BB%93%E6%9E%84%E4%BD%93/">结构体</a><small>1</small></li>
  
    <li><a href="/tags/%E7%BB%98%E5%88%B6/">绘制</a><small>2</small></li>
  
    <li><a href="/tags/%E7%BF%BB%E8%AF%91/">翻译</a><small>1</small></li>
  
    <li><a href="/tags/%E9%93%BE%E8%A1%A8/">链表</a><small>1</small></li>
  
    <li><a href="/tags/%E9%94%81/">锁</a><small>1</small></li>
  
    <li><a href="/tags/%E9%98%9F%E5%88%97/">队列</a><small>1</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2021 Lee JJ
  
</div>
<div class="clearfix"></div></footer>
  
<script src="/js/jquery-3.4.1.min.js"></script>


<script src="/js/jquery.imagesloaded.min.js"></script>


<script src="/js/gallery.js"></script>






<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script src="/fancybox/jquery.fancybox.pack.js"></script>

<script>
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>
