{"pages":[],"posts":[{"title":"连续子数组的最大和","text":"例子说明 输入的数组为{1, -2, 3, 10, -4, 7, 2, -5}，和最大的子数组为{3, 10, -4, 7, 2}。因此输出为该子数组的和18 我的第一想法把所有的可能的子数组全部循环遍历出来，找出和最大的那个数据，记录，要用到双层循环 直接上代码 1234567891011121314151617181920def cla(lyst): max_array = [] max_sum = 0 counter = 0 for i in range(len(lyst)): for j in range(i+1, len(lyst)+1): sub_array = lyst[i:j] sub_sum = sum(sub_array) counter += 1 if sub_sum &gt; max_sum: max_array = sub_array max_sum = sub_sum elif sub_sum == max_sum: max_array.append(sub_array) print(max_array, max_sum) print(counter)if __name__ == \"__main__\": cla([1, -2, 3, 10, -4, 7, 2, -5]) 这种简单粗暴的方式耗费的时间是： n+n-1+n-2+n-3+…+1 -&gt; 1/2 * n^2 + 1/2 * n 时间复杂度应该是O(n^2) 第二次优化思考一下这种规律，第一个数1，第二个数-2，和为-1，那么从外层循环1开始，内存循环在-2之后都是没有意义的了，因为前两个数的和为负数或0，和后面的数组成子数组的和肯定是比后面的数自己组成子数组更小或相等的，而在外层循环继续往后走的时候肯定也会碰到后续的子数组，即：[1, -2, 3]这样的子数组可以直接忽略，直接从[3]开始了 12345678910111213141516171819202122def cla(lyst): max_array = [] max_sum = 0 counter = 0 for i in range(len(lyst)): for j in range(i+1, len(lyst)+1): sub_array = lyst[i:j] sub_sum = sum(sub_array) counter += 1 if sub_sum &lt;= 0: break; if sub_sum &gt; max_sum: max_array = sub_array max_sum = sub_sum elif sub_sum == max_sum: max_array.append(sub_array) print(max_array, max_sum) print(counter)if __name__ == \"__main__\": cla([1, -2, 3, 10, -4, 7, 2, -5]) 第三次优化这几天一直在看MOOC上浙江大学的数据结构讲课，讲到了这个问题。上面写的两个算法时间复杂度都是O(n^2)，当我们每次看到O(n^2)这种类型的复杂度的时候，都要再思考是否可以优化成 nlog n。采用分治法的思想，把数组每次分成两份，递归的分解，直到最后只有一个元素的时候，如果元素小于0就返回0，否则返回原值。分别计算中间点左右两边的最大和，同时还要考虑横跨中间点的和。 12345678910111213141516171819202122232425262728293031# 分治法# 算法复杂度：O(nlogn)def cla(items, left, right): maxLeftSum = 0 maxRightSum = 0 leftBorderSum = 0 rightBorderSum = 0 maxLeftBorderSum = 0 maxRightBorderSum = 0 if left == right: if items[left] &gt; 0: return items[left] else: return 0 center = (left+right) // 2 maxLeftSum = maxSubseqSum2(items, left, center) maxRightSum = maxSubseqSum2(items, center+1, right) # 左边最大和 for i in range(center-1, left-1, -1): leftBorderSum += items[i] maxLeftBorderSum = max(leftBorderSum, maxLeftBorderSum) # 右边最大和 for i in range(center, right+1): rightBorderSum += items[i] maxRightBorderSum = max(rightBorderSum, maxRightBorderSum) return max(maxLeftBorderSum+maxRightBorderSum, max(maxLeftSum, maxRightSum)) 第四次优化我觉得把我第二次优化的第二层循环去掉，在优化一下就是这个了，一直不明白贪心算法是什么意思，希望再接下来的学习中能理解。这样的话算法复杂度就降低到O(n)的水平了，nice啊~ 12345678910111213# 贪心算法# 算法复杂度：O(n)def maxSubseqSum3(items): maxSum = tempSum = 0 itemsLength = len(items) for i in range(0, itemsLength): tempSum += items[i] if tempSum &gt; maxSum: maxSum = tempSum elif tempSum &lt; 0: tempSum = 0 print(maxSum) return maxSum 总结 当我们把一个算法复杂度修改到O(n^2)的时候，一定要再想想是不是能优化到 nlog n 的层次。 算法复杂度排名：n! &gt; 2^n &gt; n^3 &gt; n^2 &gt; nlog n &gt; n &gt; log n &gt; 1 两段算法相加，复杂度 = 最大的算法复杂度两段算法相乘，复杂度 = 两段算法复杂度相乘","link":"/2019/08/20/2019-07-03/"},{"title":"添加远程仓库push出错error: failed to push some refs to ...","text":"起因在GitHub上创建了一个远程仓库，然后又在本地创建了一个项目，git init后又添加远程仓库的依赖，这时候无论是push还是pull都会报错 仔细看说明好像是说当前分支和远程分支版本不一致，且当前分支是落后的。回想起来我在创建远程仓库的时候默认初始化了一个README文件，所以可能在pull的时候产生了冲突。 解决方案先pull远程分支，并且强制合并git pull origin master --allow-unrelated-histories 再push就可以了git push -u origin master 好像我之前也碰到过这个问题，但是没有细看，都是重新clone下来，再在这个文件里面创建项目的，这次总算是找到了原因彻底解决了。","link":"/2019/08/20/2019-08-20-1/"},{"title":"Mac软件提示已损坏，请移到废纸篓的解决方案","text":"一些不可说的原因 我常常要下载一些特殊的软件，装好之后打开总是提示【Mac软件提示已损坏，请移到废纸篓】，为此整理了两种方案供大家参考 方案一进入系统设置-安全性与隐私-允许从以下位置下载的引用下这里大家一般会看到两个选项 App Store App Store和被认可的开发者 我们需要打开隐藏的第三个选项，打开终端，输入以下命令sudo spctl --master-disable这时候再进入安全性与隐私页面，就能看到第三个选项，选中锁定，再重新打开软件即可。 方案二移除这个应用的安全隔离属性。依旧是打开终端，输入以下命令xattr -r -d com.apple.quarantine /Applications/APP名重新运行下载的程序即可 我用第一种方法尝试过没有成功，但是看网上很多人都可以，怀疑可能是我电脑的历史遗留问题。第二种方法我使用后没有问题。这里写出来仅供大家参考。","link":"/2019/08/20/2019-08-20/"},{"title":"go package包的使用以及路径问题","text":"前言 一开始学 Go，非常晕的就是 package 包的问题，我们知道 Go 有一个很简单的文件可见性规则：首字母大写即对外可见，但是不知道对外是对什么外。以及我在一个 ch1 目录下，创建一个 demo.go 文件，在输入 package 时， VS 又会自动提示 package ch1，这个和 main 又有什么关系呢？我在一个 ch1 目录下写了一个 demo.go 文件，里面有一个函数，我在 ch2/demo2.go 里面想用又该怎么 import 呢？带着这些疑问，这次来系统的了解一下~ Go的环境变量在我们安装完 go 之后，输入 1go env 会输出一大堆信息，其中 GOPATH 就是我们的工作区，我们写了一个 demo.go 文件，其中如果 import 了一些第三方库，运行的时候就会先从 GOROOT 中找，如果没有找到会再去 GOPATH 里面找我们可以通过修改 GOPATH 添加额外的工作区，在你的 .zshrc / .bash_profile 文件里面 1export GOPATH=&quot;/Users/lijun/go:/Users/lijun/Documents/Go/golearning&quot; 引入第三方库一般我们通过 1go get -u github.com/julienschmidt/httprouter 这个指令下载的第三方库都会保存在 GOPATH 第一个工作区指定的 src 目录下只需要在项目里 1import \"github.com/julienschmidt/httprouter\" 就能使用这个第三方包了 有时候 go get 下载失败，可以手动去 GitHub 下载源代码，放到对应目录下，记住路径要和 GitHub 上的文件路径一致 在当前文件使用另一个文件定义的函数或变量 同级目录在class文件夹下新建 demo.go 和 demo_lib.go12345678// demo_lib.gopackage mainimport \"fmt\"func hello(name string) { fmt.Printf(\"Hello, %s!\\n\", name)} 123456789101112131415// demo.gopackage mainimport \"flag\"var name stringfunc init() { flag.StringVar(&amp;name, \"name\", \"everyone\", \"The greeting object.\")}func main() { flag.Parse() hello(name)} 当在一个同级目录下面，有一个 package main 实现了 main() 函数的时候，这是作为程序的唯一入口。在同级目录下，别的文件也必须 package main，且不能再实现 main() 函数，否则提示 redeclared 错误。此时 demo_lib.go 文件里的变量和函数对 demo.go 都是可见的。且不受可见性影响 不同级目录现在我们在 class 文件夹下新建 lib 文件夹，在新建一个 demo2_lib.go 文件，demo2_lib 现在就有两种可能了 package main 并且实现 main() 函数，那么它就是另一个新程序的入口了，内部的函数和变量就不能被别的文件 import package 包名，这样的话是可以被外部使用，但是我们需要把首字母大写，对外部可见（这里了解了对外部是指对别的包而言），我们现在测试这种情况1234567package libimport \"fmt\"func Hello(name string) { fmt.Println(\"Hello, %s!\\n\",)} 如果 demo.go 要使用 demo2_lib 下的 Hello 函数，需要导入这个包。这时候我们需要 go install 一下 1go install class/lib 后面的路径是要导入的包的相对路径，执行完之后，会在我们的工作区下生成 pkg/darwin_amd64/class/lib.a 在 demo.go 导入即可 1234567891011121314151617package mainimport ( \"class/lib\" \"flag\")var name stringfunc init() { flag.StringVar(&amp;name, \"name\", \"everyone\", \"The greeting object.\")}func main() { flag.Parse() lib.Hello(name)} 到这里我们算是完成了一个供外部调用的包的程序 这里有个疑问 我在 class/lib 文件夹下创建的 demo2_lib.go 文件，并且 package lib，package的包名和所在文件夹名有必然联系吗？ 12345678// demo2_lib.gopackage lib2import \"fmt\"func Hello(name string) { fmt.Printf(\"Hello, %s!\\n\", name)} 改成 lib2 试一下go install 后面跟的是路径，所以依然是 class/lib 1go install class/lib 在主函数什么都不改变，调用 1go run demo.go 此时提示 123# command-line-arguments./demo.go:4:2: imported and not used: &quot;class2/lib&quot; as lib2./demo.go:18:2: undefined: lib 从字面上理解一下的话，第一个是说导入了但是没有把 class2/lib 当做 lib2 来使用，第二行说没有定义的 lib emmm~ 我记得 import 包的时候可以起个别名的，试一下 1234567891011121314151617package mainimport ( lib2 \"class/lib\" \"flag\")var name stringfunc init() { flag.StringVar(&amp;name, \"name\", \"everyone\", \"The greeting object.\")}func main() { flag.Parse() lib2.Hello(name)} 继续运行一下，输出结果 12lijun:class2/ $ go run demo.go Hello, everyone! 可以了！！！想一下，我们主要做了什么，和之前有什么不同在路径 class/lib 下，demo2_lib.go 文件没有 package lib，而是 package lib2 12345// 原来package lib// 现在package lib2 go install class/lib 这个步骤没有变也变不了。最后在 main 函数中调用，原来是 123import \"class/lib\"lib.Hello(name) 现在是 123import lib2 \"class/lib\"lib2.Hello(name) 也就是说，当我们要在一个项目里新建一个 tool 文件夹放我们的工具包，我们可以不 package tool，而是可以写一个别的包名，依然可以使用，只不过在使用的时候，import 的还是 pkg 下的路径，但是要给这个 import 设置它真正的包名，即这里的 lib2 总结算是弄明白了 Go 下的文件引用，以及 GOPATH 的设置。同一级目录下只能有一个 main，且别的文件对它都是可见的，不需要设置大小写都可以被访问到，不同级目录，根据首字母大小写可见，还需要 go install一下，再 import 对应路径，包名可以和路径不一致，但是要设置别名。简单了解后，如果还有别的疑惑欢迎大家一起探讨！","link":"/2019/08/21/2019-08-21-1/"},{"title":"关于goroutine的一个简单案例的思考","text":"首先思考这样一个问题下面这段代码会输出什么？ 1234567func main() { for i := 0; i &lt; 10; i++ { go func() { fmt.Println(i) }() }} 估计都不会说是 1,2,3,4…10的吧😂 我们来看一下输出 12lijun:class6/ $ go run class6_demo.go [17:05:23]lijun:class6/ $ 答案是什么都没有 我的思考过程我依稀记得上周看Go入门的时候讲到了这个例子（这里吐槽一下之前只了解了大概，到今天才算是明白其中的究竟）所以我凭着仅有的记忆修改了一下 1234567func main() { for i := 0; i &lt; 10; i++ { go func(a int) { fmt.Println(a) }(i) }} 为什么要这么改呢？因为当时就记住了如果要正确输出 1,2,3…10 的话，得传个参数进去，不然结果就会是 10,10,10…10（这个点下面会讲到），我们再来看一下输出 12lijun:class6/ $ go run class6_demo.go [17:05:26]lijun:class6/ $ 还是没有。再加一句这个 12345678func main() { for i := 0; i &lt; 10; i++ { go func(a int) { fmt.Println(a) }(i) } time.Sleep(time.Second*1)} 打印一下输出 1234567891011lijun:class6/ $ go run class6_demo.go [17:11:34]5107869342 有了！为什么会这样？我记得之前学 Python 的时候，在用多线程的时候也碰到了这样的情况，当时举得例子都差不多，要么用时间函数延迟 1s，要么加到守护线程了。不然子线程会随着主线程的执行结束而全部销毁，就什么都不干了。 所以结论会出现一开始什么都不输出的情况是主线程结束运行了，但是 goroutine 函数还没有执行！ 为什么会没有执行呢？这里我们要理解一下 goroutine 的概念 Don’t communicate by sharing memory; share memory by communicating. 这是 Go 语言的核心所在：不要通过共享内存来通讯，而应该通过通讯来共享内存 channel+goroutine 组成了Go语言中的并发编程模式（有别于其他语言的多线程）其中 goroutine 就代表着并发编程模型中的用户级线程 所谓的用户级线程指的是架设在系统级线程之上的，由用户（或者说我们编写的程序）完全控制的代码执行流程。用户级线程的创建、销毁、调度、状态变更以及其中的代码和数据都完全需要我们的程序自己去实现和处理。这带来了很多优势，比如，因为它们的创建和销毁并不用通过操作系统去做，所以速度会很快，由于不用等着操作系统去调度它们的运行，所以往往会很容易控制并且可以很灵活。 与之对应的就是系统级线程。在 Go 语言当中，运行时（runtime）系统会帮助我们自动创建和销毁系统级线程（由操作系统提供）。 用户级线程相比于系统级线程，最明显也最重要的一个劣势就是复杂。如果我们只使用了系统级线程，那么我们只要指明需要新线程执行的代码片段，并且下达创建或销毁线程的指令就好了，其他的一切具体实现都会由操作系统代劳。但是使用用户级线程的话，既是指令下达者，又是指令执行者。我们必须全权负责与用户级线程有关的所有具体实现。操作系统不但不会帮忙，还会要求我们的具体实现必须与它正确地对接，否则用户级线程就无法被并发地，甚至正确地运行。毕竟我们编写的所有代码最终都需要通过操作系统才能在计算机上执行 幸好 Go 语言提供了一个强大的用于调度 goroutine、对接系统级线程的调度器。它主要负责统筹调配 Go 并发编程模型中的三个主要元素，即：G（goroutine 的缩写）、P（processor 的缩写）和 M（machine 的缩写）。M指代的就是系统级线程，多线程的目的就是合理的分配调度多核CPU的资源，所以三者的关系如下图所示系统会有一个 goroutine 队列，每一个 goroutine 函数都会把它放到这个队列中，由 M 分配到的 P 来一个一个处理 G，如果处理的 G 是耗时很长（如I/O操作或锁的接触）的话，这个 G 就会放在当前的 M 里面休眠，等待它执行完毕之后再唤醒放到队列中继续等待被分配 M 和 P 执行，此时 P 就会转到其他的 M 中继续从队列中获取 G 执行另外，当 M 不够用时，调度器会帮我们向操作系统申请新的系统级线程，而当某个 M 已无用时，调度器又会负责把它及时地销毁掉。 主goroutine回到我们一开始的代码 1234567func main() { for i := 0; i &lt; 10; i++ { go func() { fmt.Println(i) }() }} 与一个进程总会有一个主线程类似，每一个独立的 Go 程序在运行时也总会有一个主 goroutine。这个主 goroutine 会在 Go 程序的运行准备工作完成后被自动地启用，并不需要我们做任何手动的操作。相信大家也看出来了，这个主 goroutine 的 go 函数（每条 go 语句都会携带一个函数调用，称为 go 函数）就是我们的 main 函数一定要注意，go函数真正被执行的时间总会与其所属的go语句被执行的时间不同。当程序执行到一条go语句的时候，Go 语言的运行时系统，会先试图从某个存放空闲的 G 的队列中获取一个 G（也就是 goroutine），它只有在找不到空闲 G 的情况下才会去创建一个新的 G。拿到一个空闲的 G 之后，Go 语言运行时系统会用这个 G 去包装当前的那个go函数（或者说该函数中的那些代码），然后再把这个 G 追加到某个存放可运行的 G 的队列中。队列中的G按照先入先出的顺序，由运行时系统内部的调度器安排运行，虽然很快，但还是会有耗时。所以 go 函数的执行时间才会滞后于它所属 go 语句的执行时间。go 语句本身执行完毕后，它不会等待 go 函数执行（异步并发），而是继续执行后面的语句。这就出现了上面的情况：主 goroutine 中的代码执行完毕，Go 程序就运行结束，程序都结束了，当然就没有那些子 goroutine，更谈不上执行了。 所以解决方案就是延迟主 goroutine 的执行结束时间，这样 gotoutine 就有机会执行了。上面用的是 time.Sleep，但还有更好的方案，使用 sync.WaitGroup，这里大家自己查找资料了解 1234567891011func main() { var wg sync.WaitGroup for i := 0; i &lt; 10; i++ { wg.Add(1) go func() { fmt.Println(i) wg.Done() }() } wg.Wait() } 最终目的都是等待所有子 goroutine 执行完毕主 goroutine 才结束。 搞清楚了上面那些，现在看一下输出结果1234567891011lijun:class6/ $ go run class6_demo.go [18:33:03]8101010101010101010 输出和预期的完全不一致。emmm~ 根据上面的了解，goroutine 的执行是有滞后性的，但是这种滞后性是不确定的。同时，调度器在分配 G 给每个 M 通过 P 执行的时候，虽然 G 在队列里按照先进先出的顺序拿出来，但是如何分配它是根据当前的各种资源调度情况来的，也就是说那个 G 先分配先执行完都不确定。除非人为干预（好像我也不知道怎么人为干预😂） 所以，滞后性让它的输出不可能是1,2,3,4…10，可能是5,8,10,10…10这样，同时不确定性又让每个 goroutine 执行的时机不一样，所以也有可能像这样 1234567891011lijun:class6/ $ go run class6_demo.go [18:33:19]51051010101081010 而且由于上面的 go 函数中引用的是外部变量 i，可能情况就是：1.当 go 函数所在语句执行结束后，goroutine 才执行，此时 i 变量已经是10了2.当 go 函数所在语句还没有执行结束，goroutine 开始执行了，由于执行的时机不同，每个 go 函数获取的 i 变量可能是 5， 8，10这些。 ####如何让它正确输出 1234567891011func main() { var wg sync.WaitGroup for i := 0; i &lt; 10; i++ { wg.Add(1) go func(a int) { fmt.Println(a) wg.Done() }(i) } wg.Wait() } 通过给函数传值！go 函数中，大多数参数都是值传递的，即会拷贝一份副本给函数，此时外界的变量和这个参数就没有任何关系了。这时候就能正确的打印。 1234567891011lijun:class6/ $ go run class6_demo.go [18:35:52]5239671804 但是执行顺序还没有解决，这个问题留到后面解决吧！ 以上是我通过一个 goroutine 的例子带来的思考以及学习过程，仅供大家思考！","link":"/2019/08/23/2019-08-23-01/"},{"title":"关于Go的四种字符串拼接及性能比较","text":"先上代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// fmt.Sprintffunc BenchmarkStringSprintf(b *testing.B) { b.ResetTimer() for i := 0; i &lt; b.N; i++ { var str string for j := 0; j &lt; numbers; j++ { str = fmt.Sprintf(\"%s%d\", str, j) } } b.StopTimer()}// addfunc BenchmarkStringAdd(b *testing.B) { b.ResetTimer() for i := 0; i &lt; b.N; i++ { var str string for j := 0; j &lt; numbers; j++ { str = str + string(j) } } b.StopTimer()}// bytes.Bufferfunc BenchmarkStringBuffer(b *testing.B) { b.ResetTimer() for i := 0; i &lt; b.N; i++ { var buffer bytes.Buffer for j := 0; j &lt; numbers; j++ { buffer.WriteString(strconv.Itoa(j)) } _ = buffer.String() } b.StopTimer()}// strings.Builderfunc BenchmarkStringBuilder(b *testing.B) { b.ResetTimer() for i := 0; i &lt; b.N; i++ { var builder strings.Builder for j := 0; j &lt; numbers; j++ { builder.WriteString(strconv.Itoa(j)) } _ = builder.String() } b.StopTimer()} 运行结果1234567891011lijun:benchmark/ $ go test -bench=. [10:01:20]goos: darwingoarch: amd64pkg: class12/benchmarkBenchmarkStringSprintf-4 30 47358694 ns/opBenchmarkStringAdd-4 50 27664814 ns/opBenchmarkStringBuffer-4 10000 184422 ns/opBenchmarkStringBuilder-4 10000 157039 ns/opPASSok class12/benchmark 6.350slijun:benchmark/ $ [10:01:58] 如果还不知道 Go 的 benchmark，可以先去了解一下，个人认为还是非常不错的性能测试的工具。 得出结论四种拼接字符串的方式，性能比较结果strings.Builder &gt; bytes.Buffer &gt; string add &gt; fmt.Sprintf 为什么？这里我们还是直接看源码吧 先看 Sprintf12345678// Sprintf formats according to a format specifier and returns the resulting string.func Sprintf(format string, a ...interface{}) string { p := newPrinter() p.doPrintf(format, a) s := string(p.buf) p.free() return s} 这是 fmt.Sprintf 的源码，我们可以看到内部会通过 newPrinter 创建一个新对象 p，点进去看一下 newPrinter 这个函数 12345678// newPrinter allocates a new pp struct or grabs a cached one.func newPrinter() *pp { p := ppFree.Get().(*pp) p.panicking = false p.erroring = false p.fmt.init(&amp;p.buf) return p} 它会从系统的临时对象池中那 pp 这个对象，关于临时对象池（sync.Pool)，下次有机会再探讨。这里可以知道， Sprintf 会从临时对象池中获取一个 *pp 的指针，然后再做一些格式化的操作，doPrintf 代码就不贴了，格式化后的底层字节会放到 []byte 这个切片里面，最后再 string 转换成字符串返回，并且释放掉 p 对象。整个过程：创建对象 - 格式化操作 - string化 - 释放对象 接下来看 stringstring 是在 Go 里面是一个不可变类型，所以下面的代码 1str = str + str2 每次都会创建一个新的 string 类型的值，然后重新赋值给 str 这个变量，相比于上面的 Sprintf 主要少了格式化这个过程，所以在性能上肯定要优于 Sprintf bytes.Buffer我们看一下 builder 的 String() 函数源码 1234567891011// String returns the contents of the unread portion of the buffer// as a string. If the Buffer is a nil pointer, it returns \"&lt;nil&gt;\".//// To build strings more efficiently, see the strings.Builder type.func (b *Buffer) String() string { if b == nil { // Special case, useful in debugging. return \"&lt;nil&gt;\" } return string(b.buf[b.off:])} 字符串的底层结构是一个 []byte 的字节序列，而 Buffer 是直接获取未读取的 []byte序列，在转成 string 返回，少了重复创建对象这个步骤。b.buf 是 []byte 切片b.off 是已读取的字节位置 strings.Builder1234// String returns the accumulated string.func (b *Builder) String() string { return *(*string)(unsafe.Pointer(&amp;b.buf))} strings.Builder 直接通过指针来操作了，在效率上更进一步。 总结通过源码来分析，还是比较清晰明了的，但是限于我自身的水平，对于源码的解读并不都是特别深入，这里也是给大家做出一个参考。关于最后的通过转换成指针来返回字符串的操作，我也就是知道转成指针效率会高，但是关于为什么，也都是模棱两可（是因为直接通过操作内存地址吗）。总之关于基础性、底层的东西还是要多多学习。","link":"/2019/08/29/2019-08-29/"},{"title":"go flag包使用","text":"Go是怎么接受外部的命令行参数的？ 在Python中有 sys 模块下的 sys.args 可以获取命令行列表，与之对应的，Go 也有一个 flag 包来获取 使用 flag 包获取参数需要哪几个步骤？ 导入 flag 包 初始化变量用来存储外部的命令 flag 包的配置工作，比如要接收哪些参数等等 在前面的准备工作做完之后，要在最后阶段 flag.Parse() 123456789101112131415import ( \"flag\")var name stringfunc init() { flag.StringVar(&amp;name, \"name\", \"everyone\", \"The greeting object.\")}func main() { // Parse 函数必须放在变量声明和 flag 设置之后调用 flag.Parse() fmt.Printf(\"Hello, %s!\\n\", name)} flal.StringVar 接收4个参数 用于存储该命令参数的值的地址 获取的外部命令参数的名称 在未追加该命令参数的默认值 该命令的简短说明，在 go run xx.go –help 时会输出 name 的赋值方式，除了上面的 StringVar 之外，还有一个 String 函数也可以 12// 通过返回值的方式var name = flag.String(\"name\", \"everyone\", \"The greeting object.\") 设置完，这样调用就完成了一个最简单的读取命令行参数的功能 12345678910111213141516go run test.go -name=Lee// &gt;&gt; Hello, Lee!// 没有指定 name 参数，会输出默认值 everyonego run test.go// &gt;&gt; Hellp, everyone!// 指定了没有配置的参数，会报错，这个报错的形式如果没有指明的话，就会采取默认的说明go run test.go -a=1&gt;&gt; flag provided but not defined: -a Usage of question: -name string The greeting object. (default \"everyone\") exit status 2// 这里就用到了 StringVar / String 的第三和第四个参数了 如果我们想自定义说明呢？很简单，只要实现 flag.Usage 函数就行了 1234flag.Usage = func() { fmt.Fprintf(os.Stderr, \"usage of %s:\\n这是我自定义的输出信息\\n\", \"question\") flag.PrintDefaults()} 这时候调用 1&gt;&gt; go run test.go --help 输出信息 12345Usage of question:这是我自定义的信息 -name string The greeting object. (default \"everyone\")exit status 2 变量名、描述、默认值是固定不变的，但是上面的信息可以自定义 上面在调用 StringVar、Parse 等等的函数的时候。实际上是在调用 flag.CommandLine 变量的对应方法 1234567891011121314// flag.ExitOnError 表示是以什么样的形式推出程序，还有 flag.PanicOnErrorflag.CommandLine = flag.NewFlagSet(\"\", flag.ExitOnError)flag.CommandLine.Usage = func() { fmt.Fprintf(os.Stderr, \"Ueage of %s\\n\", \"question\") flag.PrintDefaults()}// 创建自己私有的命令参数容器var cmdLine = flag.NewFlagSet(\"question\", flag.ExitOnError)// 用自己自定义的命令参数cmdLine.StringVar(&amp;name, \"name\", \"everyone\", \"The greeting object.\")cmdLine.Parse(os.Args[1:]) // [1:]第一个元素是文件本身，所以要从1开始 以上关于flag的使用只是做一些简单介绍，具体的大家可以去看一下官方文档做深入了解","link":"/2019/08/21/2019-08-21/"},{"title":"位运算的几种应用","text":"例1：不借助临时变量，交换两个数的值思路：通过异或，先求出两个变量的不同的位 123456var a = 10var b = 8a = a ^ bb = a ^ ba = a ^ b 例2：求一个UInt二进制数中1的个数思路：比如一个 1011 0100 这个二进制数，先用 1(0000 0001)和它做”与”操作，如果结果为 1，说明在最右边的这一位是 1，继续把 1 左移 1 位重复比较 123456789101112func getCountOfOne(num: UInt) -&gt; UInt { var count: UInt = 0 var temp = num var loopCount = 0 while temp != 0 { count += (temp &amp; 1) temp = (temp &gt;&gt; 1) loopCount += 1 } print(\"loop1 count: \\(loopCount)\") return count} 上述算法有一个可以优化的地方，当有这样一个数 1100 0000，如果还是从最右边往左判断的话，有大量的 0 是没有必要的，我们可以从左边开始，让 num 和 num-1 这两个数做”与”运算，如果结果为 0，则说明这个数后续已经没有 1 了，反之继续比较 123456789101112func getCountOfOne2(num: UInt) -&gt; UInt { var count: UInt = 0 var temp = num var loopCount = 0 while temp != 0 { count += 1 temp = temp &amp; (temp-1) loopCount += 1 } print(\"loop2 count: \\(loopCount)\") return count} 例3：判断一个UInt数是否为2的整数幂次方思路：能成为 2 的整数次幂的数，其二进制一定是这种类型的：1000 0000，如果 1000 0000 和它的 -1 后的数 0111 1111 做”与”操作，结果就是 0 123func isPowerOfTwo(num: UInt) -&gt; Bool { return (num &amp; (num-1)) == 0} 例4：找丢失数 一堆成对出现的数：1，2，3，4，3，2，1，找出其中缺失的一个数 思路：给定一个初始值，和数组里面的所有数做”异或”操作，成对出现的数和0做完异或操作后，结果依然是0，最后缺失的那个数4和0做异或操作，结果依然是4 1234567func findLostNum(nums: [UInt]) -&gt; UInt { var lostNum: UInt = 0 for num in nums { lostNum = lostNum ^ num } return lostNum} 如果有两个数缺失呢？ 思路：分两组来计算。先求他们的异或结果，然后找出可以区分缺失的两个数的最右边为1的位的flag（缺失的两个数最右侧为1的位数肯定是不一样的），遍历数组，根据num和flag的”与”运算是否为0，分为2组，分别做异或运算，这里就和上面的过程一致了。 1234567891011121314151617181920212223func findTwoLostNums(nums: [UInt]) -&gt; (UInt, UInt) { var num1: UInt = 0 var num2: UInt = 0 var temp: UInt = 0 for num in nums { // 得到缺失的两个数的结果 temp = temp ^ num } // 找到最后为1的位 var flag: UInt = 1 while (flag &amp; temp) == 0 { flag = flag &lt;&lt; 1 } // 找两个丢失的数字 for num in nums { if (flag &amp; num) == 0 { num1 = num1 ^ num } else { num2 = num2 ^ num } } return (num1, num2)}","link":"/2019/09/07/2019-09-07/"},{"title":"这3个月20天都是怎么度过的","text":"起因9月份找了很要好的，也是在这个行业很有想法有能力的一位前辈，聊了聊我当时对自身工作的想法和对未来的渴望。我当时一门心思想转后端，所以天天看Go，看后端有关的知识，但是说实话学的还是有点乏力或者说困顿，受困于当时的环境，对于iOS方面的学习没有再投入多少精力。随着学习的深入和难度增加，迷茫和烦躁越来越多，不知道明年如果转行前景怎么样，转后端意味着重头再来，工资啥的和iOS肯定没发比，继续干iOS又觉得天花板比不过后端，在这种患得患失间，内心无比煎熬纠结。好友张算是我入这行的指路明灯吧，从我刚毕业加入七行就认识到现在，他先我一步到杭州，机缘巧合我也来到了这座城市，也算是缘分，所以我当时迫切的需要他的一些看法，当局者迷旁观者清，他的经验还是颇丰的。一番交流下来，却是给了我一条最优的方案。 他一上来就给我泼了一盆冷水，说明年直接转后端不太现实，毕竟没有什么经验，之前一直干iOS，难度太大。点醒我的一句话是这个行业公司看中的更是你在某个方面的精通，而不是你会多少种语言。公司是不缺人的，只缺能干事的有能力的。指明我现在更应该做的是在iOS这方面更加深入，毕竟这是拿高工资的最有效的方法，想转后端是好的，但是最好以后找一个能够内部转岗的公司，自己私底下也是可以学习后端，开发一些后端的产品。相对于我目前来说这是最合适的路子了。说实话我跟他聊完之后确实也感觉我今年的目标订的不太好。盲目的转后端，在iOS方面没有继续深入，万一明年后端没找到，就算找到了也只是从头再来工资待遇都会下降，iOS也没做的更好，满盘皆输。而且给自己的压力也太大了。 我迷茫了当暂停了后端的学习后，每天感觉要看的要学习的一下子减少了很多，导致一下子松懈下来。恰逢公司的业务也基本上到了日常维护的状态，没有新项目新任务，每天上班也不知道干什么。日常学习又因为一下子的放松无以为继，上班就成了划水，上午刷刷微博，贴吧，NGA，有湖人比赛就看比赛，下午刷刷知乎，晚上回去和小伙伴们打打游戏。这种日子我以前想都不敢想，提前进入养老模式啊。。。因为之前的计划破产了，只知道该深入学习iOS，却又没有具体的实施安排，日子就这样一天天的过去，博客也停更，当我回过神觉得不行的时候，都TM到12月了。每天这样无脑的不知道干什么，这种日子是相当难熬的，浑浑噩噩我算是真实体会到了一把。 坚持啊做任何事贵在坚持，嘴里都在说，身体却没在做，我觉得这是所有庸庸碌碌平凡的人的一种通病。从小到大验证了无数次，高考、大学六级、考试、比赛，可还是会重蹈覆辙。听过这样一句话：这个世界90%的人都没有努力，你努力下去就超越90%的人了。对一件事坚持投入，努力不放弃，时间长了自然能发现它带给你的回报。那种巨大的满足感我深有体会，那也是我从小打到唯一经历的一次，之后就又陷入了这种平凡病。我是不想再三分钟热度的，这句话我感觉对自己说了无数次，但这次一定会不一样。 所以，请一定要坚持下去我自制力不是特别强，受环境的影响很大，学生那段时间父母没有给过我很大压力，自己也总是那种得过且过，随遇而安的性子，知道毕业后为了工作为了自己的程序员梦，才有了那段去追梦的时光，付出了也收获了，至今回想起来依然觉得幸福。可是先天的缺陷（没考上好大学）也让自己处于竞争劣势，需要更多的努力才能弥补，但是后来的日子又归于平凡了。现在想想，当初毕业后应该是直接去大城市的，去北京去上海、杭州，后面的发展可能会好点。在合肥这样的IT不怎么发达的二线城市，对于致力于在合肥发展家里有条件资助买房结婚的人来说或许可以，但是像我这样的情况那三年时间有点浪费。要拼搏要发展还是应该去大城市。索性来杭州还不算太晚，还有机会，但是呢，自己不努力自己不争气就什么都没了。在此想说一句：这家公司太闲了，真的太闲了！！！适合养老。。。所以啊，小伙子还是应该努力的啊。想想自己现在的情况，想想以前的经历，余地已经越来越少，脱离平凡的机会越来越少，不能再拉胯了啊。 今后，该怎么走现在又冒出了一个想法，经常看到网上说程序员的中年危机，三十多岁被公司优化掉，心里也常有危机，就想学个副业能在空余时间挣点钱（也是因为闲的+看到朋友圈里某某做微信公众号风生水起，月入上万）。前几天又和朋友聊了聊，又给我点醒了，哈哈，感谢他，在合肥能认识杰哥算是我最幸运的一件事了。我还是应该把iOS的工作做得更好，对iOS的学习更加深入才行，在现在行业发展的这么快，各种工具、技术应接不暇，iOS也不是像之前远古时期那样会点基础的就可以找一个不错的工作，现在公司要的都是专精的人才，对性能优化有更高的要求，因为对于业务来说，都是画UI写点业务代码，这谁都会做，再不济GitHub一大堆成熟的开源代码，开箱即用，这种人公司最不缺，我应该要做的是先结合极客时间的课程，深入底层，做到专精。网络，多线程（GCD，NSOperation，NSThread），音视频，NSRuntime，NSRunLoop，优化，监控。。。。。。把这些精通了我觉得在杭州找个15k左右的还是没问题的，这也是我明年的目标。 后端，我不想放弃我选择程序员的最初梦想，就是当一个全栈工程师，以前是想当一个工作上的全栈，现在知道了这个想法的不切实际，那我最起码要当一个私底下的全栈，工作上我可以精通一个iOS，私底下我更想玩服务器，玩后端，玩网站，所以我不会放弃这方面的学习。基础的知识：网络，数据结构与算法，后端语言（Go，Python），NGINX，数据库这些我还是会学，只不过是在不占用iOS学习的基础上。 把自己的知识技能变现这也是明年要做的事情，未来的收入不可能只靠工资，一眼望到头，有必要发展别的赚钱途径。以这篇文章为起点，如果之后还做不到中途放弃耽误的话，这个博客网站干脆就关掉吧。 最后时日于你无多，劝君珍惜。以此谨记！","link":"/2019/12/27/2019-12-27-01/"},{"title":"Run Loops 翻译篇","text":"Run Loops官方文档 Run Loops 是与线程相关的基础架构的一部分。一个 run loop 是一个事件处理循环，你使用来调度工作和协调收到的事件。run loop 的目的是有工作做的时候保持线程忙碌，没有事做的时候让线程睡眠。Run loop 的管理并不是全自动的。你仍然必须设计你的线程在合适的时候启动 run loop 并响应即将到来的事件。Cocoa 和 Core Foundation 都提供了 run loop 对象来帮助配置和管理线程的 run loop。你的应用不需要显式的创建这些对象；每个线程，包括应用的主线程，有一个相关联的 run loop 对象。只是非主线程需要显式的跑它们的 run loop。App 框架会自动设置并跑起主线程上的 run loop，作为应用启动的一部分。下面的部分提供了更多关于 run loops 的信息，怎么为你的应用配置它们。需要查看更多的信息，可以参见NSRunLoop Class Reference 和 CFRunLoop Reference Run Loops 的剖析run loop 非常的人如其名。它是一个线程进入并调用事件 handler 来响应事件的循环。你的代码提供用来实现 run loop 的 loop 部分的控制语句 —— 换句话就是，你的代码提供了 while 或 for 循环来驱动 run loop。在你的循环内，你使用一个 run loop 对象来跑收到事件的事件处理代码，并调用安装的 handlers。一个 run loop 从两种不同类型的 source 接受事件。input source 传递异步事件，通常消息来自其它线程或不同应用。timer source 传递同步事件，发生在规划的时间点或重复的间隔。两种类型的 source 使用应用特定的 handler 函数来处理这些到来的事件。下图展示了一个 run loop 和各种 sources 的概念图。Input source 传递异步事件到相应的 handler，导致 runUntilDate (在线程关联的 NSRunLoop 对象上执行) 方法退出。Timer sources 传递事件到它们的 handler 函数但不导致 run loop 退出。 除了处理输入的源外，run loop 会产生关于 run loop 行为的通知。这些通知的观察者可以收到这些通知，使用它们在线程上进行额外的处理。你可以使用 Core Foundation 来安装线程上的 run loop observer。 下面的部分提供了 run loop 组件的更多信息，它们工作的 modes。也描述了在处理事件的不同阶段产生的通知。 Run Loop Modes一个 run loop mode 是一个被监听的 input source 和 timer 的集合和需要被通知的 run loop observers 的集合。每次你跑你的 run loop 的时候，你指定 (显式或隐式的) 特定的 mode 来跑。在 run loop 的这次跑的过程中，只有那些与指定 mode 关联的被监听的 source 允许传递它们的事件 (同样，只有那些与该 mode 关联的 observers 被通知 run loop 的进程)。与其他 mode 相关联的 sources 会维持住任何新事件，直到 run loop 以指定的 mode 通过 loop 的时候才处理。 在你的代码中，你通过名字来标识 modes。Cocoa 和 Core Foundation 定义了一个默认 mode 和几个通用 modes，通过字符串在代码中指定这些 modes。你可以自定义 mode，只需要给自定义的 mode 指定一个自定义字符串就可以。尽管你赋给自定义 mode 的字符串是随意的，但是 mode 的内容却不是。你必须添加一个或多个 input sources，或 run-loop observers 到任何你创建的 mode 上，这样它们才是有用的。 在 run loop 的一个 pass through 中你可以使用 modes 从你不想要的 sources 中过滤出事件。大部分时候，你会想要你的 run loop 对象跑在系统定义的默认�模式。然而一个 modal panel 也许跑在 “modal” mode。在这个 mode 时，只有那些和 modal panel 相关的 sources 会给线程传送事件。对于非主线程，你也需要使用自定义的 modes 来阻止低优先级的 sources 在关键操作时传送事件。 注意: modes 的区别在于事件的 source，不在于事件的类型。例如，你不会使用 mode 来单独匹配 mouse-down 事件或键盘事件。你可以使用 modes 来监听不同的 ports，暂停 timers，或改变目前被监听的 sources 和 run loop observers 下表列出了 Cocoa 和 Core Foundation 定义的标准 modes，和什么时候使用这些 mode 的说明。name 列列出了你在代码中真实指定的常量。 Mode Name Description Default NSDefaultRunLoopMode (Cocoa) kCFRunLoopDefaultMode (Core Foundation) 大部分操作使用这个 mode。大部分时候你使用这个 mode 来启动你的 run loop 和 配置你的 input sources。 Connection NSConnectionReplyMode (Cocoa) Cocoa 使用这个 mode 和 NSConnection 对象来监听返回。你基本不会自己用到这个 mode。 Modal NSModalPanelRunLoopMode Cocoa 使用这个 mode 来标识专用于 modal panels 的事件。 Event tracking NSEventTrackingRunLoopMode (Cocoa) Cocoa 使用在 mouse-dragging loops 或其它用户交互的 tracking loop 中使用这个 mode 来限制收到的事件。 Common Modes NSRunLoopCommonModes (Cocoa) kCFRunLoopCommonModes (Core Foundation) 这是一个可配置的常用 mode group。与这个 mode 相关联的 input source 也会和这个 group 中的 modes 相关联。对于 Cocoa 应用而言，这个集合默认包括 default，modal，event tracking 这些modes。Core Foundation 初始的时候包含 default 的mode。你可以使用 CFRunLoopAddCommonMode 函数添加自定义 mode 到这个集合。 Input SourcesInput sources 传递异步事件到线程。事件的来源依赖于你的 input source 的类型，input source 的类型通常是两类之一。基于 Port 的 input source 监听应用的 Mach ports。自定义 input sources 监听自定义事件来源。你的 run loop 不需要关心 input source 是自定义的还是基于 port 的。系统通常实现了两种类型的 input sources，你可以直接拿来用。这两种类型 input sources 的唯一区别是它们怎么被发送信号了。基于 Port-based input source 自动被内核发送信号，而自定义的 input source 必须手动的从另一个线程发送信号给它。 当你创建一个 input source 的时候，你赋给它一个或多个你的 run loop 的 modes。Modes 会影响在某刻哪些 input sources 被监听。大部分时候，你会将你的 run loop 跑在 default mode，但是你也可以指定自定义 modes。如果你一个 input source 目前没有在被监听的 mode 中，任何它产生的事件会被维持住直到 run loop 跑在正确的 mode 时。 基于 Port 的 SourcesCocoa 和 Core Foundation 提供了使用 port 相关的函数和对象创建 port-based input sources 的内建支持。例如，在 Cocoa 中，你从不需要直接创建一个 input source。你简单的创建一个 port 对象，使用 NSPort 的方法添加这个 port 到 run loop。这个 port 对象会为你负责创建和配置所需的 input source。 在 Core Foundation 中，你必须手动创建 port 对象和它的 input source。两种情况你都需要使用 port opaque type 相关的函数 CFMachPortRef, CFMessagePortRef, CFSocketRef) 来创建合适的对象。 自定义 Input Sources创建一个自定义 input source，你必须使用 Core Foundation 中 CFRunLoopSourceRef opaque type 相关的函数。你通过使用几个回调函数来创建自定义 input source。Core Foundation 在不同点调用这些毁掉函数配置 input source，处理到达的事件，释放 input source 当 input source 从 run loop 移除的时候。 除了定义事件到来时自定义 input source 的行为外，你也必须定义事件传递的机制。Input source 的这部分跑在单独的线程上，负责给 input source 提供数据，当数据可用的时候发送信号给 input source 来告知它。事件交付机制是由你决定的，但不要太过复杂。 Cocoa Perform Selector Sources除了基于 port 的 source 外，Cocoa 定义了一个自定义 input source，你可以是用来在任一线程执行一个 selector。跟 port-based input source 相似，执行 selector 的请求在目标线程上是串行的，减去了多个 method 在一个线程上执行时可能发生的同步问题 (请看原文，这里不确定翻译得是否准确，因为一个线程上执行多个方法是没有问题的啊)。跟 port-based source 不同的是，一个 perform selector source 会在它执行了它的 selector 之后从 run loop 中移除自己。 注意: 在 OSX v10.5 之前，perform selector source 大部分用在给主线程发送消息，但是在 OS X v10.5 之后和 iOS 中，你可以使用它们给任何线程发送消息。 当在另一个线程执行 selector 时， 目标线程必须有一个 active 的run loop。对于你创建的线程，这意味着等到你显式的启动 run loop。因为主线程会启动自己的 run loop，因此，在应用调用了application delegate 的 applicationDidFinishLaunching: 方法后， 你就可以给主线程发送调用了。run loop 在一次 loop 迭代中处理掉所有排好队的 perform selector calls，而不是每次 loop 迭代只处理一个。 下表中列出了 NSObject 上可以用来在其它线程上 perform selector 的方法。因为这些方法在 NSObject 上申明，你可以在任何可以访问 Objectvie-C 对象的地方使用这些方法，包括 POSIX 线程。这些方法并不创建线程类执行 selector。 Methods Description performSelectorOnMainThread: withObject: waitUntilDone: performSelectorOnMainThread: withObject:waitUntilDone:modes: 在应用的主线程上的下次 run loop 迭代中执行指定的 selector。这些方法允许你选择是否阻塞当前线程直到 selector 被执行。 performSelector: onThread:withObject: waitUntilDone: performSelector: onThread:withObject:waitUntilDone:modes: 在 NSThread 对象指定的线程上执行指定的 selector。这些方法允许你选择是否阻塞当前线程直到 selector 执行完。 performSelector: withObject: afterDelay: performSelector: withObject: afterDelay:inModes: 在当前线程的下次 run loop 迭代中执行指定的 selector，可以指定可选的 delay 时间。因为它会等到下次 run loop 迭代，这些方法天然的有一个 mini delay 相对于目前执行的代码。多个排好队的 selectors 以它们排队的顺序执行。 cancelPreviousPerformRequestsWithTarget: cancelPreviousPerformRequestsWithTarget:selector:object: 让你取消使用 performSelector: withObject: afterDelay: 或 performSelector: withObject: afterDelay:inModes: 发送给一个线程的消息。 Timer SourcesTimer source 在未来的某个时刻发送同步事件到线程。Timers 是一种线程通知自己做些什么的一种方式。例如，一个搜索框使用一个 timer 来发起自动的搜索，一旦用户输入超过一段时间。这样的延迟给用户足够多的时间输入足够多的字符。 尽管它产生基于时间的通知，一个 timer 并不是一个实时的机制。跟 input source 一样，timers 是跟特定的 run loop modes 相关联的。如果一个 timer 不在 run loop 目前监听的 modes 中时，它会等待 run loop 跑在 timer 关联的 modes 时才 fire。同样，如果你一个 timer fire 了，但是 run loop 正在执行一个 handler 函数的过程中，timer 会等到 run loop 的下次迭代，再调用它的 handler 函数。如果 run loop 不运行了，timer 永远都不会 fire。 你更可以配置 timer 单次或重复的产生事件。一个重复的 timer 自动的基于调度的 fire time 来重新规划它的 fire 时间，而不是真正的 fire time。例如，一个 timer 规划在某个时刻和这个时刻之后的每 5 秒 fire，那么规划的 firing time 总会在原来的 5 秒间隔，即使真正的 firing time 被延迟了。如果 firing time 被延迟得超过了好几个规划的 firing times 的话，timer 对于错过的时间段只会 fire 一次。在为错过的时间 fire 之后，timer is rescheduled for the next scheduled firing time. Run Loop Observer相对于当异步或同步事件发生的时候 fire 的 sources，run loop observers 是 run loop 自身执行的特殊位置 fire。你可能使用 run loop observers 来准备好线程处理一个给定的事件，或准备好线程进入睡眠。你可以关联 run loop observers 到 run loop 的以下事件： 进入 run loop Run loop 准备开始处理一个 timer Run loop 准备开始处理一个 input source Run loop 准备进入睡眠状态 当 Run loop 被唤醒时，但在处理唤醒它的事件前 从 run loop 退出 你可以使用 Core Foundation 添加 run loop observers。要创建一个 run loop observer，你可以创建一个 CFRunLoopObserverRef opaque type 的实例。这个类型持有你自定义的回调函数和你敢兴趣的行为的记录。 和 timers 相似，run-loop observers 可以被一次或重复的使用。一个一次的 observer 会在 fire 后从 run loop 移除，然而一个重复的 observer 会持续附着在 run loop 上。在创建它的时候你指定一个 observer 是否跑一次还是重复的跑。 Run Loop 事件的顺序每次你跑 run loop，线程的 run loop 处理待处理的事件，给任 observers 产生通知。这些的顺序如下： 通知 observers run loop 已经进入 通知 observers 任何 timers 准备 fire 通知 observers 任何不是基于 port 的 input source 准备 fire 了 Fire 任何非基于 port 准备好 fire 的 input sources 如果一个基于 port 的 input source 准备好并等待 fire 的话，立即处理事件，跳到步骤 9 通知 observers 线程将要睡眠 将线程置为睡眠状态，直到以下事件发生： 一个给 port-based input source 的事件到达 一个 timer fires 给 run loop 设置的 timeout 值超时了 run loop 被显式的唤醒 通知 observers 线程刚被唤醒 处理待处理的事件 如果用户定义的 timer fired，处理 timer 事件并重启 loop。跳到步骤 2 如果一个 input source fired，处理 ( deliver 原文) 事件 如果 run loop 显示的被唤醒但是还没有 time out，重启 loop。跳到步骤2 通知 observers run loop 已经退出 因为 timer 和 input sources 的 observer 通知在事件发生之前被传递，可能在通知的时间和事件发生的时间之间有时间间隙。如果在这些事件之间的计时很重要的话，你可以使用 sleep 和 awake-from-sleep 通知来帮助纠正真实时间的计时。 因为 timers 和其他间隔事件是当你跑 run loop 的时候传递，绕过 run loop 会干扰这些事件的传递。这种行为发生的典型例子是你实现一个鼠标追踪的程序时，你的代码在进入 loop 中后，不断的重复的从应用中请求事件。因为你的应用直接拿取事件，而不是让应用正常的分发这些事件，active timers 将不能正常的 fire 直到你追踪鼠标的代码退出，并将控制返回给应用。 一个 run loop 可以显式的唤醒 run loop 对象。其它时间可能引起 run loop 被唤醒。例如，添加另一个不基于 port 的 input source 会唤醒 run loop，从而 input source 可以立即被处理，而不是等待直到其它的事件到达。 什么时候使用一个 Run Loop唯一需要显式跑一个 run loop 的时候是你为你的应用创建非主线程的时候。应用主线程的 run loop 架构中的关键部分。结果是，app 框架提供了自动跑起主线程 run loop 的代码。UIApplication 的 run 方法启动了应用主线程的 run loop，作为应用启动的一部分。如果你使用 Xcode 模板项目来创建你的应用，你应该永远都不会显式调用这些函数。 对于非主线程，你需要决定一个 run loop 是否必要，如果是的，配置并启动它。你并不是总是需要启动线程的 run loop。例如，如果你使用一个线程执行一些长时间的具体任务，你可能会避免启动一个 run loop。Run loop 适用于你想要跟线程有更多交互的场景。例如，你需要启动一个 run loop如果你计划做以下事之一： 使用 ports 或自定义 input sources 来与其它线程通讯 在线程上使用 timers 在 Cocoa 应用中使用任何 performSelector… 方法 维持住线程来进行间隔的任务 如果你确定使用 run loop，配置和启动是很直接的。跟所有的多线程编程一样，你应该计划在合适的时机退出线程。干净的结束线程总是比暴力的终止线程好。 使用 Run Loop 对象一个 run loop 对象提供了添加 input sources，timers，和 run-loop observers 到你的 run loop，然后跑起它的接口。每个线程有一个 run loop 对象与之关联。在 Cocoa 中，这个对象是 NSRunLoop 类的实例。在应用的底层，它是一个指向 CFRunLoopRef opaque type 的实例。 获取一个 Run Loop 对象要获取当前线程的 run loop，你使用以下方法之一： 在一个 Cocoa 应用中，使用 NSRunLoop 的 currentRunLoop 类方法获取 NSRunLoop 对象。 使用 CFRunLoopGetCurrent 函数 尽管它们不是 toll-free bridged 类型，你可以从一个 NSRunLoop 对象中获得一个 CFRunLoopRef opaque type。NSRunLoop 类定义了一个 getCFRunLoop 方法返回一个 CFRunLoopRef 类型，你可以使用来传递给 Core Foundation 函数。这两个对象指向相同的对象，你可以根据需要混合的使用 NSRunLoop 对象和 CFRunLoopRef opage type. 配置 Run Loop你在非主线程跑起一个 run loop 之前，你必须添加至少一个 input source 或 timer 到 run loop 上。如果一个 run loop 没有监听任何 sources，当你试着跑它的时候它会立马退出。怎么添加 input source 到 run loop， 请看后文。 除了安装 sources 外，你也可以安装 run loop observers，使用它们来检测 run loop 的不同执行阶段。要安装一个 run loop observer，你创建一个 CFRunLoopObserverRef opaque type，使用 CFRunLoopAddObserver 添加到 run loop 上。Run loop observers 必须要通过 Core Foundation 来创建，即使是 Cocoa 应用。 下例展示了线程的主函数，它添加一个 run loop observer 到它的 run loop。这个例子的目的是给你展示怎么创建一个 run loop observer 来监听 run loop 的行为。这些基本的 handler 函数只是简单的将 run loop 的行为打下 log。 1234567891011121314151617181920212223- (void)threadMain { // The application uses garbage collection, so no autorelease pool is needed. NSRunLoop* myRunLoop = [NSRunLoop currentRunLoop]; // Create a run loop observer and attach it to the run loop. CFRunLoopObserverContext context = {0, self, NULL, NULL, NULL}; CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, &amp;myRunLoopObserver, &amp;context); if (observer) { CFRunLoopRef cfLoop = [myRunLoop getCFRunLoop]; CFRunLoopAddObserver(cfLoop, observer, kCFRunLoopDefaultMode); } // Create and schedule the timer. [NSTimer scheduledTimerWithTimeInterval:0.1 target:self selector:@selector(doFireTimer:) userInfo:nil repeats:YES]; NSInteger loopCount = 10; do { // Run the run loop 10 times to let the timer fire. [myRunLoop runUntilDate:[NSDate dateWithTimeIntervalSinceNow:1]]; loopCount--; } while (loopCount);} 当给一个常驻的线程配置 run loop 的时候，至少添加一个 input source 来接受消息会更好。尽管只有一个 timer 附着在 run loop 上时，你可以可以进入 run loop，但是一旦 timers fires，通常它变为 invalidated，这会导致 run loop 退出。附着一个重复的 timer 可以保证你的 run loop 执行很长的一段时间，但会涉及到间隔性的 firing timer 来唤醒线程，本质上是另一种轮询的形式而已。对比下一个 input source 等待事件发生，保持线程 sleep 直到事件发生。 启动 Run Loop启动一个 run loop 只对应用中的非主线程是必须的。一个 run loop 必须有一个 input source 或 timer 来监听。如果没有一个附着，run loop 会立即退出。 有几种方式启动 run loop，如下： 无条件的 设置一个 time out 进入一个指定的 mode unconditionally 进入 run loop 是最简单的选项，但也是你最不想用的。无条件的跑你的 run loop 会使线程进入永久的循环，给你很少对 run loop 自身的控制。你可以添加和移除 input sources 和 timers，但是停止 run loop 的唯一方式是杀掉它。同样也没有方式将 run loop 跑再自定义的 mode。 与其 unconditionally 的跑一个 run loop，设置一个 timeout 来跑 run loop 会更好。当你使用一个 timeout 值时，run loop 在事件到来或被分配的时间过期之前一直跑。如果事件到来，事件被分发给 handler 处理，然后 run loop 退出。你的代码可能重新启动 run loop 来处理下一个事件。如果被分配的时间过期了，你可以简单的重启 run loop 或是用这个时间值做些必须的记录。 除了设置 timeout 外，你也可以在指定的 mode 来跑 run loop。 Modes 和 timeout 值并不相互排斥，可以同时使用来跑一个 run loop。Modes 限定了传递事件给 run loop 的 sources 类型。 下例展示了一个线程入口函数的基本结构。例子的关键部分展示 run loop 的基本结构。本质上，你添加 input sources 和 timers 到 run loop，然后重复调用一个 run loop 的函数之一来启动 run loop。每次 run loop 函数返回的时候，你检查条件是否满足退出线程。例子使用 Core Foundation run loop 函数以便检查返回值，决定 run loop 为什么退出。如果你用 Cocoa 且不需要检查返回值的话你也可以使用 NSRunLoop 的类似的方法。 1234567891011121314151617181920212223- (void)skeletonThreadMain { // Set up an autorelease pool here if not using garbage collection. BOOL done = NO; // Add your sources or timers to the run loop and do any other setup. do { // Start the run loop but return after each source is handled. SInt32 result = CFRunLoopRunInMode(kCFRunLoopDefaultMode, 10, YES); // If a source explicitly stopped the run loop, or if there are no // sources or timers, go ahead and exit. if ((result == kCFRunLoopRunStopped) || (result == kCFRunLoopRunFinished)) { done = YES; } // Check for any other exit conditions here and set the // done variable as needed. } while (!done); // Clean up code here. Be sure to release any allocated autorelease pools.} 可以嵌套的 run 一个 run loop。也就是说，你可以从 input source 或 timer 的 handler 函数中调用 CFRunLoopRun，CFRunLoopRunInMode，或任何 NSRunLoop 的跑 run loop 的方法。当你这么做的时候，你可以使用任何 mode 来跑嵌套的 run loop，包括被外围 run loop 使用的 mode。 退出 Run Loop在 run loop 处理一个事件前，有两种方式来是一个 run loop 退出: 使用一个 timeout 值来配置 run loop 告诉 run loop 停止 使用一个 timeout 的值当然更受偏好，如果你可以管理 run loop 的话。指定一个 timeout 的值使得 run loop 完成它所有的正常处理流程，包括在退出前传递通知到 run loop observers。 使用 CFRunLoopStop 函数显式停止 run loop 产生与 timeout 值相似的结果。run loop 发送出任何剩余的 run-loop notifications 然后退出。不同点是你可以使用这个在那些你 unconditionally 启动的 run loop 上。 尽管移除一个 run loop 的 input sources 和 timers 同样可能使得一个 run loop 退出，但这不是一个可靠的方式停止一个 run loop。一些系统函数添加 input source 到 run loop 来处理所需的事件。因为你的代码可能不知道这些 input sources，这样将不能移除它们，这也就阻止了 run loop 退出。 线程安全和 Run Loop 对象线程安全依赖于你使用哪个 API 来操作你的 run loop。在 Core Foundation 中的函数通常是线程安全的，可以从任何线程中调用。然而如果你进行改变 run loop 配置的操作，在那些拥有 run loop 的线程上仍然是更推从的。 Cocoa NSRunLoop 类本身不是线程安全的。如果你使用 NSNunLoop 类来修改你的 run loop，你应该在拥有 run loop 的线程上做。添加 input source 或 timer 到一个属于另一个线程的 run loop 可能导致你的应用奔溃或有异常行为。 配置 Run Loop Sources下面的部分介绍了在 Cocoa 和 Core Foundation 中怎么配置不同类型的 input source。 定义一个自定义 Input Source创建一个自定义 input source 涉及定义以下： 你想要你的 input source 处理的信息 一个 scheduler routine 让感兴趣的客户知道怎样联系你的 input source 一个处理用户发送的 perform request 的 handler 一个 cancellation 函数 invalidate 你的 input source 因为你创建一个自定义 input source 来处理自定义信息，真正的配置被设计得很灵活。scheduler，handler，cancellation handler 函数你创建自定义 input source 必须的关键函数。然后 input source 的部分其它行为发生这些函数之外。例如由你定义传送数据到 input source 的机制，和通知其它线程你的 input source 的存在。 下例展示了一个自定义 input source 的样例配置。在这个例子中，应用的主线程保持了这个 input source 的引用，给 input source 自定义的 command buffer，和 input source 被安装在哪个 run loop。当主线程有任务交付给 work 线程时，它发送一个 command 到 command buffer，command 包含 worker 线程开始工作所需的信息。(因为主线程和 worker 线程的 input source 都有 command buffer 的访问权限，它们的访问必须同步) 一旦 command 被发送，主线程给 input source 发送信号，唤醒 worker 线程的 run loop。一旦收到唤醒的命令，run loop 为 input source 调用 handler，处理 command buffer 中的 command。 下面的部分解释了上图种的自定义 input source 的实现，展示了你需要实现的核心代码。 定义 Input Source定义一个自定义 input source 需要使用 Core Foundation 函数来配置你的 run loop source，并把它附着到 run loop。尽管基本的 handlers 是基于 C 的函数，但这并不阻止你使用 Objective-C 或 C++ 实现这些函数的 wrappers。 上图中的 input source 使用 Objective-C 对象来管理一个 command buffer，和协调 run loop。下面的代码展示了这个对象的定义。RunLoopSource 对象管理一个 command buffer 和使用 buffer 来从其它线程接受消息。代码也展示了 RunLoopContext 对象的定义，这个对象只是一个 container 对象，使用来传递 RunLoopSource 对象和一个 run loop 引用到应用的主线程。 1234567891011121314151617181920212223242526272829303132333435@interface RunLoopSource : NSObject { CFRunLoopSourceRef runLoopSource; NSMutableArray* commands;}- (id)init;- (void)addToCurrentRunLoop;- (void)invalidate;// Handler method- (void)sourceFired;// Client interface for registering commands to process- (void)addCommand:(NSInteger)command withData:(id)data;- (void)fireAllCommandsOnRunLoop:(CFRunLoopRef)runloop;@end// These are the CFRunLoopSourceRef callback functions.void RunLoopSourceScheduleRoutine (void *info, CFRunLoopRef rl, CFStringRef mode);void RunLoopSourcePerformRoutine (void *info);void RunLoopSourceCancelRoutine (void *info, CFRunLoopRef rl, CFStringRef mode);// RunLoopContext is a container object used during registration of the input source.@interface RunLoopContext : NSObject { CFRunLoopRef runLoop; RunLoopSource* source;}@property (readonly) CFRunLoopRef runLoop;@property (readonly) RunLoopSource* source;- (id)initWithSource:(RunLoopSource*)src andLoop:(CFRunLoopRef)loop;@end 尽管 Objective-C 代码管理 input source 的自定义数据，但将 input source 附着到一个 run loop 需要基于 C 的函数回调。当你添加 run loop source 到 run loop 时，这些函数中的第一个被调用。因为这个 input source 只有一个 client (主线程)，它使用 scheduler 函数使用主线程上的 application delegate 发送一个消息来注册自己。当 application delegate 想要与 input source 通讯的时候，它使用 RunLoopContext 对象中的信息来达到母的。 123456void RunLoopSourceScheduleRoutine (void *info, CFRunLoopRef rl, CFStringRef mode) { RunLoopSource* obj = (RunLoopSource*)info; AppDelegate* del = [AppDelegate sharedAppDelegate]; RunLoopContext* theContext = [[RunLoopContext alloc] initWithSource:obj andLoop:rl]; [del performSelectorOnMainThread:@selector(registerSource:) withObject:theContext waitUntilDone:NO];} 最重要的回调函数之一是当你的 input source 被发送信号，用来处理自定义数据的那个。下例展示了与 RunLoopSource 对象关联的进行回调函数。这个函数简单的转发做相关工作的请求到 sourceFired 方法，然后处理任何在 command buffer 中的 command。 1234void RunLoopSourcePerformRoutine (void *info) { RunLoopSource* obj = (RunLoopSource*)info; [obj sourceFired];} 如果你有需要从 run loop 移除你的 input source 的话，使用 CFRunLoopSourceInvalidate 函数，系统调用你的 input source 的 cancellation 函数。你可以使用这个函数通知 input source 的使用者你的 input source 不再是 valid，并应该移除任何 input source 的引用。下例中展示 cancellation 回调函数。这个函数给 application delegate 发送另一个 RunLoopContext 对象，但是这次要求 delegate 移除这个 run loop source 的引用 1234567void RunLoopSourceCancelRoutine (void *info, CFRunLoopRef rl, CFStringRef mode) { RunLoopSource* obj = (RunLoopSource*)info; AppDelegate* del = [AppDelegate sharedAppDelegate]; RunLoopContext* theContext = [[RunLoopContext alloc] initWithSource:obj andLoop:rl]; [del performSelectorOnMainThread:@selector(removeSource:) withObject:theContext waitUntilDone:YES];} 安装 Input Source 到 Run Loop下例展示了 RunLoopSource 的 init 和 addToCurrentRunLoop 方法。 init 方法创建真实被添加到 run loop 的 CFRunLoopSourceRef opaque type。init 方法中它将自身传递给 contextual information，以便回调函数有指向它的指针。 input source 的安装直到 worker 线程调用 addToCurrentRunLoop 方法，在这时 RunLoopSourceScheduleRoutine 回调函数被调用。一旦 input source 被添加到 run loop，跑起 run loop 的线程进入等待。 123456789101112131415- (id)init CFRunLoopSourceContextcontext = {0, self, NULL, NULL, NULL, NULL, NULL, &amp;RunLoopSourceScheduleRoutine, RunLoopSourceCancelRoutine, RunLoopSourcePerformRoutine}; runLoopSource = CFRunLoopSourceCreate(NULL, 0, &amp;context); commands = [[NSMutableArray alloc] init]; return self;}- (void)addToCurrentRunLoop { CFRunLoopRef runLoop = CFRunLoopGetCurrent(); CFRunLoopAddSource(runLoop, runLoopSource, kCFRunLoopDefaultMode);} Input Source 的 Clients 间的协调为了你的 input source 是有用的，你需要从另外的线程操作它并给它发送信号。input source 的整个作用是使他关联的线程睡眠到有事可做。这样的话，让应用中其它的线程知道你的 input source 并有一种与之通讯的方式下显得很有必要。 一种通知 input source 用户的方式是当 input source 一开始添加到 run loop 的时候，发出注册信息。你可以注册任意多 clients，或者简单的到中心代理那里注册下，由代理向 input source 的 clients 提供它。下例中展示了由 application delegate 定义的注册方法。由 RunLoopSource 对象的 scheduler 函数调用。这个方法收到一个由 RunLoopSource 提供的 RunLoopContext 对象。下例也展示了当 input source 从 run loop 移除时用来取消注册的方法。 123456789101112131415161718- (void)registerSource:(RunLoopContext*)sourceInfo { [sourcesToPing addObject:sourceInfo];}- (void)removeSource:(RunLoopContext*)sourceInfo { id objToRemove = nil; for (RunLoopContext* context in sourcesToPing) { if ([context isEqual:sourceInfo]) { objToRemove = context; break; } } if (objToRemove) { [sourcesToPing removeObject:objToRemove]; }} 给 Input Source 发送信号在给 input source 传送数据后，一个 client 需要给 input source 发送信号，唤醒它的 run loop。给 input source 发送信号使得 run loop 知道 input source 准备好被处理。因为信号发生的时候线程是睡眠的，你总是应该显式唤醒 run loop。如果没这么做的话会导致处理 input source 的延迟。 下例中展示了 RunLoopSource 对象的 fireCommandsOnRunLoop。当 clients 已经准备好 input source 来处理它们添加到 command buffer 的 commands 的时候它们调用这个方法。 1234- (void)fireCommandsOnRunLoop:(CFRunLoopRef)runloop { CFRunLoopSourceSignal(runLoopSource); CFRunLoopWakeUp(runloop);} 注意: 你永远不应该通过给一个自定义的 input source 发送信号来处理 SIGHUP 或其它进程级别的信号。Core Foundation 唤醒 run loop 的函数并不是 signal 安全的，不应该在应用的 signal handler 函数中使用。关于 signal handler 函数更多的信息，可以参见 sigaction man page。 配置 Timer Sources创建一个 timer source，所有你需要做的是创建一个 timer 对象，然后在 run loop 上 schedule 它。在 Cocoa 中，使用 NSTimer 类来创建新的 timer 对象，在 Core Foundation 中，你使用 CFRunLoopTimerRef opaque type。NSTimer 的内部只是一个 Core Foundation 的简单扩展，提供了一些易用的特性，像使用一个方法创建和 schedule 一个 timer。 在 Cocoa 中，你可以同时创建和 schedule 使用以下任一方法： scheduledTimerWithTimeInterval:target:selector:userInfo:repeats: scheduledTimerWithTimeInterval:invocation:repeats: 这些方法创建一个 timer 并添加它们到当前线程的 run loop，与 default mode 关联。你也可以手动 schedule 一个 timer 如果你想通过创建你的 NSTimer 对象，然后使用 NSRunLoop 的 addTimer:forMode: 方法。两种技术基本上做的是同样的事情，但是给了你不同层面配置 timer 的选择。例如，如果你创建一个 timer，并手动的添加到 run loop，你可以使用一个非 default 的一个 mode。下例展示怎么使用两种技术创建 timer。第一个 timer 延迟 1s 后每隔 0.1s fire。第二个 timer 初始延迟 0.2s 后每隔 0.2s fire。 123456789NSRunLoop* myRunLoop = [NSRunLoop currentRunLoop];// Create and schedule the first timer.NSDate* futureDate = [NSDate dateWithTimeIntervalSinceNow:1.0];NSTimer* myTimer = [[NSTimer alloc] initWithFireDate:futureDate interval:0.1 target:self selector:@selector(myDoFireTimer1:) userInfo:nil repeats:YES]; [myRunLoop addTimer:myTimer forMode:NSDefaultRunLoopMode];// Create and schedule the second timer.[NSTimer scheduledTimerWithTimeInterval:0.2 target:self selector:@selector(myDoFireTimer2:) userInfo:nil repeats:YES]; 接下来看看怎么使用 Core Foundation 来配置一个 timer。尽管这个例子并没有在 context structur 中传递任何用户定义的信息，你可以使用这个结构来传递你的 timer 所需的任何自定义数据。更多的信息可以参见 CFRunLoopTimer reference. 1234CFRunLoopRef runLoop = CFRunLoopGetCurrent();CFRunLoopTimerContext context = {0, NULL, NULL, NULL, NULL};CFRunLoopTimerRef timer = CFRunLoopTimerCreate(kCFAllocatorDefault, 0.1, 0.3, 0, 0, &amp;myCFTimerCallback, &amp;context);CFRunLoopAddTimer(runLoop, timer, kCFRunLoopCommonModes); 配置一个基于 Port 的 Input SourceCocoa 和 Core Foundation 都提供了基于 port 的对象来支持线程或进程间的通讯。下面的部分将给你展示怎么使用不同类型的 port 设置 port 通讯。 配置一个 NSMachPort 对象为了使用 NSMachPort 对象建立一个本地连接，你创建一个 port 对象，添加它到线程的 run loop 上，当你启动你的非主线程的时候，传递同样的对象给你线程的入口函数。副线程使用同样的对象给你的主线程发送消息。 实现主线程的代码 下面的代码展示了主线程起一个非主线程作为 worker 线程。因为 Cocoa 框架进行许多配置 port 和 run loop 的中间步骤，launchThread 方法要比使用 Core Foundation 实现同样的功能要短很多。Core Foundation 的实现传递 local port 的名字给 worker 线程，而 Cocoa 传递一个 NSPort 对象。 12345678910111213- (void)launchThread { NSPort* myPort = [NSMachPort port]; if (myPort) { // This class handles incoming port messages. [myPort setDelegate:self]; // Install the port as an input source on the current run loop. [[NSRunLoop currentRunLoop] addPort:myPort forMode:NSDefaultRunLoopMode]; // Detach the thread. Let the worker release the port. [NSThread detachNewThreadSelector:@selector(LaunchThreadWithPort:) toTarget:[MyWorkerClass class] withObject:myPort]; }} 为了设置成线程间双向的通讯，你也许想要 worker 线程在 check-in 的消息中把它自己的 local port 告诉主线程。收到 check-in 消息让主线程知道在启动 worker 线程的过程中一切正常，同时也给了一种方式发送进一步的消息给 worker 线程。 下面的代码展示了主线程的 handlePortMessage: 方法。这个方法当有数据到达线程自己的 local port 时被调用。当一个 check-in 消息到达的时候，方法直接从 port message 中获取 worker 线程的 port，然后本地保存。 1234567891011121314151617#define kCheckinMessage 100// Handle responses from the worker thread.- (void)handlePortMessage:(NSPortMessage *)portMessage { unsigned int message = [portMessage msgid]; NSPort* distantPort = nil; if (message == kCheckinMessage) { // Get the worker thread’s communications port. distantPort = [portMessage sendPort]; // Retain and save the worker port for later use. [self storeDistantPort:distantPort]; } else { // Handle other messages. }} 实现非主线程代码 对于非主线程，你必须配置它使用指定的 port 来传回信息给主线程。 下面展示了设置 worker 线程的代码。给线程创建了 autorelease pool 后，接着创建了一个 worker 对象来驱动线程的执行。worker 对象的 sendCheckinMessage: 方法给 worker 线程创建一个 local port 和发送一个 check-in 消息回主线程。 123456789101112131415161718+(void)LaunchThreadWithPort:(id)inData { NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init]; // Set up the connection between this thread and the main thread. NSPort* distantPort = (NSPort*)inData; MyWorkerClass* workerObj = [[self alloc] init]; [workerObj sendCheckinMessage:distantPort]; [workerObj sendCheckinMessage:distantPort]; // Let the run loop process things. do { [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]; } while (![workerObj shouldExit]); [workerObj release]; [workerObj release];} 当使用 NSMachPort 时，local 和 remote 线程可以使用同一个 port 对象来进行线程间的单向通讯。也就是说，一个线程创建的 local port 成了其它线程的 remote port。 下面的代码展示了 worker 线程的 check-in 函数。这个方法设置好用于未来通讯的 local port，然后发送一个 check-in 的消息回主线程。发送使用 LaunchThreadWithPort: 函数收到的 port 对象作为消息的目标。 123456789101112131415161718// Worker thread check-in method- (void)sendCheckinMessage:(NSPort*)outPort { // Retain and save the remote port for future use. [self setRemotePort:outPort]; // Create and configure the worker thread port. NSPort* myPort = [NSMachPort port]; [myPort setDelegate:self]; [[NSRunLoop currentRunLoop] addPort:myPort forMode:NSDefaultRunLoopMode]; // Create the check-in message. NSPortMessage* messageObj = [[NSPortMessage alloc] initWithSendPort:outPort receivePort:myPort components:nil]; if (messageObj) { // Finish configuring the message and send it immediately. [messageObj setMsgId:setMsgid:kCheckinMessage]; [messageObj sendBeforeDate:[NSDate date]]; }} 配置一个 NSMessagePort 对象要使用一个 NSMessagePort 对象创建一个本地连接，你不能简单的在线程间传递 port 对象。Remote message ports 必须通过名字来获得。在 Cocoa 中为了可能通过名字获得 message port，需要使用指定的名称注册你的 local port，然后传递给想获取合适的 port 对象进行的通讯的 remote 线程。下面的代码展示了在你想要使用 message ports 时创建和注册 port 的过程。 123456789NSPort* localPort = [[NSMessagePort alloc] init];// Configure the object and add it to the current run loop.[localPort setDelegate:self];[[NSRunLoop currentRunLoop] addPort:localPort forMode:NSDefaultRunLoopMode];// Register the port using a specific name. The name must be unique.NSString* localPortName = [NSString stringWithFormat:@\"MyPortName\"];[[NSMessagePortNameServer sharedInstance] registerPort:localPort name:localPortName]; 在 Core Foundation 中配置一个基于 Port 的 Input Source这部分展示了怎么使用 Core Foundation 在应用的主线程和一个 worker 线程间设置一个双向的通讯通道。 下面的代码被应用的主线程调用来启动一个 worker 线程。代码做的第一件事是设置一个 CFMessagePortRef opaque type 来监听 worker 线程发送过来的消息。worker 线程需要 port 的名字来建立连接，所以名字字符串被传递给 worker 线程的入口函数。Port names 应该在当前用户的上下中是唯一的，不然你可能会遇到冲突。 首先添加 Core Foundation Message Port 到一个线程 1234567891011121314151617181920212223242526272829303132333435#define kThreadStackSize (8 *4096)OSStatus MySpawnThread() { // Create a local port for receiving responses. CFStringRef myPortName; CFMessagePortRef myPort; CFRunLoopSourceRef rlSource; CFMessagePortContext context = {0, NULL, NULL, NULL, NULL}; Boolean shouldFreeInfo; // Create a string with the port name. myPortName = CFStringCreateWithFormat(NULL, NULL, CFSTR(\"com.myapp.MainThread\")); // Create the port. myPort = CFMessagePortCreateLocal(NULL, myPortName, &amp;MainThreadResponseHandler, &amp;context, &amp;shouldFreeInfo); if (myPort != NULL) { // The port was successfully created. // Now create a run loop source for it. rlSource = CFMessagePortCreateRunLoopSource(NULL, myPort, 0); if (rlSource) { // Add the source to the current run loop. CFRunLoopAddSource(CFRunLoopGetCurrent(), rlSource, kCFRunLoopDefaultMode); // Once installed, these can be freed. CFRelease(myPort); CFRelease(rlSource); } } // Create the thread and continue processing. MPTaskID taskID; return(MPCreateTask(&amp;ServerThreadEntryPoint, (void*)myPortName, kThreadStackSize, NULL, NULL, NULL, 0, &amp;taskID);} port 被安装和线程启动后，主线程在等待 check-in 消息时可以继续正常的执行。当 check-in 消息到达的时候，它被分发给主线程的 MainThreadResponseHandler 函数。函数代码如下，它取出给 work 线程的 port 名字，创建一个 conduit 以便将来通讯。 123456789101112131415161718192021222324252627282930313233#define kCheckinMessage 100// Main thread port message handlerCFDataRef MainThreadResponseHandler(CFMessagePortRef local, SInt32 msgid, CFDataRef data, void* info) { if (msgid == kCheckinMessage) { CFMessagePortRef messagePort; CFStringRef threadPortName; CFIndex bufferLength = CFDataGetLength(data); UInt8* buffer = CFAllocatorAllocate(NULL, bufferLength, 0); CFDataGetBytes(data, CFRangeMake(0, bufferLength), buffer); threadPortName = CFStringCreateWithBytes (NULL, buffer, bufferLength, kCFStringEncodingASCII, FALSE); // You must obtain a remote message port by name. messagePort = CFMessagePortCreateRemote(NULL, (CFStringRef)threadPortName); if (messagePort) { // Retain and save the thread’s comm port for future reference. AddPortToListOfActiveThreads(messagePort); // Since the port is retained by the previous function, release it here CFRelease(messagePort); } // Clean up. CFRelease(threadPortName); CFAllocatorDeallocate(NULL, buffer); } else { // Process other messages. } return NULL;} 主线程配置好后，剩下的唯一需要做的是给新建的线程创建它自己的 port 和 check in。下面的代码展示了 worker 线程的入口函数。函数取出主线程的 port 名称，是用来创建一个创建一个 remote 连接回主线程。然后然后给自己创建一个 local port，安装 port 到线程的 run loop 上，发送 check-in 包含 local port 的消息回主线程。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758OSStatus ServerThreadEntryPoint(void* param) { // Create the remote port to the main thread. CFMessagePortRef mainThreadPort; CFStringRef portName = (CFStringRef)param; mainThreadPort = CFMessagePortCreateRemote(NULL, portName); // Free the string that was passed in param. CFRelease(portName); // Create a port for the worker thread. CFStringRef myPortName = CFStringCreateWithFormat(NULL, NULL, CFSTR(\"com.MyApp.Thread-%d\"), MPCurrentTaskID()); // Store the port in this thread’s context info for later reference. CFMessagePortContext context = {0, mainThreadPort, NULL, NULL, NULL}; Boolean shouldFreeInfo; Boolean shouldAbort = TRUE; CFMessagePortRef myPort = CFMessagePortCreateLocal(NULL, myPortName, &amp;ProcessClientRequest, &amp;context, &amp;shouldFreeInfo); if (shouldFreeInfo) { // Couldn't create a local port, so kill the thread. MPExit(0); } CFRunLoopSourceRef rlSource = CFMessagePortCreateRunLoopSource(NULL, myPort, if (!rlSource) { // Couldn't create a local port, so kill the thread. MPExit(0); } // Add the source to the current run loop. CFRunLoopAddSource(CFRunLoopGetCurrent(), rlSource, kCFRunLoopDefaultMode); // Once installed, these can be freed. CFRelease(myPort); CFRelease(rlSource); // Package up the port name and send the check-in message. CFDataRef returnData = nil; CFDataRef outData; CFIndex stringLength = CFStringGetLength(myPortName); UInt8* buffer = CFAllocatorAllocate(NULL, stringLength, 0); CFStringGetBytes(myPortName, CFRangeMake(0,stringLength), kCFStringEncodingASCII, 0, FALSE, buffer, stringLength, NULL); outData = CFDataCreate(NULL, buffer, stringLength); CFMessagePortSendRequest(mainThreadPort, kCheckinMessage, outData, 0.1, 0.0, NULL, NULL); // Clean up thread data structures. CFRelease(outData); CFAllocatorDeallocate(NULL, buffer); // Enter the run loop. CFRunLoopRun();}","link":"/2019/12/27/2019-12-27-02/"},{"title":"通过两个数组实现队列","text":"使出栈和入栈的时间复杂度都为O(1) 123456789101112131415161718192021222324252627protocol Queue { associatedtype Element mutating func enqueue(_ newElement: Element) mutating func dequeue() -&gt; Element?}struct FIFOQueue&lt;Element&gt;: Queue { private var left: [Element] = [] private var right: [Element] = [] /// 将元素添加到队列最后 /// - 复杂度：O(1) /// - Parameter newElement: Element mutating func enqueue(_ newElement: Element) { right.append(newElement) } /// 从当前队列前端移除一个元素 /// 当队列为空时，返回nil /// - 复杂度：平摊 O(1) mutating func dequeue() -&gt; Element? { if left.isEmpty { left = right.reversed() right.removeAll() } return left.popLast() }} 就和数组的扩容一样，扩容的操作并不是时刻发生，它的频率是低频的，平摊下来接近于O(1)这里的将 right 数组 reversed 到 left 数组，虽然是 O(n) 的操作，但是队列入栈和出栈的频次是完全高于 reversed 的，所以平摊复杂度是 O(1)","link":"/2019/12/30/2019-12-30-01/"},{"title":"Swift与OC的运行时特性","text":"OC运行时 动态类型 动态绑定 动态装载 OC的消息转发机制分为两步 实例变量会先查找自身有没有该方法，没有就再去父类，直到最上级父类也没有，就会转向第二步 这一步会有很多个地方让用户重启消息发送过程 resolveInstanceMethod forwardingTargetForSelector methodSignatureForSelector -&gt; forwardInvocation doesNotRecognizeSelector 派发方式 直接派发（Direct Dispatch） 最快，需要调用的指令集会更少，编译器还能够优化，也成为静态调用，但是缺乏动态性所有没办法支持继承和多态 函数表派发（Table Dispatch） 使用一个数组存储类声明的每一个函数的指针，也成为virtual table（虚函数表），Swift里成为witness table. 每个类都会维护一个函数表，记录类所有的函数，如果父类函数被override，则只会保存被override之后的函数，一个子类新添加的函数，都会被插入到数组的最后 比直接派发慢，不好扩展 消息机制派发（Message Dispatch） 调用函数最动态的方式，Cocoa的基石，支持函数替换、kvo这些功能 Swift运行时 纯Swift类的函数不再是运行时发消息，而是类似 C++ 的 vtable，在编译时就确定了调用哪个函数，所以没法通过 runtime 获取方法、属性 为了兼容OC，凡是继承自NSObject的类都会保留其动态性，能通过 runtime 拿到它的方法。新版本必须手动加上@objc 不管是纯 Swift 类还是继承自 NSObject 的类只要在属性和方法前面加上 @objc 关键字就可以使用 runtime 下面是一些 Swift 运行时的派发方式 原始定义 扩展 值类型 直接派发 直接派发 协议 函数表派发 直接派发 类 函数表派发 直接派发 继承自NSObject的类 函数表派发 消息机制派发 final 直接派发 dynamic 消息机制派发 @objc &amp; @nonobic 改变在OC里的可见性 @inline 告诉编译器可以直接派发","link":"/2020/01/03/2020-01-03-01/"},{"title":"探究写时复制","text":"写时复制和Objective-C不同，在Swift中，Array、Dictionary、Set这样的集合不再是引用类型而是值类型了，这意味着，每次传递不再是传递指针而是一个Copy后的值，但是如果每次都要Copy一次的话就会太浪费性能，所以这时候就要用到一个写时复制(copy-or-write)的技术。 123456var x = [1, 2, 3]var y = xx.append(5)y.removeLast()x // [1, 2, 3, 5]y // [1, 2] 在内部，这些Array的结构体含有指向某个内存的引用。这个内存就是数组中元素所存储的位置。两个数组的引用指向的是内存中同一个位置，这两个数据共享了它们的存储部分。当我们改变 x 的时候，这个共享会被检测到，内存将会被复制。所以说，复制操作只会则必要的时候发生。 这种行为被称为写时复制。它的工作方式是，每当数组被改变，它首先检查它对存储缓冲区的引用是否是唯一，或者说，检查数组本身是不是这块缓冲区的唯一拥有者。如果是，那么缓冲区可以进行原地变更；也不会有复制被进行。如果缓冲区有一个以上的持有者，那么数组就需要先进行复制，然后对复制的值进行变化，而保持其他的持有者不受影响。 实现写时复制使用 NSMutableData 作为内部引用类型来实现 Data 结构体。 12345678910111213141516171819202122232425struct MyData { var _data: NSMutableData var flag: String? init(_ data: NSData) { _data = data.mutableCopy() as! NSMutableData }}extension MyData { func append(_ byte: UInt8) { var mutableByte = byte _data.append(&amp;mutableByte, length: 1) }}let theData = NSData(base64Encoded: \"wAEP/w==\")!var x = MyData(theData)x.flag = \"flag\"var y = xx._data == y._datay.flag = \"new flag\"x.append(0x55)print(x) // MyData(_data: &lt;c0010fff 55&gt;, flag: Optional(\"flag\"))print(y) // MyData(_data: &lt;c0010fff 55&gt;, flag: Optional(\"new flag\")) MyData虽然是一个结构体，是一个值类型，对于值类型数据遵循写时复制的特性，但是对于内部 NSMutableData 这样的引用类型，多个 MyData 的变量指向的还是同一个 NSMutableData 地址。所以我们要手动实现 NSMutableData 的写时复制 简单的实现12345678910111213141516171819202122232425struct MyData { fileprivate var _data: NSMutableData fileprivate var _dataForWriting: NSMutableData { mutating get { _data = _data.mutableCopy() as! NSMutableData return _data } } var flag: String? init() { _data = NSMutableData() } init(_ data: NSData) { _data = data.mutableCopy() as! NSMutableData }}extension MyData { mutating func append(_ byte: UInt8) { var mutableByte = byte _dataForWriting.append(&amp;mutableByte, length: 1) }} 不直接变更 _data，通过一个 _dataForWriting 来访问。每次都会复制 _data 并将该复制返回。当我们调用 append 时，将会进行复制 1234567891011let theData = NSData(base64Encoded: \"wAEP/w==\")!var x = MyData(theData)x.flag = \"flag\"var y = xx._data == y._datay.flag = \"new flag\"x.append(0x55)print(x) // MyData(_data: &lt;c0010fff 55&gt;, flag: Optional(\"flag\"))print(y) // MyData(_data: &lt;c0010fff&gt;, flag: Optional(\"new flag\")) 但是这样有一个问题，多次 append 时，就会非常浪费，因为每次都要 copy 高效的方式我们可以通过判断一个对象是否是唯一的引用，来决定是否需要对这个对象进行复制。如果它是唯一引用，那就直接修改对象，否则，需要在修改前创建该对象的复制。在 Swift 中，通过 isKnownUniquelyReferenced 函数来检查某个引用只有一个持有者。只有一个返回 true，否则返回 false。对于 OC 类，它会直接返回 false，我们需要创建一个 Swift 的类来包装 OC 类 123456789101112final class Box&lt;A&gt; { var unbox: A init(_ value: A) { self.unbox = value }}var x = Box(NSMutableData())isKnownUniquelyReferenced(&amp;x) // truevar y = xisKnownUniquelyReferenced(&amp;y) // false 让我们再写一个循环 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647struct MyData { fileprivate var _data: Box&lt;NSMutableData&gt; fileprivate var _dataForWriting: NSMutableData { mutating get { if !isKnownUniquelyReferenced(&amp;_data) { _data = Box(_data.unbox.mutableCopy() as! NSMutableData) print(\"Making a copy\") } return _data.unbox } } init() { _data = Box(NSMutableData()) } init(_ data: NSData) { _data = Box(data.mutableCopy() as! NSMutableData) }}extension MyData { mutating func append(_ byte: UInt8) { var mutableByte = byte _dataForWriting.append(&amp;mutableByte, length: 1) }}var bytes = MyData()var copy = bytesfor byte in 0..&lt;5 as CountableRange&lt;UInt8&gt; { print(\"Appending 0x\\(String(byte, radix: 16))\") bytes.append(byte)}print(bytes)print(copy)/*Appending 0x0Making a copyAppending 0x1Appending 0x2Appending 0x3Appending 0x4MyData(_data: __lldb_expr_26.Box&lt;__C.NSMutableData&gt;)MyData(_data: __lldb_expr_26.Box&lt;__C.NSMutableData&gt;)*/ 可以看到当第一次 append 的时候，拷贝了一份引用，之后因为新拷贝的引用是惟一的，就没有进行复制操作","link":"/2020/01/03/2020-01-03-02/"},{"title":"SQL基础教程（1）","text":"以下基于mysql 一个商品表12345678create table Product (product_id char(4) not null,product_name varchar(100) not null,product_type varchar(32) not null,sale_price integer ,purchase_price integer ,regist_date date ,primary key (product_id)); 导入sql语句12// 进入mysql命令行source 路径 删除表1drop table product 重命名表1rename table Poduct to Product 增加列1alter table product add column product_name_pinyin varchar(100); 删除列1alter table product drop column product_name_pinyin; 更改列为主键1alter table product add primary key (product_id); 插入行12345678910begin transaction;INSERT INTO Product VALUES ('0001', 'T恤衫', '衣服', 1000, 500, '2019-12-30');INSERT INTO Product VALUES ('0002', '打孔器', '办公用品', 500, 320, '2019-12-29');INSERT INTO Product VALUES ('0003', '运动T恤','衣服', 4000, 2800, NULL);INSERT INTO Product VALUES ('0004', '菜刀', '厨房用具', 3000, 2800, '2019-12-28');INSERT INTO Product VALUES ('0005', '高压锅', '厨房用具', 6800, 5000, '2019-12-27');INSERT INTO Product VALUES ('0006', '叉子', '厨房用具', 500, NULL, '2019-12-26');INSERT INTO Product VALUES ('0007', '擦菜板', '厨房用具', 880, 790, '2019-12-25');INSERT INTO Product VALUES ('0008', '圆珠笔', '办公用品', 100, NULL, '2019-12-24');commit; SELECT查询列设置别名123select product_id as id, product_name as name, purchase_price as price from product;select product_id as \"商品编号\", product_name as \"商品名称\", purchase_price as \"进货单价\" from product; 设置汉语要用双引号”” 设置常数显示1select '商品' as string, 38 as number, '2019-02-24' as date, product_id, product_name from product; 显示结果每一行都会有 商品，38，2019-02-24这三个数据 从结果中删除重复行123select distinct product_type from product;select distinct product_type, regist_date from product; 如果有NULL，会被当成一类来显示 where123select product_name, product_type from product where product_type='衣服';select product_name from product where product_type = '衣服'; 注释1234-- 单行注释/* 多行注释*/ 算数运算符 + - * / 1select product_name, sale_price, sale_price * 2 as \"sale_price_x2\" from product; 比较运算符1234567891011-- 等于select product_name, product_type from product where sale_price = 500;-- 不等于select product_name, product_type from product where sale_price &lt;&gt; 500;/*还有&gt;=&gt;&lt;=&lt;*/ 联合使用 1select product_name, sale_price, purchase_price from product where sale_price - purchase_price &gt;= 500; NULL不能比较，只能用 is null &amp; is not null 来判断 1select product_name, purchase_price from product where purchase_price is null; 逻辑运算符not1select product_name, product_type, sale_price from product where not sale_price &gt;= 1000; and &amp; or12345select product_name, purchase_price from product where product_type='厨房用具' and sale_price &gt;= 3000;select product_name, purchase_price from product where product_type='厨房用具' or sale_price &gt;= 3000;select product_name, product_type, regist_date from product where product_type='办公用品' and (regist_date = '2019-12-29' or regist_date = '2019-12-24'); and运算符优先级高于or，所以要加上括号 聚合与排序对表进行聚合查询 COUNT: 计算表中的记录数（行数） SUM: 计算表中数值列中数据的合计值 AVG: 计算表中数值列中数据的平均值 MAX: 求出表中任意列中数据的最大值 MIN: 求出表中任意列中数据的最小值 DISTINCT: 删除重复值 123456789101112131415161718192021222324252627282930313233-- 计算行数select count(*) from product;-- count(*)会得到包含NULL的数据行数，count(列名)会得到NULL之外的数据行数-- 计算合计值select sum(sale_price) from product;-- 计算平均值select avg(sale_price) from product;-- avg自动把NULL排除，所以这时候数量是6-- 最大值，最小值select max(sale_price), min(purchase_price) from product;-- min和max理论上适用于任何数据类型的列，字符串、日期等的比较也不会有问题，但是SUM/AVG不行-- 计算删除重复数据后的数据行数select count(distinct product_type) from product;-- 所有的聚合函数都可以使用distinct``` **所有包含列名的聚合函数，都会把NULL排除在外**##### 对表进行分组先把表分成几组，在进行汇总处理###### GROUP BY```sql-- 将数据按照product_type分类，并计算每个分类的数量select product_type, count(*) from product group by product_type;select purchase_price, count(*) from product where product_type='衣服' group by purchase_price; 如果有group by，那么select语句只能使用group by指定的列名 group by 不能使用 select 中列的别名 group by 字句结果的显示是无序的 只有 select, having, order by 字句中能够使用聚合函数 为聚合结果指定条件 使用COUNT函数等对表中数据进行汇总操作时，为其指定条件的不是where字句，而是HAVING字句 聚合函数可以在SELECT字句、HAVING字句和ORDER BY字句中使用 HAVING字句要写在GROUP BY字句之后 WHERE字句用来指定数据行的条件，HAVING字句用来指定分组的条件 1234-- 按照商品种类进行分组后的结果中，取出”包含的数据行数为2行的组“select product_type, count(*) from product group by product_type having count(*) = 2;-- 取出销售单价大于等于2500的分组数据select product_type, avg(sale_price) from product group by product_type having avg(sale_price) &gt;= 2500; 聚合键所对应的条件不应该卸载HAVING字句当中，而应该书写在WHERE字句当中 对查询结果进行排序1234567891011select product_id, product_name, sale_price, purchase_price from product order by sale_price;select product_id, product_name, sale_price, purchase_price from product order by sale_price DESC;-- order by 字句中可以使用列的别名select product_id as id, product_name, sale_price as sp, purchase_price from product order by sp, id;-- select字句中未包含的列也可以在order by字句中使用select product_name, sale_price, purchase_price from product order by product_id;-- 在order by字句中可以使用select字句中未使用的列和聚合函数select product_type, count(*) from product group by product_type order by count(*); 未指定ORDER BY字句中排列顺序时会默认使用升序进行排列排序键中包含NULL时，会在开头或末尾进行汇总 为什么order by可以使用别名，group by不可以呢？ 这里要知道使用HAVING字句时SELECT语句的顺序 FROM -&gt; WHERE -&gt; GROUP BY -&gt; HAVING -&gt; SELECT -&gt; ORDER BY SELECT字句的执行顺序是在GROUP BY字句之后，ORDER BY字句之前，因此在执行GROUP BY字句时，SELECT语句中定义的别名无法被识别 数据更新数据的插入1234567891011121314-- 通常的insertinsert into ProductIns (product_id, product_name, product_type, sale_price, purchase_price, regist_date) values ('0001', 'T恤衫', '衣服', 1000, 500, '2009-09-20');-- 多行insertinsert into ProductIns values ('0002', '打孔器', '办公用品', 500, 320, '2009-09-11'), ('0003', '运动T恤', '衣服', 4000, 2800, NULL), ('0004', '菜刀', '厨房用具', 3000, 2800, '2009-09-20');-- 省略列清单insert into ProductIns values ('0005', '高压锅', '厨房用具', 6800, 5000, '2009-01-15');-- 插入NULLinsert into ProductIns (product_id, product_name, product_type, sale_price, purchase, regist_date) values ('0006', '叉子', '厨房用具', 500, NULL, '2009-09-20');-- 插入默认值(显式方式)insert into ProductIns (product_id, product_name, product_type, sale_price, purchase, regist_date) values ('0007', '擦菜板', '厨房用具', DEFAULT, 790, '2009-04-28');-- 插入默认值(隐式方式)insert into ProductIns (product_id, product_name, product_type, purchase, regist_date) values ('0007', '擦菜板', '厨房用具', 790, '2009-04-28');-- 使用显式方式更容易理解 从其他表中复制数据1234insert into ProductCopy (product_id, product_name, product_type, sale_price, purchase_price, regist_date) select product_id, product_name, product_type, sale_price, purchase_price, regist_date from Product;-- 多种多样的selectinsert into ProductType (product_type, sum_sale_price, sum_purchase_price) select product_type, sum(sale_price), sum(purchase_price) from Product group by product_type; 数据的删除drop table 删除整个表，delete 删除表中的数据 1234-- 清空表delete from ProductType;-- 根据条件删除delete from Product where sale_price &gt;= 4000; delete只能使用where字句，group by、having、order by不能用，没有意义 truncate与delete相似，但是前者只能删除表中的全部数据，而不能通过where字句指定条件来删除部分数据，因为它只能删除全部，所以处理速度别delete更快 数据的更新update 12345678910update Product set regist_date='2009-10-10';-- 指定条件update Product set sale_price = sale_price * 10 where product_type='厨房用具';-- 使用NULL进行更新update Product set regist_date = NULL where product_id='0008';-- 多列更新update Product set sale_price = sale_price * 10, purchase_price = purchase_price / 2 where product_type = '厨房用具'; 事务 事务是需要在同一个处理单元中执行的一系列更新处理的集合。通过使用事务，可以对数据库中的数据更新处理的提交和取消进行管理 事务处理的终止指令包括COMMIt（提交处理）和ROLLBACK（取消处理）两种 DBMS的事务具有原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）四种特性，统称为ACID特性 事务是需要在同一个处理单元中执行的一系列更新处理的集合 1234567start transaction;update Product set sale_price = sale_price+1000 where product_id='0001';commit;-- rollback 回滚到开始事务之前的状态 当开启一个连接对数据库进行操作时，启动事务，修改，还没有提交，此时启动另一个连接，是看不到还没有提交的事务修改后的数据的。这时候如果执行 delete 操作，就会阻塞住，只有等之前的事务提交后才会继续执行delete 复杂查询视图视图并不保存数据，它保存的是select语句 12345create view ProductSum (product_type, cnt_product) as select product_type, count(*) from product group by product_type;select product_type, cnt_product from ProductSum;drop view ProductSum; 从视图中查找就是调用视图的select语句 视图支持嵌套，但不建议，影响性能 从表中更新数据，查询视图也会同步更新，因为本质是select。从视图更新数据，也会影响到表，但是有限制 SELECT子句中未使用DISTINCT FROM字句中只有一张表 未使用GROUP BY子句 未使用HAVING子句 子查询一张一次性视图 123select product_type, cnt_product from (select product_type, count(*) as cnt_product from Product group by product_type) as ProductSum;-- 就是将用来定义视图的select语句直接用于from字句当中，as ProductSum就是子查询的名称，但是是一次性的，执行完之后就消失 子查询作为内存查询会首先执行，且没有层数上的限制 标量子查询只能返回表中某一行的某一列的值 12345-- 找出售价高于平均售价的产品select product_id, product_name, sale_price from Product where sale_price &gt; avg(sale_price);-- 很明显上面是错误的写法，where字句不能有聚合函数，所以这里就要用到标量子查询select product_id, product_name, sale_price from Product where sale_price &gt; (select avg(sale_price) from Product); 标量子查询的书写位置不局限于where字句中，通常任何可以使用单一值的位置都可以使用 12345-- select子句使用标量子查询select product_id, product_name, sale_price, (select avg(sale_price) from Product) as avg_price from Product;-- having子句使用标量子查询select product_type, avg(sale_price) from Product group by product_type having avg(sale_price) &gt; (select avg(sale_price) from Product); 注意：标量子查询的结果一定不能返回多行 关联子查询如果要找出产品售价高于每个商品种类的平均售价的产品，理论上 1select product_id, product_name, sale_price from Product where sale_price &gt; (select avg(sale_price) from Product group by product_type); 这里用了标量子查询，但是是错误的，标量子查询的返回结果必须是单一值，这里返回了多个值（每个商品种类的平均售价），比较是不成立的 用关联子查询来解决 1select product_id, product_name, sale_price from Product as P1 where sale_price &gt; (select avg(sale_price) from Product as P2 where P1.product_type = P2.product_type group by product_type); 关联子查询相比于标量子查询增加了一个判断，用来找出子查询返回多个结果的相匹配的那一个，这样就可以用来比较了，要注意关联名称的范围","link":"/2020/01/08/2020-01-08-01/"},{"title":"排序算法（1）- 冒泡、插入、选择","text":"有一些最经典的、最常用的算法，按照时间复杂度可以分为三类 排序算法 时间复杂度 是否基于比较 冒泡、插入、选择 O(n^2) 是 快排、归并 O(nlogn) 是 桶、计数、基数 O(n) 否 如何分析一个“排序算法”排序算法的执行效率一般从以下几个方面来衡量： 最好情况、最坏情况、平均情况时间复杂度 时间复杂度的系数、常数、低阶 日常情况下，我们业务中的数据规模也不过是几百上千，这时候在比较算法的时候也要把这些考虑进来 比较次数和交换（或移动）次数 排序算法的内存消耗通过空间复杂度来衡量，这里引入一个新概念，原地排序（Sorted in place）。原地排序算法，就是空间复杂度为 O(1) 的排序算法 排序算法的稳定性数据中往往会有相等的数据，稳定性是指经过比较后，相等的数据的先后顺序是否不变。实际应用中，稳定性往往能简化一些操作，提升效率。 冒泡排序冒泡排序每次只会交换两个相邻的元素。遍历数组，将遍历到的元素和它后面的所有元素比较，满足条件就互换元素。 123456789101112131415161718def bubble_sort(array): \"\"\" 冒泡排序 :param array: :return: \"\"\" count = len(array) if count &lt;= 1: return for i in range(count): flag = False # 这里优化一下，如果已经达到完全有序，则不需要再比较 for j in range(count-i-1): if array[j] &gt; array[j+1]: array[j], array[j+1] = array[j+1], array[j] flag = True if not flag: break 这里要说一下有序度：对于一个倒序排列的数组，比如6, 5, 4, 3, 2, 1, 有序度是0；对于一个完全有序的数组，比如1, 2, 3, 4, 5, 6，有序度是 n*(n-1)/2，也就是15。这种有序度叫做满有序度。逆序度的定义跟有序度相反。逆序度=满有序度-有序度。数组排序的操作就是一个增加有序度，减少逆序度的过程，最后达到满有序度 冒泡排序每次最多交换一个元素，也就是说每次有序度都会+1，所以要交换的次数就是逆序度数。对于数组[4, 5, 6, 3, 2, 1]，初始有序度是(4, 5), (4, 6), (5, 6)，则要进行15-3=12次交换操作。 分析： 冒泡排序每次只交换相邻数据，只需要常量级的临时空间，所以空间复杂度是O(1)，是一个原地排序算法 每次只改变相邻元素，如果相等则不交换，所以是稳定的排序算法 数据是有序的，则进行一次冒泡就结束了，最好时间复杂度为O(n)，数据是倒序的，则需要进行n此冒泡，最坏时间复杂度为O(n^2)， 平均时间复杂度为O(n^2) 插入排序想象一下，把一个待排序的数组分为有序区和无序区，遍历数组，每次从无序区取出第一个元素，和有序区从后往前比较，找到要替换的地方插入，这就是插入排序 12345678910111213141516171819def insertion_sort(array): \"\"\" 插入排序 :param array: :return: \"\"\" count = len(array) if count &lt;= 1: return for i in range(count): value = array[i] j = i - 1 while j &gt;= 0: if array[j] &gt; value: array[j+1] = array[j] # 数据移动 else: break j -= 1 array[j+1] = value # 插入数据 分析： 插入排序不需要额外的存储空间，是一个原地排序算法。 对于值相同的元素，可以选择将后面出现的元素，插入到前面出现的元素后面，这样就可以保持前后顺序不变，所以是一个稳定的排序算法。 如果是一个有序数据，则每次比较都不需要往前继续遍历有序区交换数据，只会一直拿无序区的数据，所以最好时间复杂度为O(n)，如果完全倒序，每次拿无序区的数据都要和有序区的完全比较一遍，最坏时间复杂度为O(n^2)。 在数组中插入一个数据的平均复杂度为O(n)，插入排序每次操作都是相当于在数组中插入一个数据，循环执行n次，所以平均时间复杂度为O(n^2)。 选择排序选择排序和插入排序有些类似，都是分为有序区和无序区，只不过选择排序是从无序区找到最小的那个元素，把它直接放在有序区的末尾 123456789101112131415def selection_sort(array): \"\"\" 选择排序 :param array: :return: \"\"\" count = len(array) if count &lt;= 1: return for i in range(count): min_idx = i for j in range(i+1, count): if array[min_idx] &gt; array[j]: min_idx = j array[i], array[min_idx] = array[min_idx], array[i] 分析： 是一种原地排序算法 它不是稳定的。举个例子，[5, 8, 5, 2, 9]，第一次会找到最小元素2，然后和5交换位置，这样第一个5和后面的5顺序就改变了，所以它不是稳定的排序算法 最好、最坏、平均时间复杂度都为O(n^2)。因为它每次都要从未排序区找出最小的一个元素，即使是一个有序数据。 插入比冒泡更好我们可以看一下两个排序的交换部分的关键代码 1234567# 冒泡if array[j] &gt; array[j+1]: array[j], array[j+1] = array[j+1], array[j] # 插入if array[j] &gt; value: array[j+1] = array[j] 上面冒泡排序交换两个元素，因为我是用Python写的原因，所以直接用元祖的方式交换，但是本质上还是会设置一个临时变量来存储元素，和C的交换一样 123temp c = a;a = b;b = c; 所以冒泡排序实际是有三个操作步骤的，设置临时变量，赋值，赋值，而插入排序呢，只需要一个基于数组下标的交换而已。假设每个操作的时间复杂度为K，则冒泡每次交换需要 3K个时间，而插入只需要 1K个时间，当数据规模足够大时，就会看到明显的差别。下面我创建了一个数组，包含200个数组，每个数组包含400个随机的元素，分别对它们进行排序。 12345678910111213141516171819202122232425262728293031def gen_items(): \"\"\" 生成随机数组 :return: list \"\"\" res = [] for _ in range(200): sub_res = [] for _ in range(400): sub_res.append(random.randint(1, 1000)) res.append(sub_res) return resitems = gen_items()start_time = time.time()for sub_items in items: bubble_sort(sub_items)end_time = time.time()print(\"冒泡排序耗时：{0}\".format(end_time - start_time))items = gen_items()start_time = time.time()for sub_items in items: insertion_sort(sub_items)end_time = time.time()print(\"插入排序耗时：{0}\".format(end_time - start_time))\"\"\"冒泡排序耗时：3.2597298622131348插入排序耗时：1.7137877941131592\"\"\" 在当前的数据规模和系统环境下，冒泡排序的耗时已经是插入排序的200倍。所以在性能优化的选择上，首选插入排序 总结 是否原地排序 是否稳定 最好 最坏 平均 冒泡排序 是 是 O(n) O(n^2) O(n^2) 插入排序 是 是 O(n) O(n^2) O(n^2) 选择排序 是 否 O(n^2) O(n^2) O(n^2)","link":"/2020/01/09/2020-01-09-01/"},{"title":"排序算法（2）- 归并、快速","text":"归并排序的原理采用分治思想，每次将数组从中间分成两部分，分别对两部分进行排序，直到不能继续分解为止 1234567891011121314151617181920212223242526272829303132333435363738def merge_sort(array): \"\"\" 归并排序：适合大规模数据 :param array: \"\"\" def _merge_sort(start, end): if start &gt;= end: return mid = (start+end) // 2 _merge_sort(start, mid) _merge_sort(mid+1, end) _merge(start, mid, end) def _merge(start, mid, end): i = start j = mid + 1 temp = [] while i &lt;= mid and j &lt;= end: if array[i] &lt; array[j]: temp.append(array[i]) i += 1 else: temp.append(array[j]) j += 1 remaining_start = i remaining_end = mid if j &lt;= end: remaining_start = j remaining_end = end while remaining_start &lt;= remaining_end: temp.append(array[remaining_start]) remaining_start += 1 for idx in range(end-start+1): array[start+idx] = temp[idx] count = len(array) _merge_sort(0, count-1) 归并排序的性能分析 是否是稳定的排序算法，要看merge函数，如果从start-&gt;mid和mid-&gt;end两个区间的存在值相同的元素，那么在合并的时候可以将start-&gt;mid先放入数组，这样就保证了值相同的元素前后顺序不变，所以是一个稳定的排序算法 关于时间复杂度的分析，这里涉及到了递归调用，如果我们定义求解问题a的事件是T(a)，求解问题b、c的时间分别是T(b)和T(c)，那么可以得到这样的递推公式：T(a) = T(b) + T(c) + KK是将两个子问题合并所消耗的时间。假设对n个元素进行归并排序需要的时间是T(n)，那分解成两个子数组排序的的时间就是T(n/2)。merge合并两个子数组的时间复杂度是O(n)。那么归并排序的时间复杂度的计算公式就是： 123456789T(1) = C; n=1T(n) = 2*T(n/2) + n; n&gt;1进一步分解得到：T(n) = 2*T(n/2) + n = 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2*m = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n = 8*(2*T(n/16) + n/8) + 3*n = 16*T(n/16) + 4*n ... = 2^k * T(n/2^k) + k*n 当T(n/2^k) = T(1)时，也就是n/2^k=1，得到k=log2(n)，将k带入上面的公式，得到T(n) = Cn + nlog2(n)。所以 T(n) = O(nlogn) 空间复杂度。每次合并两个子数组的时候，都会创建一个临时数组，合并结束即销毁。所以临时空间最大不会超过n个数据的大小，为O(n)。 快速排序的原理和归并排序相似，都是用到了分治思想，但是实现却是完全不同。快速排序是要在start和end之间找一个任意的元素pivot（分区点），遍历数组，将小于pivot的元素放在左边，大于pivot的元素放在右边，结束后，整个数组就被分为了三个部分，小于pivot的start-&gt;pivot_idx-1，pivot，大于pivot的pivot_idx+1-&gt;end。 123456789101112131415161718192021222324252627def quick_sort(array): \"\"\" 快速排序 :param array: \"\"\" def _quick_sort(start, end): if start &gt;= end: return pivot_idx = _partition(start, end) _quick_sort(start, pivot_idx-1) _quick_sort(pivot_idx+1, end) def _partition(start, end): pivot = array[end] i = start for j in range(start, end): if array[j] &lt; pivot: array[i], array[j] = array[j], array[i] i += 1 array[i], array[end] = array[end], array[i] return i count = len(array) if count &lt;= 1: return _quick_sort(0, count-1) 归并排序的分治思想是先分，后治，先拆分到最后，在合并子数组。而快速排序更像是先治后分，先将比pivot小和大的元素分别排到左右两边，在拆分子数组继续找pivot继续排，直到最后不能排为止。 快速排序的性能分析 快速排序是一种原地（交换部分没有用到额外的空间）、不稳定的排序算法 如果每次分区操作，都能把数组分成大小相等的两个小区间，那快排的时间复杂度递推公式跟归并是相同的，所以快排的时间复杂度也是O(nlogn)。如果排序的数组已经是有序，那么每次分区得到的两个区间都是不均等的，需要进行大约n次分区操作，每次分区平均扫描大于n/2的元素，这种情况下，时间复杂度就退化成了O(n^2)。 总结快排和归并都是通过分治思想、递归调用方式来实现，但是归并排序虽然是一种在任何情况下时间复杂度都比较稳定的排序算法，但是也存在致命缺点，即不是原地排序算法，空间复杂度比较高（O(n)），因此也没有快排应用的广泛。快排的时间复杂度最快情况是O(n^2)，但是平均时间复杂度是O(nlogn)，而且退化到O(n^2)的概率非常小，也可以合理地选择pivot来避免这种情况。","link":"/2020/01/14/2020-01-14-01/"},{"title":"SQL基础教程（2）","text":"函数、谓词、CASE表达式函数先创建表和数据 12345678910111213141516171819create table SampleMath ( m numeric (10, 3), n integer , p integer);start transaction;insert into SampleMath values (500, 0, null);insert into SampleMath values (-180, 0, null);insert into SampleMath values (null, null, null);insert into SampleMath values (null, 7, 3);insert into SampleMath values (null, 5, 2);insert into SampleMath values (null, 4, null);insert into SampleMath values (8, null, 3);insert into SampleMath values (2.27, 1, null);insert into SampleMath values (5.555, 2, null);insert into SampleMath values (null, 1, null);insert into SampleMath values (8.76, null, null);commit; abs(数值)计算绝对值 1select m, abs(m) as abs_col from SampleMath; mod(被除数, 除数)计算除法余数（求余） 1select n, p, mod(n, p) as mod_col from SampleMath; round(对象数值, 保留小数的位数)四舍五入，如果指定位数为1，那么会对小数点第2位进行四舍五入处理 1select m, n, round(m, n) as round_col from SampleMath; 字符串拼接函数Mysql 中使用 concat， PostgreSql 中用 || 1select str1, str2, concat(str1, str2) as str_concat from SampleStr; length函数字符串长度，注意这里由于每个DBMS的计算方式不同，结果可能不一样，这涉及到字符串的字节 1select str1, length(str1) as len_str from SampleStr; lower(字符串)小写转换，对应的upper是大写转换 1select str1, lower(str1) as low_str from SampleStr where str1 in ('ABC', 'aBC', 'abc', '山田'); replace(对象字符串, 替换前的字符串, 替换后的字符串)1select str1, str2, str3, replace(str1, str2, str3) as rep_str from SampleStr; substring(对象的字符串 from 截取的起始位置 for 截取的字符数)1select str1, substring(str1 from 3 for 2) as sub_str from SampleStr; current_date 当前日期1select current_date; current_time 当前时间1select current_time; current_timestamp 当前日期和时间1select current_timestamp; extract 截取日期元素extract(日期元素 from 日期) 1234567select current_timestamp, extract(year from current_timestamp) as year, extract(month from current_timestamp) as month, extract(day from current_timestamp) as day, extract(hour from current_timestamp) as hour, extract(minute from current_timestamp) as minute, extract(second from current_timestamp) as second; cast 类型转换case(转换前的值 as 想要转换的数据类型) 12select cast('0001' as signed integer) as int_col;select cast('2009-12-14' as date) as date_col; coalesce 将NULL转换为其他值coalesce(数据1, 数据2, 数据3…)是sql特有的函数。该函数会返回可变参数中左侧开始第1个不是NULL的值。参数个数是可变的，因此可以根据需要无限增加。在sql语句中将NULL转换为其他值时就会用到转换函数。 12345select coalesce(null, 1) as col_1, coalesce(null, 'test', null) as col_2, coalesce(null, null, '2009-11-01') as col_3; select coalesce(str2, 'NULL') from SampleStr; 谓词like 字符串的部分一致查询查询结果有前方一致、中间一致和后方一致这三个概念 前方一致：其实部分相同 中间一致：存在相同即可，就是说包括前方一致和后方一致 后方一致：末尾部分相同 12345678-- 前方一致select * from SampleLike where strcol like 'ddd%';-- 中间一致select * from SampleLike where strcol like '%ddd%';-- 后方一致select * from SampleLike where strcol like '%ddd'; % 代表 0字符以上的任意字符串_ 代表 任意一个字符，有几个 _ 就只能有几个字符 12select * from SampleLike where strcol like 'abc__';select * from SampleLike where strcol like 'abc___'; between 范围查询包含临界值 1select product_name, sale_price from Product where sale_price between 100 and 1000; is null 、 is not null判断是否为null 12select product_name, purchase_price from Product where purchase_price is null;select product_name, purchase_price from Product where purchase_price is not null; in – or的简便用法否定形式是 not in 12345select product_name, purchase_price from Product where purchase_price = 320 or purchase_price = 500 or purchase_price = 5000;select product_name, purchase_price from Product where purchase_price in (320, 500, 5000);select product_name, purchase_price from Product where purchase_price not in (320, 500, 5000); 使用子查询作为in谓词的参数先创建一个商品商店的关联表 1234567891011121314151617181920212223create table ShopProduct ( shop_id varchar(4) not null , shop_name varchar(200) not null , product_id varchar(4) not null , quantity integer not null , primary key (shop_id, product_id));start transaction ;insert into ShopProduct values ('000A', '东京', '0001', 30);insert into ShopProduct values ('000A', '东京', '0002', 50);insert into ShopProduct values ('000A', '东京', '0003', 15);insert into ShopProduct values ('000B', '名古屋', '0002', 30);insert into ShopProduct values ('000B', '名古屋', '0003', 120);insert into ShopProduct values ('000B', '名古屋', '0004', 20);insert into ShopProduct values ('000B', '名古屋', '0006', 10);insert into ShopProduct values ('000B', '名古屋', '0007', 40);insert into ShopProduct values ('000C', '大阪', '0003', 20);insert into ShopProduct values ('000C', '大阪', '0004', 50);insert into ShopProduct values ('000C', '大阪', '0006', 90);insert into ShopProduct values ('000C', '大阪', '0007', 70);insert into ShopProduct values ('000D', '福冈', '0001', 100);commit ; 找出在大阪销售的商品，这里就要用到子查询 1select product_name, sale_price from Product where product_id in (select product_id from ShopProduct where shop_id = '000C'); exist 谓词理论上都可以用 in 和 not in 来代替。只有1个参数，该参数通常都会是一个子查询。exist通常都会使用关联子查询作为参数 同样的，使用 not exist 表示相反的结果 12select product_name, sale_price from Product as P where exists(select * from ShopProduct as SP where SP.shop_id = '000C' and SP.product_id = P.product_id); case表达式和if-else差不多，有多个条件需要判断，最终只会有一个返回结果 123456789101112select product_name, case when product_type = '衣服' then concat('A: ', product_type) when product_type = '办公用品' then concat('B: ', product_type) when product_type = '厨房用具' then concat('C: ', product_type) else null end as abc_product_typefrom Product;select sum(case when product_type = '衣服' then sale_price else 0 end) as sum_price_clothes, sum(case when product_type = '厨房用具' then sale_price else 0 end) as sum_price_kitchen, sum(case when product_type = '办公用品' then sale_price else 0 end) as sum_price_officefrom Product; 上面使用的是搜索CASE表达式，下面用简单CASE表达式来实现以下 12345678select product_name, case product_type when '衣服' then concat('A: ', product_type) when '办公用品' then concat('B: ', product_type) when '厨房用具' then concat('C: ', product_type) else null end as abc_product_typefrom Product; 简单case表达式看上去和代码里的switch差不多了 集合运算通过集合运算，可以得到两张表中记录的集合或者公共记录的集合，又或者其中某张表中的记录的集合。像这样用来进行集合运算的运算符称为集合运算符。 表的加减法表的加法 - union（并集）会去除重复的记录 1select product_id, product_name from Product union select product_id, product_name from Product2; 注意事项 select的列必须一致 select的列的类型必须一致 如果有order by的话，必须放在最后使用 保留重复行，在union后面加一个all即可 1select product_id, product_name from Product union all select product_id, product_name from Product2; 选取表中公共部分 - intersect（MySQL不支持）希望保留重复行，同样是加上all 1select product_id, product_name from Product intersect select product_id, product_name from Product2; 记录的减法 - except（MySQL不支持）要注意左右关系，左边 - 右边 1select product_id, product_name from Product except select product_id, product_name from Product2 order by product_id; 联结（以列为单位对表进行联结）一个表中的数据往往不够，这时候要从别的表中把列拿过来，这时候用联结以表A的列作为桥梁，将表B中满足同样条件的列汇集到同一结果之中 内联结 - inner join12select SP.shop_id, SP.shop_name, SP.product_id, P.product_name, P.sale_pricefrom ShopProduct as SP inner join Product as P on SP.product_id = P.product_id 内联结要点 进行联结时需要在from字句中使用多张表 on必不可少，它指定了联结条件，需要指定多个键时，可以使用and、or。必须在from和where之间 select指定列时，有些列是共有的，有些列是独有的，独有的列可以不写&lt;表的别名&gt;.&lt;列名&gt;这种形式，共有的一定要写，这里为了不混乱，全都写上表名 内联结和where子句结合使用 12select SP.shop_id, SP.shop_name, SP.product_id, P.product_name, P.sale_pricefrom ShopProduct as SP inner join Product as P on SP.product_id = P.product_id where SP.shop_id = '000A'; 联结之后的结果可以想象为一个新表，我们可以对这个表使用where，group by，having，order by等工具 外连接 - outer join12select SP.shop_id, SP.shop_name, SP.product_id, P.product_name, P.sale_pricefrom ShopProduct as SP right outer join Product as P on SP.product_id = P.product_id; 外连接的结果比内联结多了两条数据，这两条数据是ShopProduct中product_id没有的。也就是说，当我使用外连接时，先像内联结一样，找出联结点关联的数据，如果还有没有关联到的数据，就继续取出来。这里有一个left和right，就涉及到取哪边的数据了。 12select SP.shop_id, SP.shop_name, SP.product_id, P.product_name, P.sale_pricefrom Product as P left outer join ShopProduct as SP on SP.product_id = P.product_id; 这两条sql结果是一样的 3张以上表的联结表的联结是没有数量限制的 准备一个表 12345678910111213141516171819202122232425create table InventoryProduct ( inventory_id char(4) not null , product_id char(4) not null , inventory_quantity integer not null , primary key (inventory_id, product_id));start transaction;INSERT INTO InventoryProduct (inventory_id, product_id, inventory_quantity) VALUES ('P001', '0001', 0);INSERT INTO InventoryProduct (inventory_id, product_id, inventory_quantity) VALUES ('P001', '0002', 120);INSERT INTO InventoryProduct (inventory_id, product_id, inventory_quantity) VALUES ('P001', '0003', 200);INSERT INTO InventoryProduct (inventory_id, product_id, inventory_quantity) VALUES ('P001', '0004', 3);INSERT INTO InventoryProduct (inventory_id, product_id, inventory_quantity) VALUES ('P001', '0005', 0);INSERT INTO InventoryProduct (inventory_id, product_id, inventory_quantity) VALUES ('P001', '0006', 99);INSERT INTO InventoryProduct (inventory_id, product_id, inventory_quantity) VALUES ('P001', '0007', 999);INSERT INTO InventoryProduct (inventory_id, product_id, inventory_quantity) VALUES ('P001', '0008', 200);INSERT INTO InventoryProduct (inventory_id, product_id, inventory_quantity) VALUES ('P002', '0001', 10);INSERT INTO InventoryProduct (inventory_id, product_id, inventory_quantity) VALUES ('P002', '0002', 25);INSERT INTO InventoryProduct (inventory_id, product_id, inventory_quantity) VALUES ('P002', '0003', 34);INSERT INTO InventoryProduct (inventory_id, product_id, inventory_quantity) VALUES ('P002', '0004', 19);INSERT INTO InventoryProduct (inventory_id, product_id, inventory_quantity) VALUES ('P002', '0005', 99);INSERT INTO InventoryProduct (inventory_id, product_id, inventory_quantity) VALUES ('P002', '0006', 0);INSERT INTO InventoryProduct (inventory_id, product_id, inventory_quantity) VALUES ('P002', '0007', 0);INSERT INTO InventoryProduct (inventory_id, product_id, inventory_quantity) VALUES ('P002', '0008', 18);commit; 现在需要把仓库P001的产品数量，和商店的信息、产品信息展示出来 123select SP.shop_id, SP.shop_name, SP.product_id, P.product_name, P.sale_price, IP.inventory_quantityfrom ShopProduct as SP inner join Product as P on SP.product_id = P.product_idinner join InventoryProduct as IP on SP.product_id = IP.product_id where IP.inventory_id = 'P001'; 这里先把ShopProduct表和Product表联结，再和InventoryProduct表联结，Product表就不需要再和InventoryProduct表联结了 交叉联结 - cross join很少使用，但是是所有联结运算的基础 12select SP.shop_id, SP.shop_name, SP.product_id, P.product_namefrom ShopProduct as SP cross join Product as P; 结果有104个记录，ShopProduct有13条记录，Product有8条记录，13x8=104。是两个表交叉组合的结果。所以，内联结是交叉联结的一部分，”内“也可以理解为”包含在交叉联结结果中的部分“。相反，外联结的”外“可以理解为”交叉联结结果之外的部分“","link":"/2020/01/10/2020-01-10-01/"},{"title":"正则表达式的贪婪模式和非贪婪模式","text":"先看一个例子拿到一个数字 123content = \"Xiaoxingxing has 100 bananas\"res = re.match(r'^Xi.*(\\d+)\\s.*s$', content)print(res.group(1)) 我们可以将要匹配的内容用()括起来，这里我们知道 字符 描述 . 代表所有的单个字符，除了 \\n \\r {n} 匹配在 {n} 前面的东西，比如：o{2} 不能匹配 Bob 中的 o, 但是能匹配 food 中的两个 o {n,m} 匹配在 {n,m} 前面的东西，比如：o{1,3} 将匹配”fooooood”中的前三个o {n, } 匹配在 {n,} 前面的东西，比如：o{2,} 不能匹配“Bob”中的“o”，但能匹配“fooooood”中的所有o * 和 {o,} 一样，匹配 * 前面的0次或多次。比如 zo* 能匹配“z”、“zo”以及“zoo” + 和 {1,} 一样，匹配 + 前面的1次或多次。比如 zo+ 能匹配“zo”以及“zoo”，但不能匹配“z” ? 和 {0,1} 一样，匹配 ? 前面0次或1次。 所以理论上，上面的表达式的结果应该是能匹配到100这个数字。但实际结果呢 0 没错，上面的正则表达式匹配到的是0，而要想匹配到100，我们只需要加一个 ?，即 12res = re.match(r'^Xi.*?(\\d+)\\s.*s$', content)print(res.group(1)) 结果为 100 为什么会出现上述情况呢，这里就要弄清楚正则表达式的贪婪和非贪婪模式这两个概念了。 贪婪匹配模式定义正则表达式去匹配时，会尽量多的匹配符合条件的内容 标识符+, ?, *, {n}, {n,}, {n,m} 匹配时，如果遇到上述标识符（匹配不定数量个），代表是贪婪匹配，会尽可能多的去匹配内容。即优先它的匹配，其它的匹配要为它让路 实例 12345content = 'aacbacbc'res = re.match(r\"a.*b\", content)print(res.group())# aacbacb 当匹配到第一个a后，开始匹配.*，由于是贪婪模式，它会一直往后匹配，知道最后一个满足条件的b为止，因此匹配结果是aacbacb 非贪婪匹配模式定义正则表达式去匹配时，会尽量少的匹配符合条件的内容，也就是说，一旦发现匹配符合要求，立马就匹配成功，不会继续匹配下去 标识符+?, ??, *?, {n}?, {n,}?, {n,m}? 实例 123content = 'aacbacbc'res = re.match(r\"a.*?b\", content)print(res.group()) 匹配到第一个a后，开始匹配.*，由于是非贪婪模式，在匹配到了第一个b后，就匹配成功了，因此结果是aacb 最后由于一开始是贪婪模式匹配，会尽可能多的匹配任意字符，而(\\d+)的优先级就会降低，只要保证至少有一个数字匹配到即可，所以第一个正则匹配的结果是0，加上?变成非贪婪模式后，.*?的优先级就变低，(\\d+)的优先级最高，优先匹配一个或多个数字，所以结果是100","link":"/2020/01/15/2020-01-15-01/"},{"title":"brew安装服务开机自启动","text":"通过 brew services start当我们通过 brew install 安装第三方库比如 redis 时，安装完会有这样一段提示 1234567891011121314redis: stable 5.0.7 (bottled), HEADPersistent key-value database, with built-in net interfacehttps://redis.io//Users/lijun/homebrew/Cellar/redis/5.0.7 (13 files, 3.1MB) * Poured from bottle on 2020-02-17 at 18:31:08From: https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git/Formula/redis.rb==&gt; Options--HEAD Install HEAD version==&gt; CaveatsTo have launchd start redis now and restart at login: brew services start redisOr, if you don&apos;t want/need a background service you can just run: redis-server /Users/lijun/homebrew/etc/redis.conf 其中已经说明了为了现在启动和登录时重新启动，请执行 1brew services start redis 使用 services 指令，请先安装1brew tap gapple/services 安装完成后使用 12$ brew services start mysql==&gt; Successfully started `mysql` (label: homebrew.mxcl.mysql) 那么 mysql 服务就会在后台启动，并且电脑开机重新登录也会自启动 原理是利用 launchctl 命令在 OS X 中，服务本身存储在 .plist 文件中，这些文件的位置一般在 ~/Library/LaunchAgents 中。可以使用 launchctl load $PATH_TO_LIST 和 launchctl unload $PATH_TO_LIST 命令来加载和卸载他们，从而达到开机自动运行的目的。 所有通过 brew install 安装的库文件都在 homebrew 的安装文件夹下，通过软连接，将库的 plist 文件链接到 ~/Library/LaunchAgents 中 1ln -sfv homebrew所在文件夹/Cellar/redis/5.0.7/homebrew.mxcl.redis.plist ~/Library/LaunchAgents 然后在加载他们 1launchctl load homebrew所在文件夹/Cellar/redis/5.0.7/homebrew.mxcl.redis.plist 卸载 1launchctl unload homebrew所在文件夹/Cellar/redis/5.0.7/homebrew.mxcl.redis.plist brew services start 其实最后也就是执行了上述的命令。 最后如果卸载了 redis 但是 homebrew 没有把 plist 文件删除的话，可以 1brew services cleanup 当执行brew services start xxx提示 1Error: No such file or directory 可能是放入LaunchAgents的文件有问题，我们可以直接把plist文件拷贝进来 1cp homebrew所在文件夹/Cellar/redis/5.0.7/homebrew.mxcl.redis.plist ~/Library/LaunchAgents 补充当我们使用brew services命令的时候，很有可能出现 1Error: Unknown command: services 这时候就要安装services命令 1234567891011121314151617&gt; curl -o /usr/local/bin/brew-services.rb https://gist.githubusercontent.com/lwe/766293/raw/75a7907004bbff0eb3b072d1d951be2cfe7e5020/brew-services.rb&gt; chmod +x /usr/local/bin/brew-services.rb&gt; brew services helpusage: [sudo] brew services [--help] &lt;command&gt; [&lt;formula&gt;]Small wrapper around `launchctl` for supported formulas, commands available: cleanup Get rid of stale services and unused plists list List all services managed by `brew services` restart Gracefully restart selected service start Start selected service stop Stop selected serviceOptions, sudo and paths: sudo When run as root, operates on /Library/LaunchDaemons (run at boot!) Run at boot: /Library/LaunchDaemons Run at login: /Users/ian/Library/LaunchAgents 但是当安装完之后使用如果出现下面的问题 123456789Error: undefined method `resolve_alias&apos; for Formula:Class/usr/local/bin/brew-services.rb:154:in `service&apos;/usr/local/bin/brew-services.rb:203:in `check&apos;/usr/local/bin/brew-services.rb:193:in `run!&apos;/usr/local/bin/brew-services.rb:397:in `&lt;top (required)&gt;&apos;/System/Library/Frameworks/Ruby.framework/Versions/2.6/usr/lib/ruby/2.6.0/rubygems/core_ext/kernel_require.rb:54:in `require&apos;/System/Library/Frameworks/Ruby.framework/Versions/2.6/usr/lib/ruby/2.6.0/rubygems/core_ext/kernel_require.rb:54:in `require&apos;/usr/local/Homebrew/Library/Homebrew/utils.rb:20:in `require?&apos;/usr/local/Homebrew/Library/Homebrew/brew.rb:106:in `&lt;main&gt;&apos; 请尝试下面的方法 12345678910111213141516171819202122232425262728293031323334Hey there,I&apos;ve been faced this same issue and I figured out this way.[#1](https://github.com/Homebrew/legacy-homebrew/issues/1)I got this message when I ran brew doctor :Warning: You have external commands with conflicting names.Found command `brew-services` in following places:/usr/local/bin/brew-services.rb/usr/local/Library/Taps/homebrew/homebrew-services/cmd/brew-services.rbI&apos;ve been getting this message when I tried to check brew services available$ brew services listWarning: No user-space services controlled by `brew services` running...[#2](https://github.com/Homebrew/legacy-homebrew/issues/2)So, I decided to remove the first installation that was out of Library/Taps directories.rm -rf /usr/local/bin/brew-services.rb[#3](https://github.com/Homebrew/legacy-homebrew/issues/3)Now, to be sure that everything is okay, I ranbrew update &amp;&amp; brew upgrade[#4](https://github.com/Homebrew/legacy-homebrew/issues/4) Finally, brew services is working fine now.$ brew services listName Status User Plistdnsmasq started root /Library/LaunchDaemons/homebrew.mxcl.dnsmasq.plisthttpd22 started root /Library/LaunchDaemons/homebrew.mxcl.httpd22.plistmysql started luciano /Users/luciano/Library/LaunchAgents/homebrew.mxcl.mysql.plistphp56 started luciano /Users/luciano/Library/LaunchAgents/homebrew.mxcl.php56.plist\\o/ 1.删除/usr/local/bin/brew-services.rb文件2.执行 brew update 和 brew upgrade 命令3.brew services list 查看是否可以正确使用","link":"/2020/02/17/2020-02-17-01/"},{"title":"安装mysqlclient报错","text":"安装mysqlclient，报错，一般问题卡在这里 123ld: library not found for -lsslclang: error: linker command failed with exit code 1 (use -v to see invocation)error: command &apos;gcc&apos; failed with exit status 1 首先确保安装了openssl 1brew install openssl 我两台mac用了两种解决方式，很奇怪为什么同一种方式不行，可能是系统版本不一样 MacOS 10.14 1export LIBRARY_PATH=$LIBRARY_PATH:/usr/local/opt/openssl/lib/ 然后执行安装即可 1pip3.8 install mysqlclient MacOS 10.15 1LDFLAGS=-L/usr/local/opt/openssl/lib pip3.8 install mysqlclient","link":"/2020/02/24/2020-02-24-01/"},{"title":"mysqlclient修复image not found","text":"Django项目要用到mysql，安装完mysqlclient之后，启动项目报错 1234567891011INFO Watching for file changes with StatReloaderException in thread django-main-thread:Traceback (most recent call last): File &quot;/Library/Frameworks/Python.framework/Versions/3.8/lib/python3.8/site-packages/django/db/backends/mysql/base.py&quot;, line 16, in &lt;module&gt; import MySQLdb as Database File &quot;/Library/Frameworks/Python.framework/Versions/3.8/lib/python3.8/site-packages/MySQLdb/__init__.py&quot;, line 18, in &lt;module&gt; from . import _mysqlImportError: dlopen(/Library/Frameworks/Python.framework/Versions/3.8/lib/python3.8/site-packages/MySQLdb/_mysql.cpython-38-darwin.so, 2): Library not loaded: /usr/local/opt/mysql/lib/libmysqlclient.20.dylib Referenced from: /Library/Frameworks/Python.framework/Versions/3.8/lib/python3.8/site-packages/MySQLdb/_mysql.cpython-38-darwin.so Reason: image not found...... 后面部分省略，主要看这部分，提示找不到libmysqlclient.20.dylib，之前为了安装mysqlclient，折腾了一大堆，brew update &amp;&amp; brew upgrade，mysql又重新装了一遍，可能是由于这些原因导致的。 打印显示该目录下有一个libmysqlclient.21.dylib 12345678910-rw-r--r-- 1 lijun staff 7.0M 2 24 22:11 libmysqlclient.21.dylib-r--r--r-- 1 lijun staff 7.7M 12 10 04:11 libmysqlclient.alrwxr-xr-x 1 lijun staff 23B 12 10 04:11 libmysqlclient.dylib -&gt; libmysqlclient.21.dylib-r--r--r-- 1 lijun staff 683K 2 24 21:48 libmysqlharness.1.dylib-r--r--r-- 1 lijun staff 7.8M 2 24 21:48 libmysqlrouter.1.dylib-r--r--r-- 1 lijun staff 254K 2 24 21:48 libmysqlrouter_http.1.dylib-r--r--r-- 1 lijun staff 9.5K 12 10 04:11 libmysqlservices.adrwxr-xr-x 13 lijun staff 416B 12 10 04:11 mysqlrouterdrwxr-xr-x 3 lijun staff 96B 2 24 21:48 pkgconfigdrwxr-xr-x 105 lijun staff 3.3K 12 10 04:11 plugin 索性想能不能加一个指向libmysqlclient.21.dylib的软连接libmysqlclient.20.dylib 1ln -sfv /usr/local/opt/mysql/lib/libmysqlclient.21.dylib /usr/local/opt/mysql/lib/libmysqlclient.20.dylib 重新运行项目 12345678910111213python3.8 manage.py runserver [22:11:52]INFO Watching for file changes with StatReloaderPerforming system checks...System check identified no issues (0 silenced).You have 20 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): admin, auth, book, contenttypes, crawler, sessions, user.Run &apos;python manage.py migrate&apos; to apply them.February 24, 2020 - 22:14:58Django version 3.0.3, using settings &apos;bookstore.settings&apos;Starting development server at http://127.0.0.1:8000/Quit the server with CONTROL-C. OK，解决~","link":"/2020/02/24/2020-02-24-02/"},{"title":"写于2020.03.01 23:58","text":"看了下时间，还好是赶上了。没有来不及，总是刚刚好。 小感想从1月15号到2月17号两篇博客之间隔了有一个来月，本来应该能更早更新的，过年回家忙于各种事，又加上新冠病毒导致之前的习惯规律被打破，本来定好的各种学习只好搁浅了，毁灭总是比创造更轻易。 2分钟过后，3.2号就要开始正式去公司上班，希望一切归于以往，病毒也赶紧消散吧。 回顾2019年，本来定好的计划也是一改再改，其实也很迷茫，应该是每年都很迷茫，不过还算有个大方向，只不过是在岔路口选择该往哪个方向而已。到了现在心中的目标才算是渐渐明确。一句话概括就是打工是不可能一直打工的，这辈子也就只能自己搞点事情的样子。 我还是希望能有点自己的东西。做自媒体，做自己的个人博客，个人网站，微信公众号，总之是希望能通过自己的能力帮助到更多的人，大家互惠互利，各取所需。 所以我本人还是往全栈这个方向走，但是在iOS这方面我得继续钻研，把底层的知识都掌握好，为下半年的跳槽做准备。毕竟把本职工作做好，是提升最快速也是相对更明确的一条道路。 2020年目标是年底挣个10W再说，让自己忙碌起来，而不是整天空想，要干这个要干那个，到头来只是想想，跨出那一步，趁着年轻有试错的机会都去尝试一遍。 一切都要努力，走了很多弯路，时不我待，奋斗吧！ 总结努力学习，高效学习，开始尝试，一步一步往前走，不要停。","link":"/2020/03/01/2020-03-01-01/"},{"title":"排序算法（3）- 桶排序、计数排序、基数排序","text":"桶排序（Bucket sort）将要排序的数据分到几个有序的桶里，每个桶里面再单独进行排序，最后把每个桶里的数据依次取出来，组成的序列就是有序序列。 看问题 对一组金额在0-50之间的订单进行排序：22,5,11,41,45,26,29,10,7,8,30,27,42,43,40 我们按0-9，10-19，20-29，30-39，40-49分5个桶，这样每个桶的数据就是[5,7,8]，[10,11]，[22,26,27,29]，[30]，[40,41,42,43,45] 分别对桶内数据排序，再取出即可。 如果要排序的数据有n个，把它们均匀地划分到m个桶内，每个桶里有k=n/m个元素，每个桶内部使用快速排序，时间复杂度为o(klogk)。m个桶排序复杂度就是O(mklogk)，因为k=n/m，所以整个桶排序的时间复杂度就是O(nlog(n/m))。当桶的个数接近数据个数n时，log(n/m)就是一个非常小的常量，这个时候桶排序时间复杂度接近O(n)。 计数排序（Counting sort）如果排序的数据范围不大的话，例如查询高考分数，分数只可能是0780分，或者查询年龄1120岁这样的话，那么就可以分成781个桶或者120个桶，只需要扫描遍历即可，所以时间复杂度是O(n)。 关键点在于”计数”假设有8个考生，分数范围在0~5分之间，分别是：2，5，3，0，2，3，0，3，放在数组A[8]中 A[8] 2 5 3 0 2 3 0 3 以考生成绩作为下标，就能得到一个C[6]的桶，我们用这个桶来存储对应分数的考生个数，得到如下的数据： C[6] 2 0 2 3 0 1 下标 0 1 2 3 4 5 这时对数组顺序求和： C[6] 2 2 4 7 7 8 下标 0 1 2 3 4 5 接下来是怎么计算出每个考生在有序数组中对应的位置 我们从后到前一次扫描A[8]，当扫描倒数第一个3时，查找数组C中下标3对应的数字是7，说明分数小于等于3的考生个数是7，当前数字3就是7个考生里面的最后一个，那就可以把3放进数组R[8]的对应下标6的位置。 R[8] 3 下标 0 1 2 3 4 5 6 7 同时，C[6]中3对应的个数-1 C[6] 2 2 4 6 7 8 下标 0 1 2 3 4 5 加下来是0，对应的是2，则在R[8]中下标为1 R[8] 0 3 下标 0 1 2 3 4 5 6 7 c[0] = c[0] - 1 C[6] 1 2 4 6 7 8 下标 0 1 2 3 4 5 按这样的规律最后数组R内的数据就是从小到达有序排列。 下面是代码描述 123456789101112131415161718192021222324252627282930313233343536373839def counting_sort(array): n = len(array) if n &lt;= 1: return max = array[0] for item in array: if max &lt; item: max = item countArray = [] for i in range(0, max+1): countArray.append(0) # 计算每个元素的个数，放入C中 for i in array: countArray[i] += 1 count = len(countArray) # 依次累加 for i in range(1, count): countArray[i] = countArray[i-1] + countArray[i] resultArray = [0] * n for i in range(n-1, -1, -1): index = array[i] count = countArray[index] resultArray[count-1] = index countArray[index] = count-1 for i in range(0, n): array[i] = resultArray[i]if __name__ == \"__main__\": arr = [2, 5, 3, 0, 2, 3, 0, 3] counting_sort(arr) print(arr) 总结一下，在数据范围不大的场景中，可以使用计数排序，而且计数排序只能给非负整数排序，如果存在负数或小数情况，可以考虑手动调整到正整数范围内。 基数排序（Radix sort)看问题 假设有10万个手机号码，怎么比较快速的从小到达排序？ 用快排可以做到O(nlogn)，用上面的桶排序和计数排序范围太大了不适合，这时候就要用到基数排序。 手机号码有11位，a、b两个手机号，如果a的第一位就比b大，那后面就不用比较了。我们先按照最后一位来排序手机号码，然后再按倒数第二位排序，以此类推，经过11次排序后，手机号码就都有序了。 根据每一位来排序，用桶排序或者计数排序，时间复杂度可以做到O(n)，如果要排序的数据有k位，总的时间复杂度是O(kn)，当k不大的时候，近似于O(n)。 如果排序的数据位数不是等长的，可以先把他们补齐，再排序。 总结基数排序就是可以把数据按位来比较，且每一位是递进关系。此外每一位的范围不能太大。","link":"/2020/03/02/2020-03-02-01/"},{"title":"彻底搞懂import \"\" 和 import <>","text":"今天打开Xcode看到import的时候，突然想起来好像除了在刚出来工作面试iOS的时候背过它们的区别外，后来就再也没有深入了解过这两个究竟是什么作用，以致于到现在连作用区别都一时间说不上来，实在惭愧。今天还是来彻底研究一番。 一般情况下我们新建一个项目，再创建一个类文件比如叫FooView，此时我们要在其它地方用到FooView的时候，我们一般这样 1#import \"FooView\" 当我使用cocoapod安装第三方库，比如安装了Masonry，那么在用到Masonry的时候，一般我都会 1#import &lt;Masonry.h&gt; 为什么不用 “”，因为我发现用””编译器并不会给出提示，所以我一直以为只能用&lt;&gt;，但是在我做过的几个项目中，我其实并没有用到 &lt;&gt;，而是一直都用的 “”，曾经也很奇怪为什么会不一样，但之前也只是想想，可能是项目设置里面加了什么东西，也没有仔细深入了解。（PS：这种精神还是不可取的） 所以就会有这样一个思维：正常情况下，自己新建的文件用””，而通过cocoapod安装或者引用系统库文件，用&lt;&gt; 在Stack Overflow上有一个回答较高的解释： the quoted form is for “local” includes of files (you need to specify the relative path from the current file, e.g. #include “headers/my_header.h”), while the angle-bracket form is for “global” includes — those found somewhere on the include path passed to the compiler。大概意思就是双引号用于引用本地文件，需要指定相对路径，尖括号用于全局引用，路径由编译器提供。 所以当我们用&lt;&gt;引用我们新建的文件的时候，就会有这样一个提示： 1&apos;FooView.h&apos; file not found with &lt;angled&gt; include; use &quot;quotes&quot; instead user header map Enable the use of Header Maps, which provide the compiler with a mapping from textual header names to their locations, bypassing the normal compiler header search path mechanisms. This allows source code to include headers from various locations in the file system without needing to update the header search path build settings。 在Xcode项目 - Build Settings 下搜索：search path 我们会看到有一个Use Header Maps开关，默认是打开的。这个意思是：开启这个开关后，在本地会根据当前目录生成一份文件名和相对路径的映射，依靠这个映射，我们可以直接import工程里的文件，不需要依靠header search path。我们在管理项目的时候，一般都会把文件放在各个模块下面，模块以各个文件夹区分，在Xcode中创建文件夹会有两种方式，一种是虚拟文件夹（文件还是在项目根目录下），一种是真实文件夹。我之前一直觉得他们就是文件在不在一起的区别，当我关掉Use Header Maps这个选项的时候，这两种文件夹在这里又表现出了不一致。 我一开始是用New Group With Folder创建的真实文件夹EventViewController是BaseViewController的子类，在头文件中引用了BaseViewController。当我关掉Use Headers Maps选项的时候，就会报以下错误：相对路径找不到BaseViewController，这时候EventViewController是在Event文件夹下，BaseViewController是在Base文件夹下，由于关闭了Header Maps，所以无法直接引用。 但是当我用虚拟文件夹管理文件的时候，由于他们都是在根目录下，所以通过相对路径引用是完全没有问题的，即使关闭了Use Headers Maps选项。 该如何解决？这时候我们就涉及到Header Search Paths和User Header Search Paths。两者都是提供search path，区别在于一个指明是用户的。并且如果编译器不支持user headers概念，会从header search paths中去寻找。并且看上面有一个Always Search User Paths，但是已经被Deprecated。查阅资料知道 如果开启，&lt;&gt; 和 “” 都可以引用，关闭的话，user headers 只能通过””引用。 我们现在要让编译器知道这个文件在哪里，所以要在search paths里面添加引用文件所在的文件夹。在Header Search Paths里添加的话，无论import “” 还是 import &lt;&gt;都是没有问题的，在User Header Search Paths里添加，只能使用import “” 解答上面cocopad安装第三方库引用的疑问看下面的三种方式 123#import \"Masonry.h\"#import &lt;Masonry.h&gt;#import \"Masonry/Masonry.h\" 思考一下这三种方式是否都正确？...答案是：都正确。 之前一直困惑用哪种方式，又好像哪种方式都正确。这次直接看 search paths下面，发现cocopod在install的时候，会将第三方库的framework路径添加到Header Search Paths下，所以我们可以直接import，也可以import它的模块下的文件 总结如果按照Xcode默认配置的话，自己新建的文件直接import “”使用，cocoapod安装的第三方库使用import “”、import &lt;&gt;都可以使用。如果关闭Use Header Maps，文件不在根目录下的话，需要手动添加路径到search paths中，添加到User Header Search Paths只能通过import ”“使用，添加到Header Search Paths两种方式都可以。 参考：关于Objective-C中的import - 掘金","link":"/2020/03/05/2020-03-05-01/"},{"title":"二分查找（上）","text":"也叫折半查找算法 思考 假设我们有1000万个整数数据，每个数据占8个字节，如何设计数据结构和算法，快速判断某个整数是否出现在这1000万个数据中？占用内存最多不要超过100MB。 二分思想如果从有1000个元素的有序数组找某一个元素，每次取中间（如果是偶数个就-1）的数，判断是大于、小于或等于就直接找到，这样就确定了目标元素的范围，在缩小后的范围中按这样的方式一直找下去，1000/2=500/2=250/2=125-1 /2=62/2=31-1 /2=15-1 /2=7-1 /2=3-1 /2=1,这样最多不超过10次就可以找到目标元素。这就是二分思想。 O(logn)的时间复杂度假设数据大小为n，每次查找后数据都会缩小为原来的一半，最坏情况下，知道查找区间被缩小为空才停止。 1n, n/2, n/4, n/8, ... , n/2^k, ... 当 n/2^k=1 时，k的值就是总共缩小的次数。每一次缩小操作只涉及两个数据的大小比较，所以，经过了k次区间缩小操作，时间复杂度就是O(k)。通过 n/2^k=1，可以得到 k = ㏒(2)n，所以时间复杂度为O(logn)。 这样即使数据量很大，实际 logn 也会非常小。某些时候甚至比 O(1) 还要快。我们在用 O(1) 表示常数时间复杂度的时候，实际上是省略了常数、系数和低阶，O(1) 也有可能是一个非常大的常亮值，比如 O(1000)， O(10000)，这样有时候就还没有 O(logn) 时间复杂度高。 递归与非递归简单实现非递归12345678910111213def binary_search(array, value): low = 0 high = len(array) - 1 while low &lt;= high: mid = low + (high-low)&gt;&gt;1 if array[mid] == value: return mid elif array[mid] &lt; value: low = mid + 1 else: high = mid - 1 return -1 递归12345678910def binary_search(array, low, high, value): if low &gt; high: return -1 mid = low + ((high-low)&gt;&gt;1) if array[mid] == value: return mid elif array[mid] &lt; value: return bsearch(array, mid+1, high, value) else: return bsearch(array, low, mid-1, value) 二分查找的局限性 数据必须是顺序表结构，像数组这样支持随机存储，可以通过下标直接访问元素，如果是链表这样的，每次通过下标获取元素的时间复杂度都是O(n)效率就很低了。 其次必须是有序数据，如果没有序，先进行排序最低时间复杂度是O(nlogn)，如果数据频繁的插入、删除，每次都要先排序的话，成本也不低，所以最好数据没有频繁的插入、删除，是一组景静态数据。 数据量太小也没有意义，直接顺序遍历就够了。 数据量太大也不行，应为要读取到数组中，而数组这样的数据结构为了支持随机访问，需要内存空间连续。如果我们有1GB的数据的话，那么读取到内存中需要1GB的内存空间，而且必须是连续的，这就非常苛刻了。 总结二分查找通过每次取中间元素对比，缩半区间，使得性能非常优秀。但是应用场景也特别有限。","link":"/2020/03/03/2020-03-03-01/"},{"title":"事件响应和传递","text":"iOS设备会产生各种事件：触摸、晃动设备、远程控制等，事件发生了就需要有响应者去接收并处理事件，这就形成了一套事件响应机制。 事件类型在iOS开发中，UIEventType定义了四种事件类型。 123456typedef NS_ENUM(NSInteger, UIEventType) { UIEventTypeTouches, // 最常接触的事件 UIEventTypeMotion, // 加速计，手机摇一摇 UIEventTypeRemoteControl, // 远程控制，例如一些音乐APP的耳机控制 UIEventTypePresses API_AVAILABLE(ios(9.0)), // 一般碰不到，指的是物理按键被按下，例如电视的遥控器。}; 事件响应者和响应链能响应事件的一定是UIResponder或者其子类，常见的有UIView、UIViewController、UIApplication、UIApplicationDelegate。 一个UIResponder通过它的nextResponder方法指向下一个UIResponder，可以重写nextResponder。UIView类就是重写了该方法，如果它是UIViewController的根视图，它的nextResponder会指向viewController，否则就会指向它的父视图。 如果顺着响应者链最终没有找到事件的响应者，这个事件就会被忽略。 UIResponder中对应每种事件都有一系列对应的方法，对于touch来说： 12345- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;- (void)touchesEstimatedPropertiesUpdated:(NSSet&lt;UITouch *&gt; *)touches API_AVAILABLE(ios(9.1)); 如果UIResponder的子类重写了上述方法，那么事件传递到这个类的时候，就会被捕获，不会再往后面传递。举个例子我们在一个添加点击事件的视图上添加一个UIButton子视图，但是不给button添加事件，这时候如果点击button，虽然没有button事件，但是button的父视图的事件也是不会被触发的。如果我们把button换成它的父类UIControl，不添加target，事件就会被传递到父视图上。所以这里可以猜测UIButton是实现了上述响应事件的。 事件传递机制当触摸屏幕，系统会将其包装成一个触摸事件(touch event)，首先会把该事件传递给UIApplication，UIApplication传递给UIWindow，UIWindow会调用 123- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event { // } 得到一个能响应触摸事件的UIView。 UIView的hitTest方法会遍历View的层级结构，找到包含特定touch的最深层的子视图，成为触摸事件的first responder。如果first responder不能响应事件，就会开始沿响应者链向上传递，直到被响应或被忽略。 pointInside:withEvent:如果子视图的区域超过了父视图，默认超出的部分是不会响应事件的，这时候要重写父视图的pointInside:withEvent:方法，让超出的部分返回YES。","link":"/2020/03/05/2020-03-05-02/"},{"title":"二分查找（下）","text":"4种常见的二分查找变形问题 查找第一个值等于给定值的元素 查找最后一个值等于给定值的元素 查找第一个大于等于给定值的元素 查找最后一个小于等于给定值的元素 查找第一个值等于给定值这里都默认数据是从小到达有序排序。 12345678910111213141516def search_first_equal(array, value): low = 0 high = len(array) - 1 while low &lt;= high: mid = low + ((high-low)&gt;&gt;1) if array[mid] == value: if mid == 0 or array[mid-1] != value: return mid else: high = mid - 1 elif array[mid] &lt; value: low = mid + 1 else: high = mid - 1 return -1 思路是在找到mid的值等于value时，我们要知道mid之前是否有相同值的数据，那怎么判断呢：如果mid==0，那么说明在它前面没有元素了， 返回mid；如果mid前一个元素不等于value，那么该mid就是对应第一个值的元素位置。 查找最后一个值等于给定值的元素12345678910111213141516def search_last_equal(array, value): low = 0 high = len(array) - 1 while low &lt;= high: mid = low + ((high-low)&gt;&gt;1) if array[mid] == value: if mid == len(array)-1 or array[mid+1] != value: return mid else: low = mid + 1 elif array[mid] &lt; value: low = mid + 1 else: high = mid - 1 return -1 这个就很简单了，理解了前面的思路就行。 查找第一个大于等于给定值的元素1234567891011121314def search_first_greater_or_equal(array, value): low = 0 high = len(array) - 1 while low &lt;= high: mid = low + ((high-low)&gt;&gt;1) if array[mid] &gt;= value: if mid == 0 or array[mid-1] &lt; value: return mid else: high = mid - 1 else: low = mid + 1 return -1 查找最后一个小于等于给定值的元素1234567891011121314def search_last_less_or_equal(array, value): low = 0 high = len(array) - 1 while low &lt;= high: mid = low + ((high-low)&gt;&gt;1) if array[mid] &lt;= value: if mid == len(array) - 1 or array[mid+1] &gt; value: return mid else: low = mid + 1 else: high = mid - 1 return -1","link":"/2020/03/04/2020-03-04-01/"},{"title":"UI绘制原理","text":"我想搞懂哪些东西？ 这个过程是什么？ 有哪些参与了这个过程？ 它们都干了哪些事？起了什么作用？ 本片源自这里。主要是学习笔记，方便日后查看。 简单说一下CPU和GPU是通过总线连接的，CPU计算输出一个位图，经过总线在合适的时机传给GPU，GPU获取到位图后，会进行图层渲染、纹理合成，将结果放入帧缓存区，由视频控制器根据VSync信号，在指定时间提取帧缓存区中的屏幕显示内容，最终显示到手机屏幕上 CPU和GPU分别做了什么创建UIView后，显示部分就交给了CALayer负责 ，CALayer有一个contents属性，就是我们最终要绘制到屏幕上的位图。比如我们有一个label要显示”hello“，那么contents就是要显示”hello“的位图，系统在合适的时候回调给我们一个drawRect方法，我们可以在这里自定义一些内容，绘制好的这个位图，会经过core animation提交给GPU部分的OpenGL渲染管线，进行最终的位图的渲染以及纹理的合成，最终显示到屏幕上。 CPU的工作 Layout UI布局 文本计算 Display 绘制（drawRect） Prepare 图片解码 Commit 提交位图 GPU的工作（渲染管线） 顶点着色 图元装配 光栅化 片段着色 片段处理 最后提交到帧缓冲区 屏幕图像显示原理CRT的电子枪从上到下逐行扫描，扫描完成后显示器就呈现一帧画面。然后电子枪回到初始位置进行下一次扫描。为了同步显示器的显示过程和系统的视频控制器，显示器会用硬件时钟产生一系列的定时信号。当电子枪换行进行扫描时，显示器会发出一个水平同步信号(HSync)；当一帧画面绘制完成后，电子枪回复到原位，准备画下一帧前，显示器会发出一个垂直同步信号(VSync)。显示器通常以固定的频率进行刷新，这个刷新率就是VSync信号产生的频率。现在的液晶显示屏其原理基本与CRT显示器一致。 帧缓冲和垂直同步如果只有一个帧缓冲区，那么从帧缓冲区读取和写入都会有比较大的效率问题。为了解决这个，GPU会设置两个缓冲区，即双缓冲机制。GPU会先渲染一帧放入一个缓冲区内，用于视频控制器的读取。当下一帧渲染完毕后，GPU会直接把视频控制器的指针指向第二个缓冲区。所以这里就会有一个问题：如果第一帧的数据还没读取完，GPU渲染完下一帧数据并让视频控制器指向了这一帧，视频控制器就会把下一帧的数据显示在显示器上，就会造成画面撕裂的现象。 为了解决这个问题，GPU有一个机制叫做垂直同步(V-Sync)，当开启垂直同步后，GPU会等待显示器的VSync信号发出后，才进行新的一帧渲染和缓冲区更新。这样能解决画面撕裂现象，也增加了画面流畅度，但需要消耗更多的资源，也会带来部分延迟。 iOS图像渲染原理先介绍几个涉及到的概念 UIKit Framework 主要提供：界面呈现能力、事件响应能力、驱动RunLoop运行和与系统内核通信的数据。简单来说就是：主要负责界面展示、事件响应以及是RunLoop的需求方。 QuartzCore Framework与CoreAnimation 前者提供了图形处理和视频图形处理的能力。就是负责把图形图像最终显示到屏幕上。CoreAnimation不仅仅是负责动画的创建和执行，还负责把我们用代码构建的界面显示到屏幕上，实际上是CoreAnimation通过OpenGL ES做的。 CoreGraphics Framework 一个基于C库函数的高级绘画引擎，提供非常强大的轻量级2D渲染能力。可以使用CoreGraphics处理基于path的绘图工作（如 CGPath）、变形操作（如 CGAffineTransform）、颜色管理（如 CGColor）、离屏渲染（如 CGBitmapContextCreateImage）、渲染模式（patterns）、渐变（gredients）、阴影效果、图形数据管理、图形创建、蒙版以及PDF文档的创建、显示和解析。 CoreGraphics负责创建显示到屏幕上的数据模型，QuartzCore(CoreAnimation -&gt; OpenGL ES)负责把CoreGraphics创建的数据模型真正显示到屏幕上。 UIView和CALayer的关系这里介绍的很详细。 UIView继承自UIResponder，可以响应事件，CALayer不行。 UIView是CALayer的代理。UIView主要是对显示内容的管理而CALayer主要侧重显示内容的绘制。View的显示内容有CALayer决定。 UIView负责处理用户交互，CALayer负责绘制内容。平常访问和设置UIView的负责显示的属性实际上访问和设置的都是它的CALayer对应的属性，UIView知识将这些操作封装起来。一个Layer的frame是由它的anchorPoint、position、bounds和transform共同决定的，而一个View的frame知识简单的返回Layer的frame，同样View的center和bounds也是返回Layer的一些属性。 一个UIView只有一个相关联的CALayer（自动创建），同时它也可以支持无数多个子CALayer。 CALayer默认修改属性支持隐式动画，再给UIView的Layer做动画的时候，View作为Layer的代理，Layer通过actionForLayer:forKey:向View请求相应的action（动画行为） layer内部维护着三份layer tree，分别是presentLayer Tree（动画树），modeLayer Tree（模型树），render Tree（渲染树），在做iOS动画的时候，修改动画的属性，在动画的其实是Layer的presentLayer的属性值，而最终展示在界面上的其实是提供View的modeLayer。 UIView与CALayer的界面渲染通过这篇可知： 通过在loadView过程中debug子view的drawRect方法得知：RunLoop处于kCFRunLoopBeforeWaiting状态时，会回调CoreAnimation中监听KCFRunLoopBeforeWaiting的RunLoopObserver，从而通过RunLoopObserver来进一步调用CoreAnimation内部的CA::Transaction::commit();方法，进而一步一步地调用到drawRect方法。 通过在VC里给一个按钮添加点击事件，并在事件对应的selector中修改子view的背景色，debug子view的drawRect:方法得知：RunLoop被iOS系统传递来的点击事件唤醒并由source1处理(__IOHIDEventSystemClientQueueCallback)，并且在下一个runloop里由source0转发给UIApplication(_UIApplicationHandleEventQueue)，从而能通过source0里的事件队列来调用CoreAnimation内部的CA::Transaction::commit();方法。 上面两种情况都是触发CoreAnimation的CA::Transaction::commit();方法来达到触发CALayer/UIView的渲染，所以这个CA::Transaction机制很关键。 CA::Transaction已经进入到了Quartz Core的内部(Core Animation)，即调用CA::Transaction::commit();来创建CATrasaction，然后进一步调用-[CALayer drawInContext:]() 回调CALayer的Delegate(UIView)，问UIView有没有需要画的内容，即回调到drawRect:方法。 在drawRect:方法里面可以通过CoreGraphics函数或UIKit中对CoreGraphics封装的方法进行画图操作，这些画图的操作内容都是以Off-Screen离屏(广义的离屏，因为没有再GPU中进行)方式进行画图。 无论是有UIView参与的或是直接采用CALayer渲染的操作都会体现在CALayer上(在没有CoreGraphics参与的情况下，UIView或CALayer本身也有一些在业务层面需要显示的内容，所以这里说的”体现在CALayer上”，是泛指UIView的子视图或CALayer的子图层以及CoreGraphics参与的内容)。 CoreAnimation(CALayer)把它的内容转换成位图(纹理)，然后通过OpenGL ES把位图内容传送到GPU的帧缓冲区。 等到由iOS显示屏时钟信号驱动的VSync信号来临时，则把GPU帧缓冲区里的内容显示iOS显示屏上。 Core Animation 流水线app本身并不负责渲染，渲染是由一个独立的进程负责，即 Render Server 进程。App 通过 IPC 将渲染任务及相关数据提交给 Render Server。Render Server 处理完数据后，再传递至 GPU。最后由 GPU 调用 iOS 的图像设备进行显示。 首先，由app处理事件（Handle Events），如：用户的点击操作，在此过程中app可能需要更新视图树，相应的，图层树也会被更新。 其次，app通过CPU完成对显示内容的计算，如：视图的创建、布局计算、图片解码、文本绘制等。在完成对显示内容的计算之后，app对图层进行打包，并在下一次RunLoop时将其发送至Render Server，即完成了一次Commit Transaction操作。 Render Server主要执行Open GL、Core Graphics相关程序，并调用GPU。 GPU则在物理层上完成了对图像的渲染。 最终，GPU通过Frame Buffer、视频控制器等相关部件，将图像显示在屏幕上。 在Core Animation流水线中，app调用Render Server前的最后一步Commit Transaction其实可以细分为4个步骤： Layout：Layout阶段主要进行视图构建，包括：LayoutSubViews方法的重载，addSubview：方法填充子视图等。 Display：Display阶段主要进行视图绘制，这里仅仅是设置最需要成像的图元数据。重载试图的drawRect: 方法可以自定义UIView的显示，其原理是在drawRect:方法内部绘制寄宿图，该过程使用CPU和内存。 Prepare：Prepare阶段属于附加步骤，一般处理图像的解码和转换等操作。 Commit：Commit阶段主要讲图层进行打包，并将它们发送至Render Server。改过程会递归执行，因为图层和视图都是以树形结构存在。 iOS动画的渲染也是基于Core Animation流水线完成的。 调用 animationWithDuration:animations: 方法 在 Animation Block 中进行 Layout，Display，Prepare，Commit 等步骤 Render Server 根据 Animation 逐帧进行渲染。 绘制流程总结 计算机系统中CPU、GPU、显示器是以上面这种方式协同工作的。CPU计算好显示内容提交到GPU，GPU渲染完成后将渲染结果放入帧缓存区，随后视频控制器会按照VSync信号，逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。 在VSync信号到来后，系统图形服务会通过CADisplayLink机制通知App，App主线程就开始在CPU中计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等。随后CPU会将计算好的内容提交到GPU去，由GPU进行变换、合成、渲染。随后GPU会把渲染结果提交到帧缓冲区去，等待下一次VSync信号到来时显示到屏幕上。由于垂直同步的机制，如果在一个VSync时间内，CPU或者GPU没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。这就是界面卡顿的原因。 iOS的显示系统是由VSync信号驱动的，VSync信号由硬件时钟生成，每秒钟发出60次（这个值取决设备硬件，比如iPhone真机上通常是59.97）。iOS图形服务接收到VSync信号后，通过IPC通知到APP内。APP的RunLoop在启动后会注册对应的CFRunLoopSource通过mach_port接收传过来的时钟信号通知，随后Source的回调会驱动整个APP的动画与显示。 Core Animation在RunLoop中注册了一个Observer，监听了 BeforeWaiting 和Exit事件。当一个触摸事件到来时，RunLoop被唤醒，APP中的代码会执行一些操作，比如创建和调整视图层级、设置UIView的frame、修改CALayer的透明度、为视图添加一个动画；这些操作最终都会被CALayer标记，并通过CATransaction提交到一个中间状态去。当上面所有操作结束后，RunLoop即将进入休眠（或者退出）时，关注该事件的Observer都会得到通知。这时Core Animation注册的那个Observer就会在回调中，把所有中间状态合并并提交到GPU去显示；如果此时有动画，通过DisplayLink稳定的刷新机制会不断的唤醒RunLoop，使得不断的有机会出发Observer回调，从而根据时间来不断更新这个动画的属性值并绘制出来。为了不阻塞主线程，Core Animation的核心是OpenGL ES的一个抽象物，所以大部分的渲染是直接提交给GPU来处理。而Core Graphics/Quartz 2D的大部分绘制操作都是在主线程和CPU上同步完成的，比如自定义UIView的drawRect里用CGContext来画图。 Core Animation 在 RunLoop 中注册了一个Observer监听Before Waiting（即将进入休眠）和Exit（即将推出Loop）事件。当在操作UI时，比如改变了Frame、更新了UIView_CALayer的层次时，或者手动调用了UIView_Calayer的setNeedsLayout_setNeedsDisplay方法后，这个UIView_CALayer就被标记为待处理，并被提交到一个全局的容器去。当Observer监听的事件到来时，回调执行函数中会遍历所有待处理的UIView/CALayer以执行实际的绘制和调整，并更新UI界面。 CPU和GPU渲染GPU渲染OpenGL中，GPU屏幕渲染有一下两种方式： On-Screen Rendering意为当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行 Off-Screen Rendering离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。按照这样的说法，如果将不在GPU的当前屏幕缓冲区中进行的渲染都称为离屏渲染，那么就还有另一种特殊的“离屏渲染”方式——CPU渲染 CPU渲染如果我们重写drawRect方法，并且使用任何Core Graphics的技术进行了绘制，就涉及到了CPU渲染。整个渲染过程由App内同步地完成，渲染得到的bitmap最后再交由GPU用于显示。 离屏渲染相比于当前屏幕渲染，离屏渲染的代价很高。这里和这里介绍的很详细，主要体现在两个方面： 创建新缓冲区 要想进行离屏渲染，首先要创建一个新的缓冲区 上下文切换 离屏渲染的整个过程，需要多次切换上下文环境：先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）；等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上，又需要将上下文环境从离屏切换到当前屏幕。而上下文环境的切换是要付出很大代价的。 设置了以下属性时，都会触发离屏绘制： shouldRasterize（光栅化） masks（遮罩） shadows（阴影） edge antialiasing（抗锯齿） group opacity（不透明） 需要注意的是，如果shouldRasterize被设置成YES，在触发离屏绘制的同时，会将光栅化后的内容缓存起来，如果对应的layer及其sublayer没有发生改变，在下一帧的时候可以直接复用。这将在很大程度上提升渲染性能。而其它属性如果是开启的，就不会有缓存，离屏绘制会在每一帧都发生。 开发时需要根据实际情况来选择最优的实现方式，尽量使用On-Screen Rendering。简单的Off-Screen Rendering可以使用Core Graphics让CPU来渲染。","link":"/2020/03/07/2020-03-07-01/"},{"title":"异步绘制","text":"本文源自这里 UI绘制的过程当调用[UIView setNeedsDisplay]方法时，系统会立即调用对应的layer的setNeedsDisplay，之后给layer打上标记，在一次RunLoop将要结束时，会调用[CALayer display]方法，然后进入到真正的绘制过程当中。 [CALayer display]方法内部实现中，会判断有没有layer的delegate响应了displayLayer方法，如果没有会执行系统绘制流程，如果响应了就为我们提供了异步绘制的入口。 系统绘制流程在CALayer内部会创建一个backing store(CGContextRef)，然后layer会判断它是否有代理，如果没有代理的话，会调用[CALayer drawInContext:]， 如果有代理，会调用[layer.delegate drawLayer: inContext]，然后做当前视图的绘制工作，这部分是发生在系统内部的，然后在一个合适的时机给予我们一个回调方法，就是[UIView drawRect:]，[UIView drawRect:]的默认实现是什么都不做，给我们开一个口子，就允许我们在系统绘制的基础上做一些其他的相关的绘制工作，最后不论是哪个分支，都是由CALayer上传对应的backing store（可以理解为位图）到GPU 异步绘制[layer.delegate drawLayer:inContext:]方法实现就可以进入到异步绘制的流程 代理负责生产对应的bitmap 设置该bitmap作为layer.contents属性的值 异步绘制的机制和流程在调用setNeedsDisplay方法之后，在当前RunLoop快要结束时，由系统调用视图所对应的CALayer的display方法，然后如果代理实现了displayLayer:函数，会调用代理的displayLayer:函数方法，然后会通过子线程的切换，在子线程中做位图的绘制，此时主线程可以做别的事。 在全局并发队列子线程中 通过CGBitmapContextCreate()函数来创建一个位图的上下文 通过CoreGraphics的相关api做当前UI空间的绘制工作 再通过CGBitmapContextCreateImage()函数来根据当前所绘制的上下文，生成一张CGImage图片 然后回到主队列中提交位图，设置给CALayer的contents属性，这样就完成了一个UI控件的异步绘制","link":"/2020/03/09/2020-03-09-01/"},{"title":"改造链表支持\"二分查找\"","text":"改造之后的数据结构叫做跳表，支持类似”二分“的查找算法。 怎么提高链表查找效率？正常链表的查询，因为要从头开始遍历，所以时间复杂度是O(n)。 试想一下给链表建立一个索引，我们先按照每2个节点提取1个节点，那么就可以建立这样的节点索引 如果我们要查找某个节点，比如8，我们可以现在第一层索引遍历，找到8所在的区间节点，8比节点7大，比9节点小，那么从7的down指针找到原链表这一层，继续往后遍历就找到8所在的节点位置了。这样，原来如果查找8需要遍历8个节点，现在只需要遍历5个节点。 我们还可以在第一层的索引基础上，继续按每两个节点抽取一个节点来建立索引。 跳表查询有多快？按每两个节点抽一个节点来算，第一级索引的节点个数为：n_2，第二级的节点个数为：n/4，以此类推，第k级的节点个数为：n_(2^k)。假设索引有h级，最高级的索引有2个节点，则可以得到这样一个公式： 123n/(2^h) = 2=&gt;h = log(2)n - 1 如果包含原始链这一层，那么h的高度就是log(2)n。如果每一层都要遍历m个节点，那么跳表中查询一个数据的时间复杂度为O(m*logn)。 那么m的值是多少呢？按照前面每2个取1一个节点的规则，那么m的值应为3。当遍历到某个层级的某个节点x时，除了要和x比较，还要和x的下一级节点y比较，如果在x和y之间，那么到x的down指向的下一级，根据之前的规则，x和y分别对应的下一级节点之间只有一个节点，所以每一层最多只需要遍历3个。 所以，在跳表中，查询一个数据的时间复杂度为O(logn)，和二分查找的时间复杂度是一样的。 跳表消耗多少内存？我觉得所有时间复杂度低的算法，在空间复杂度上一定是有抵消的。跳表也是如此，它查询快的原因，是建立在增加了很多层索引的基础上。每层索引的节点数减半，知道减少到2个节点为止，就是一个等比数列。 12原始链表大小为n，每2个节点抽1个节点，每层索引的节点数为：n/2, n/4, n/8, ..., 8, 4, 2 节点总和就是 1n/2+n/4+n/8…+8+4+2 = n-2 也就是说，我们需要额外增加n个节点的空间。 关于跳表的插入和删除关于插入操作和链表是一样的，都是O(1)的时间复杂度，区别在于定位的查找上，跳表在查找上是O(logn)的时间复杂度，而链表是O(n)。关于删除，跳表不光要删除原链表中的，还需要删除索引中的。 跳表索引动态更新如果我们不停的往跳表中插入数据，不更新索引，就又可能出现某2个节点间数据非常多的情况下，极端情况下，还会退化成单链表。所以需要某种手段来维护索引与原始链表大小间的平衡，如果链表中节点多了，索引节点就相应增加。和红黑树、AVL树这样的平衡二叉树，通过左右旋的方式保持左右子树的大小平衡不同，跳表是通过随机函数来维护前面提到的”平衡性“。 当我们往跳表中插入数据的时候，通过一个随机函数，来决定将这个节点插入到哪几级索引中，比如随机函数生成了值K，就将这个节点添加到第1级到第k级的索引中。这里的随机函数选择，以后再研究。。。 Redis为什么要用跳表来实现有序集合，而不是红黑树Redis中的有序集合支持的核心操作主要有下面这几个： 插入一个数据 删除一个数据 查找一个数据 按照区间查找数据 迭代输出有序序列 其中插入、删除、查找以及迭代输出有序序列红黑树也可以完成，效率是一样的，但是按照区间查找这个操作，跳表可以做到O(logn)的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了，非常高效。 而且，跳表更容易代码实现，相比红黑树来说更易懂，跳表更加灵活，可以通过改变索引构建策略，有效平衡执行效率和内存消耗。","link":"/2020/03/09/2020-03-09-02/"},{"title":"界面性能优化","text":"CPU资源消耗原因和解决方案对象创建 对象的创建会分配内存、调整属性、甚至还有读取文件等操作，比较消耗CPU资源，尽量用轻量的对象带它重量的对象。 CALayer比UIView要轻量许多，如果控件不需要响应触摸事件，可以用CALayer代替。 如果对象不涉及UI操作，尽量放到后台线程去创建。 包含CALayer的控件，只能在主线程创建和操作。 通过StoryBoard创建视图对象，消耗资源严重。不建议用。 对象调整CALayer内部并没有属性，当调用属性方法时，它内部是通过运行时 resolveInstanceMethod 为对象临时添加一个方法，并把对应属性值保存到内部的一个 Dictionary 里，同时还会通知 delegate、创建动画等等，非常消耗资源。UIView的关于显示的属性（比如frame_bounds_transform）等实际上都是CALayer属性映射来的，所以对UIView的这些属性进行调整时，消耗的资源要远大于一般的属性。所以要尽量减少不必要的属性修改 对象销毁对象消耗消耗资源不多，但是如果有容器持有大量对象，也是可以优化的。把他们放到后台去释放，这里介绍个小tip： 12345NSArray *tmp = self.array;self.array = nil;dispatch_async(queue, ^{ [tmp class];}); 把对象捕获到block中，然后扔到后台队列去随便发送个消息以免编译器警告，就可以让对象在后台线程销毁了。 布局计算计算视图布局是App中最为常见的消耗资源的地方，尽量在后台线程提前计算好视图布局、并且对视图布局进行缓存。 AutoLayout自动布局对于复杂的视图来说，可能会产生性能问题。如果遇到这种情况，建议使用手动布局，或者ComponentKit、AsyncDisplayKit等框架。 文本计算如果一个界面包含大量文本（比如微博、微信朋友圈等），文本的宽高计算会占用很大一部分资源，并且不可避免。如果对文本显示没有特殊要求，可以参考UILabel内部的实现方式：用[NSAttributedString boundingRectWithSize:options:context]来计算文本宽高，用[NSAttributedString drawWithRect:options:context]来绘制文本。尽管这两个方法性能不错，但仍旧需要放到后台线程进行以避免阻塞主线程。如果用CoreText绘制文本，可以先生成CoreText排版对象，然后自己计算。并且CoreText对象还能保留以供稍后绘制使用。 文本渲染屏幕上能看到的所有文本内容控件，包括UIWebView，在底层都是通过CoreText排版、绘制为Bitmap显示的。常见的文本空间（UILabel、UITextView等），其排版和绘制都是在主线程进行的，当显示大量文本时，CPU的压力会非常大。对此解决方案只有一个，那就是自定义文本空间，用TextKit 或最底层的CoreText对文本异步绘制。CoreText对象创建好后，能直接获取文本的宽高等信息，避免了多次计算（调整UILabel大小时算一遍、UILabel绘制时内部再算一遍）；CoreText对象占用内存较少，可以缓存下来以备稍后多次渲染。 图片解码用UIImage或CGImageSource的那几个方法创建图片时，图片数据并不会立刻解码。图片设置到UIImageView或者CALayer.contents中去，并且CALayer被提交到GPU前，CGImage中的数据才会得到解码。这一步是发生在主线程的，并且不可避免。如果想要绕开这个机制，常见的做法是在后台线程先把图片绘制到CGBitmapContext中，然后从Bitmap直接创建图片。 图像绘制图像的绘制通常是指用那些以CG开头的方法把图形绘制到画布中，然后从画布创建图片并显示这个过程。这个最常见的地方就是[UIView drawRect:]里面。由于CoreGraphic方法通常都是现场安全的，所以图形的绘制可以很容易的放到后台线程进行。一个简单的异步绘制的过程大致如下： 12345678910- (void)display { dispatch_async(backgroundQueue, ^{ CGContextRef ctx = CGBitmapContextCreate(…); CGImageRef img = CGBitmapContextCreateImage(ctx); CFRelease(ctx); dispatch_async(mainQueue, ^{ layer.contents = img; }); });} GPU资源消耗原因和解决方案相对于CPU来说，GPU能干的事情比较单一：接收提交的纹理（Texture）和顶点描述（三角形），应用变换（transform）、混合并渲染，然后输出到屏幕上。通常所能看到的内容，主要也就是纹理（图片）和形状（三角模拟的矢量图形）两类。 纹理的渲染所有的Bitmap，包括图片、文本、栅格化的内容，最终都是由内存提交到显存，绑定为GPU Texture。不论是提交到显存的过程，还是GPU调整和渲染Texture的过程，都要消耗不少GPU资源。当在较短时间显示大量图片时（比如TableView存在非常多的图片并且快速滑动时），CPU占用率很低，GPU占用非常高，界面仍然会掉帧。避免这种情况的方法只能是尽量减少在短时间内大量显示图片的显示，尽可能将多张图片合成为一张进行显示。当图片过大时，超过GPU的最大纹理尺寸时，图片需要由CPU进行预处理，这对CPU和GPU都会带来额外的资源消耗。目前来说，iPhone 4s以上机型，纹理尺寸上限都是4096x4096，所以，尽量不要让图片和视图的大小超过这个值。 视图的混合当多个视图（或者说CALayer）重叠在一起显示时，GPU会首先把它们混合到一起。如果视图结构过于复杂，混合的过程也会消耗很多GPU资源。为了减轻这种情况的GPU消耗，应当尽量减少视图数量和层次，并在不透明的视图里表明opaque属性以避免无用的Alpha通道合成。也可以用上面的方法，把多个视图预先渲染为一张图片来显示。 图形的生成CALayer的border、圆角、阴影、遮罩（mask），CASharpLayer的矢量图形显示，通常会触发离屏渲染（offscreen rendering），而离屏渲染通常发生在GPU中。当一个列表视图中出现大量圆角的CALayer，并且快速滑动时，GPU会被大量占用，但是CPU资源消耗很少。这时帧数就会降低。为了避免这种情况，可以尝试开启CALayer.shouldRasterize属性，把原本离屏渲染的操作转移到CPU上去。对于只需要圆角的某些场合，也可以用一张已经绘制好的圆角图片覆盖到原本视图上面来模拟相同的视觉效果。最彻底的解决办法，就是把需要系那是的图形在后台线程绘制为图片，避免使用圆角、阴影、遮罩等属性。","link":"/2020/03/10/2020-03-10-02/"},{"title":"设置navigationItem","text":"在设置navigationItem的时候，如果要添加图片，图片大小无法自己控制，只能用默认的图片大小，解决方法：把button放在一个view上，设置view的frame即可 1234567let view = UIView(frame: CGRect(x: 0, y: 0, width: 25, height: 25))let button = UIButton(type: .custom)button.frame = view.framebutton.setImage(UIImage(named: \"settings\"), for: .normal)view.addSubview(button)let buttonItem = UIBarButtonItem(customView: view)self.navigationItem.setLeftBarButton(buttonItem, animated: true)","link":"/2020/03/10/2020-03-10-01/"},{"title":"探究KVO的底层实现","text":"KVO是什么？KVO全称KeyValueObserving，俗称键值监听。就是允许监听对象属性的改变，从而响应特定的事件。 KVO做了什么呢？重写对象的setter方法吗？我在Person类里面，重写了age的setter方法， 12345678910111213141516@interface Person : NSObject@property (nonatomic, assign) NSInteger age;@end#import \"Person.h\"@implementation Person- (void)setAge:(NSInteger)age { NSLog(@\"设置age: %ld\", age); _age = age;}@end 发现监听器的observeValueForKeyPath方法还是会执行 1234567891011121314- (void)viewDidLoad { [super viewDidLoad]; Person *p1 = [Person new]; p1.age = 1; NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld; [p1 addObserver:self forKeyPath:@\"age\" options:options context:nil]; p1.age = 10; [p1 removeObserver:self forKeyPath:@\"age\"];}- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context { NSLog(@\"监听到%@的%@改变了%@\", object, keyPath, change);} 思考是不是对对象做了一些改变，打断点打印一下它们的内存地址试试：在person对象addObserver之前： 12(lldb) po p1&lt;Person: 0x600003924b70&gt; addObserver之后 12(lldb) po p1&lt;Person: 0x600003924b70&gt; 没有任何变化。在打印一下它们的isa指针试试 12345(lldb) po p1-&gt;isaPerson(lldb) po p1-&gt;isaNSKVONotifying_Person persion对象的isa指针指向的类变化了！ 底层实现分析正常情况下，一个person实例对象，设置它的属性，会通过它的isa指针，找到它所属的类对象，通过类对象再找到它的setAge方法，然后找到方法对应的实现。但是刚才我们发现p1对象的isa指针在经过KVO之后，指向的是NSKVONotifying_Person类对象了。 12(lldb) po [p1-&gt;isa isSubclassOfClass:[Person class]]YES 通过打印发现，NSKVONotifying_Person其实是Person类的子类，说明是runtime在运行时生成的。所以此时的p1对象在调用setAge方法时，找到的类对象已经是NSKVONotifying_Person类了，调用的也是它里面的setAge方法。查找网上资料可以知道，NSKVONotifying_Person中的setAge方法其实调用了Foundation框架中C语言函数 _NSSetIntValueAndNotify，_NSSetIntValueAndNotify内部做的操作相当于，首先调用willChangeValueForKey ，之后调用父类的setAge方法对成员变量赋值，最后调用didChangeValueForKey。didChangeValueForKey中会调用监听器的监听方法，最终来到监听这的observeValueForKeyPath方法中。 验证上述分析我们检验一下setAge方法的内存地址 123456NSLog(@&quot;添加KVO监听之前 p1 setAge = %p&quot;, [p1 methodForSelector:@selector(setAge:)]); NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;[p1 addObserver:self forKeyPath:@&quot;age&quot; options:options context:nil]; NSLog(@&quot;添加KVO监听之后 p1 setAge = %p&quot;, [p1 methodForSelector:@selector(setAge:)]); 通过methodForSelector方法获取方法实现地址 1234562020-03-17 23:28:06.388425+0800 AwesomeOC[1599:156522] 添加KVO监听之前 p1 setAge = 0x102d71390(lldb) p (IMP)0x102d71390(IMP) $0 = 0x0000000102d71390 (AwesomeOC`-[Person setAge:] at Person.m:13)2020-03-17 23:28:25.218130+0800 AwesomeOC[1599:156522] 添加KVO监听之后 p1 setAge = 0x7fff257228bc(lldb) p (IMP)0x7fff257228bc(IMP) $1 = 0x00007fff257228bc (Foundation`_NSSetLongLongValueAndNotify) 在获取到方法地址之后，打印方法实现发现，添加KVO之后，实现由Person类转换为了Foundation框架中的_NSSetLongLongValueAndNotify实现。 注意一下这里的_NSSetLongLongValueAndNotify，我现在设置的age类型是NSInteger，如果我改成double类型，那么就会变成_NSSetDoubleValueAndNotify。根据不同的属性会调用不同的函数。可以猜测还会有_NSSetBoolValueAndNotify，_NSSetFloatValueAndNotify等等这些函数。 NSKVONotifying_Person我们通过runtime来分别打印Person类和NSKVONotifying_Person类对象内存储的实例方法。 1234567891011121314151617- (void)printMethods:(Class)cls { unsigned int count; Method *methods = class_copyMethodList(cls, &amp;count); NSMutableString *methodNames = [NSMutableString string]; [methodNames appendFormat:@\"%@ - \", cls]; for (int i = 0; i &lt; count; i++) { Method method = methods[i]; NSString *methodName = NSStringFromSelector(method_getName(method)); [methodNames appendString:methodName]; [methodNames appendString:@\" \"]; } NSLog(@\"%@\", methodNames); free(methods);} 打印结果如下： 12342020-03-17 23:40:29.327795+0800 AwesomeOC[1731:176338] 添加KVO监听之前 p1 setAge = 0x10de671902020-03-17 23:40:29.327921+0800 AwesomeOC[1731:176338] Person - age setAge:2020-03-17 23:40:29.328166+0800 AwesomeOC[1731:176338] 添加KVO监听之后 p1 setAge = 0x7fff2572215c2020-03-17 23:40:29.328254+0800 AwesomeOC[1731:176338] NSKVONotifying_Person - setAge: class dealloc _isKVOA Person类中有 age 和 setAge 方法，NSKVONotifying_Person类中有四个方法：setAge，class，dealloc，_isKVOA。现在我们可以重写屡一下他们之间的调用顺序了。这里NSKVONotifying_Person重写了class方法，是为了隐藏NSKVONotifying_Person这个中间类，这样即使我们在添加了KVO之后，打印Person对象的class，也只会是Person。 123- (Class)class { return class_getSuperclass(object_getClass(self));} willChangeValueForKey和didChangeValueForKey在Person类中重写这两个方法 1234567891011- (void)willChangeValueForKey:(NSString *)key { NSLog(@\"willChangeValueForKey begin\"); [super willChangeValueForKey:key]; NSLog(@\"willChangeValueForKey end\");}- (void)didChangeValueForKey:(NSString *)key { NSLog(@\"didChangeValueForKey begin\"); [super didChangeValueForKey:key]; NSLog(@\"didChangeValueForKey end\");} 重新运行一下看看打印结果 1234567892020-03-17 23:56:56.052579+0800 AwesomeOC[1813:197178] willChangeValueForKey begin2020-03-17 23:56:56.052661+0800 AwesomeOC[1813:197178] willChangeValueForKey end2020-03-17 23:56:56.052721+0800 AwesomeOC[1813:197178] didChangeValueForKey begin2020-03-17 23:56:56.052906+0800 AwesomeOC[1813:197178] 监听到&lt;Person: 0x600002a30470&gt;的age改变了{ kind = 1; new = 10; old = 2;}2020-03-17 23:56:56.053017+0800 AwesomeOC[1813:197178] didChangeValueForKey end 通过这里的顺序可以发现，在didChangeValueForKey方法内部，调用了observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context方法。 所以我们是否可以手动触发KVO呢？答案是可以的。通过手动调用willChangeValueForKey和didChangeValueForKey方法即可。 12[p1 willChangeValueForKey:@“age”];[p1 didChangeValueForKey:@“age”]; 打印结果 123452020-03-18 09:40:30.460369+0800 AwesomeOC[68954:1537453] 监听到&lt;Person: 0x600002d80fe0&gt;的age改变了{ kind = 1; new = 2; old = 2;} 现在对于KVO差不多有概念了实例对象在添加了KVO之后，runtime会在运行时创建一个继承该类的NSKVONotifying_XXX类，然后实例对象的isa指针会指向该类。那么添加KVO之后的实例对象，它的class其实已经是NSKVONotifying_XXX类，我们打印它的class之所以还是原来的类名，是因为NSKVONotifying_XXX重写了class方法。当我们设置属性的时候，就会找到NSKVONotifying_XXX类的方法，我猜测那里面的设置属性的函数就是 12345- (void)setAge:(NSInteger)age { [self willChangeValueForKey]; [super setAge:age]; [self didChangeValueForKey];} 最终，didChangeValueForKey会回调observeValueForKeyPath。","link":"/2020/03/18/2020-03-18-01/"},{"title":"Xcode真机运行crash dyld: Library not loaded","text":"最近在做一个项目，在手机上跑的没问题，但是某一天突然就不能运行了。一直报这个错 但是奇怪的是模拟器可以正常运行，尝试了很多解决办法，最后发现这应该是iOS13.3的bug，而且没有苹果开发者会员才会出现。解决办法： 开通苹果开发者会员，重新安装证书和描述文件 或者 等iOS13.4更新，或者找低版本的机子安装运行","link":"/2020/03/21/2020-03-21-01/"},{"title":"关于KVC","text":"键值编码在iOS开发中，允许通过key名直接访问或者赋值对象的属性，而不用通过存取方法。这样就可以在运行时动态的访问和修改对象的属性，而不是在编译时确定。 定义与使用KVC的定义是通过对NSObject的扩展来实现的，有个显示的NSKeyValueCoding类别名，对于所有继承了NSObject的类型，都能使用KVC。 寻找key我们可以在Xcode里面，打开NSKeyValueCoding.h文件，里面有关于KVC的完整介绍。 valueForKey: 首先按照-get&lt;Key&gt;, -&lt;key&gt;, or -is&lt;Key&gt;的顺序来查找，如果找到的值是一个object类型就直接返回，如果是一个数据类型就会转换成NSNumber对象返回，如果是结构体类型（不仅限于：NSPoint，NSRange，NSRect，NSSize），就转换成NSValues返回 如果上面没有找到，就会开始查找下面几个方法-countOf&lt;Key&gt; 、 -indexIn&lt;Key&gt;OfObject: 、-objectIn&lt;Key&gt;AtIndex: 、 -&lt;key&gt;AtIndexes: 只要-countOf&lt;Key&gt;和-indexIn&lt;Key&gt;OfObject:和后面两个至少一个方法被发现了，就会返回一个可以相应所有NSOrderedSet方法的集合代理对象。所有的NSOrderedSet消息都会被发送到这个对象上，并且将会以组合的形式调用-countOf&lt;Key&gt;, -indexIn&lt;Key&gt;OfObject:, -objectIn&lt;Key&gt;AtIndex:, and -&lt;key&gt;AtIndexes:这几个方法，发送到-valueForKey:上。如果对象的类实现了一个可选的函数-get&lt;Key&gt;:range:那么也会被调用（提高性能）。 查找-countOf&lt;Key&gt; and -objectIn&lt;Key&gt;AtIndex: （匹配NSArray类），-&lt;key&gt;AtIndexes:（匹配-[NSArray objectsAtIndexes:]）。count方法和另外两个中的至少一个被发现，返回一个响应所有NSArray方法的集合协议对象。每一个NSArray消息都有该对象响应，并以-countOf&lt;Key&gt;, -objectIn&lt;Key&gt;AtIndex:, and -&lt;key&gt;AtIndexes:一些组合（组合规则如前面所说）的形式被发送到原始接受者的valueForKey上。如果这个接受者的类实现了-get&lt;Key&gt;:range: 那么会调用，可以有更好的性能。 继续没有找到的话，就开始匹配-countOf&lt;Key&gt;, -enumeratorOf&lt;Key&gt;, and -memberOf&lt;Key&gt;这三个方法，如果这个三个方法都找到的话，就返回一个响应所有NSSet方法的集合协议对象。每一个NSSet消息都会发送给集合协议对象，然后该对象就会以-countOf&lt;Key&gt;, -enumeratorOf&lt;Key&gt;, and -memberOf&lt;Key&gt;三者组合的形式响应。 还没有找到的话，就检查+accessInstanceVariablesDirectly属性，如果返回YES，就按_&lt;key&gt;, _is&lt;Key&gt;, &lt;key&gt;, or is&lt;Key&gt;查找，找到了就直接返回，一些属性会以NSNumber或NSValue 的形式返回如前面所说。 上面条件都不满足，就调用-valueForUndefinedKey:我们可以重写这个方法。默认实现是抛一个NSUndefinedKeyException异常 setValue:setValue概括起来比较简单，分为下面三步 查找-set&lt;Key&gt;:方法，如果参数类型不是一个指针类型，但是接受了一个nil值，那么就会走到-setNilValueForKey: 这个方法，默认抛NSInvalidArgumentException异常，可以重写它。数值类型也会被转为相应的对象类型（NSNumber，NSValue） 没有找到的话，就会检查+accessInstanceVariablesDirectly，返回YES，就开始查找_&lt;key&gt;, _is&lt;Key&gt;, &lt;key&gt;, or is&lt;Key&gt;。如果这个变量是一个对象类型，setValue的的时候，新值会被持有，旧值会被释放。 返回NO，就触发-setValue:forUndefinedKey:方法，逻辑和上面一致 KeyPath如果类的成员变量是另一个类或其它的复杂数据类型，就可以使用KeyPath。有一个address类 12345@interface Address : NSObject@property (nonatomic, copy) NSString *country;@end 另一个people类 1234567@interface People : NSObject@property (nonatomic, copy) NSString *name;@property (nonatomic, strong) KVCAddress *address;@property (nonatomic, assign) NSInteger age;@end 我们可以用KeyPath来设置people实例的address中的country属性 1234567Address *address = [Address new];address.country = @“中国”;People *people = [People new];people.address = address;NSLog(@“%@|%@“, people.address.country, [people valueForKeyPath:@“address.country”]);[people setValue:@“日本” forKeyPath:@“address.country”];NSLog(@“%@|%@“, people.address.country, [people valueForKeyPath:@“address.country”]); 打印结果 122020-03-23 12:03:48.686338+0800 AwesomeOC[10376:165500] 中国|中国2020-03-23 12:03:48.687086+0800 AwesomeOC[10376:165500] 日本|日本 KVC与容器类mutableArrayValueForKey: 搜索-insertObject:in&lt;Key&gt;AtIndex: and -removeObjectFrom&lt;Key&gt;AtIndex: -insert&lt;Key&gt;:atIndexes: and -remove&lt;Key&gt;AtIndexes:如果至少找到一个insert方法和一个remove方法，返回一个可以响应NSMutableArray所有方法代理集合，给这个代理结合发送NSMutableArray的方法，以-insertObject:in&lt;Key&gt;AtIndex:, -removeObjectFrom&lt;Key&gt;AtIndex:, -insert&lt;Key&gt;:atIndexes:, and -remove&lt;Key&gt;AtIndexes:组合的形式调用。 搜索-set&lt;Key&gt;: 如果找到了，每一个发送给代理集合的NSMutableArray方法都会调用-set&lt;Key&gt;: 没找到就检查+accessInstanceVariablesDirectly属性，返回YES，就搜索_&lt;key&gt; or &lt;key&gt;，找打了，那么发送给NSMutableArray的方法就直接给这个成员变量处理。 还是找不到，就forUndefinedKey了。 另外还有mutableOrderedSetValueForKey，mutableSetValueForKey 关于有序容器和无序容器的方法，这里就不写了，直接在NSKeyValueCoding.h查看即可，思路都是一致的。它们也有对应的KeyPath版本。 KVC与字典字典使用KVC，valueForKey:内部就是返回objectForKey: 那么使用KeyPath来访问多层嵌套字典，这是一个比较方便的操作。 dictionaryWithValuesForKeys提供一组key，返回这组key对应的属性，再组成一个字典 setValuesForKeysWithDictionary修改model中对应的key的属性 KVC验证用来验证key对应的value是否可用- (BOOL)validateValue:(inout id _Nullable * _Nonnull)ioValue forKey:(NSString *)inKey error:(out NSError **)outError;默认返回YES，如果重写了，就调用这个方法返回。 1234567891011121314151617181920-(BOOL)validateValue:(inout id _Nullable __autoreleasing *)ioValue forKey:(NSString *)inKey error:(out NSError *__autoreleasing _Nullable *)outError { NSString *country = *ioValue; country = country.capitalizedString; if ([country isEqualToString:@“Japan”]) { return NO; } return YES;}Address *address = [Address new];NSError *error;id value = @“japan”;NSString *key = @“country”;BOOL result = [address validateValue:&amp;value forKey:key error:&amp;error];if (result) { NSLog(@“键值匹配”); [address setValue:value forKey:key];} else { NSLog(@“键值不匹配”);} 如果我在设定某个值前需要验证一下，那么就可以重写这个方法，但是要注意，KVC在setValue时并不会主动调用这个验证函数，这里需要我们手动调用才行。 手动实现KVC123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172- (void)setMyValue:(id)value forKey:(NSString *)key { if (key == nil || key.length == 0) { NSLog(@“Key不能为空”); return; } if ([value isKindOfClass:[NSNull class]]) { NSLog(@“value不能为空”); [self setNilValueForKey:key]; return; } if (![value isKindOfClass:[NSObject class]]) { @throw @“must be a NSObject type”; return; } NSString *funcName = [NSString stringWithFormat:@“set%@“, key.capitalizedString]; if ([self respondsToSelector:NSSelectorFromString(funcName)]) { [self performSelector:NSSelectorFromString(funcName) withObject:value]; return; } unsigned int count; BOOL flag = false; Ivar *vars = class_copyIvarList([self class], &amp;count); for (int i = 0; i &lt; count; i++) { Ivar var = vars[i]; NSString *keyName = [NSString stringWithCString:ivar_getName(var) encoding:NSUTF8StringEncoding]; NSLog(@“keyName: %@“, keyName); keyName = [keyName substringFromIndex:1]; if ([keyName isEqualToString:[NSString stringWithFormat:@“_%@“, key]]) { flag = true; object_setIvar(self, var, value); break; } if ([keyName isEqualToString:key]) { flag = true; object_setIvar(self, var, value); } } if (!flag) { [self setValue:value forUndefinedKey:key]; }}- (id)myValueForKey:(NSString *)key { if (key == nil || key.length == 0) { return nil; } NSString *funcName = [NSString stringWithFormat:@“get%@:”, key.capitalizedString]; if ([self respondsToSelector:NSSelectorFromString(funcName)]) { return [self performSelector:NSSelectorFromString(funcName)]; } unsigned int count; BOOL flag = false; Ivar *vars = class_copyIvarList([self class], &amp;count); for (int i = 0; i &lt; count; i++) { Ivar var = vars[i]; NSString *keyName = [NSString stringWithFormat:@“_%@“, key]; NSString *varName = [[NSString stringWithCString:ivar_getName(var) encoding:NSUTF8StringEncoding] substringFromIndex:1]; if ([varName isEqualToString:keyName]) { flag = true; return object_getIvar(self, var); } if ([varName isEqualToString:key]) { flag = true; return object_getIvar(self, var); } } if (!flag) { [self valueForUndefinedKey:key]; } return nil;} KVC的使用动态地取值、设值访问和修改私有变量。之前项目里面，需要给一个textView添加placeholder，有一种做法就是通过获取私有变量来实现的。但是在后来的iOS版本中，这种做法会报错，猜测是苹果在新的版本中移除了这个私有变量。 Model和字典转换这个相信是最常见的，在获取网络数据转换model的时候经常用到 操作集合这种方式会达到一种高阶函数的效果 12345NSArray *langArr = @[@“english”, @“franch”, @“chinese”];NSArray *capLangArr = [langArr valueForKey:@“capitalizedString”];NSLog(@“%@“, capLangArr);NSArray *langLenArr = [langArr valueForKeyPath:@“capitalizedString.length”];NSLog(@“%@“, langLenArr); 输出 123456789102020-03-23 16:12:43.690950+0800 AwesomeOC[18336:330583] ( English, Franch, Chinese)2020-03-23 16:12:43.691636+0800 AwesomeOC[18336:330583] ( 7, 6, 7) 函数操作集合简单集合运算符: @avg, @count, @max, @min, @sum123456789101112131415161718192021222324Book *book1 = [Book new];book1.name = @“The Grate Gastby”;book1.price = 22;Book *book2 = [Book new];book2.name = @“Time History”;book2.price = 12;Book *book3 = [Book new];book3.name = @“Wrong Hole”;book3.price = 111;Book *book4 = [Book new];book4.name = @“Wrong Hole”;book4.price = 111;NSArray *books = @[book1, book2, book3, book4];NSNumber *sum = [books valueForKeyPath:@“@sum.price”];NSLog(@“sum: %f”, sum.doubleValue);NSNumber *avg = [books valueForKeyPath:@“@avg.price”];NSLog(@“avg: %f”, avg.doubleValue);NSNumber *count = [books valueForKeyPath:@“@count”];NSLog(@“count: %ld”, count.integerValue);NSNumber *min = [books valueForKeyPath:@“@min.price”];NSLog(@“min: %f”, min.doubleValue);NSNumber *max = [books valueForKeyPath:@“@max.price”];NSLog(@“max: %f”, max.doubleValue); 输出 123452020-03-23 16:21:35.262880+0800 AwesomeOC[18701:337719] sum: 256.0000002020-03-23 16:21:35.263241+0800 AwesomeOC[18701:337719] avg: 64.0000002020-03-23 16:21:35.263456+0800 AwesomeOC[18701:337719] count: 42020-03-23 16:21:35.263639+0800 AwesomeOC[18701:337719] min: 12.0000002020-03-23 16:21:35.263791+0800 AwesomeOC[18701:337719] max: 111.000000 对象运算符: @distinctUnionOfObjects，@unionOfObjects前者返回去重以后的结果，后者返回全部 总结关于KVC的了解，其实主要是看官方文档就行，其次就是一些用法，以前对于KVC就仅仅局限在model转换这里，要么就是获取私有变量这些，这次学习下来还是很有收获的。","link":"/2020/03/23/2020-03-23-01/"},{"title":"简单认识散列表","text":"也叫做“哈希表”或者“Hash表”。来源于数组，依赖于下标随机访问数据的特性。 散列思想存在一些元素，它们的编号为1，2，3，4，。。。，99，我们把这些元素按编号放在数组下标为1，2，3，。。。，99的位置上，当我们想要知道编号40的元素的信息的时候，我们可以直接array[40]，就可以在O(1)的时间复杂度上找到这个元素。现在我们把情况变复杂一些，这些元素的编号不是1，2，3这些，或者说根本没有编号，我们依然可以设计一种关系映射，根据每一个元素的特征属性，计算出元素的特征值，然后按照这个值把元素一个一个放到对应的数组下标中去。这就是散列思想。我们把这个元素的特征属性叫做key或者关键字。用它来标识这个元素。把元素 -&gt; 数组下标 这个计算的方法叫做散列函数（或“Hash函数”“哈希函数”），计算得到的值叫做散列值（或“Hash值”“哈希值”） 散列函数关于散列函数的设计，有三点基本的要求： 散列函数计算得到的散列值是一个非负整数； 如果 k1 = k2，那 hash(k1) = hash(k2)； 如果 k1 != k2，那 hash(k1) != hash(k2)； 因为数组下标是从0开始的，所以散列函数生成的散列值也要是非负整数。第二点也很好理解。第三点其实要真实现起来，难度是很大的，著名的MD5、SHA、CRC等哈希算法，也无法完全避免。 散列冲突两个key值不相等，但是有可能他们的hash值是相等的，很多hash算法都无法避免，所以就会出现散列冲突。常见的解决散列冲突的方法有两类，开放寻址发和链表法 开放寻址法如果出现了散列冲突，那么我们就重新探测一个空闲位置。先来说一下简单的探测方法：线性探测（Linear Probing） 元素x在插入散列表之前，散列表中已经有元素了，此时经过hash就算，得到x应该放在下标为7的位置，但是7此时已经存放了元素，那么就要往后偏移来找到空闲位置。找到末位之后，又从头开始找。知道下标为2的位置没有数据然后插入进去。所以散列表的查找也是根据这个，如果该位置有元素，说明就是我们想要的元素，如果遍历到数组的空闲位置还没有找到，则说明要查找的元素不在散列表中。 删除操作不是真删根据上面说的，散列表查找元素如果遍历到空闲位置还没有找到该元素的话，说明该散列表不存在该元素。如果散列表中某个相邻位置有 a, b（b的hash值对应的位置有其它元素了，现在b所在位置是偏移后找到的），我们把a删除，此时查找b元素，由于b的hash值有其它元素了，我们开始往后遍历，当我们遍历到a的时候，由于已经被真的删除了，此时位置为空，那么就会给我们一个错误的信息：b不在散列表中。所以对于散列表，删除元素不能真删，是打上一个特殊标记：deleted，当探测的时候，遇到deleted的空间会继续往下探测。 线性探测的问题线性探测需要遍历，直到找到空的位置。所以当散列表中的元素很多的时候，hash冲突就会越来越多，探测操作也变得更加频繁，极端情况下，需要遍历整个散列表，才能找到空位，此时的时间复杂度就是O(n)了。 另外两种经典的探测方法 二次探测线性探测的步长为1，那么二次探测的步长就是原来的二次方。 双重散列所谓双重散列，就是不仅要使用一个散列函数。使用一组散列函数 hash1(key), hash2(key), hash3(key)… 先用第一个，如果计算得到的位置已经被占用，再用第二个，以此类推，知道找到空闲位置为止。 不管采用哪种探测方法，当元素增加，空闲位置不多时，散列冲突的概率会大大提高。 链表法相比开放寻址法，链表法要简单很多。每个“桶(bucket)”都会对应一条链表，所有散列值相同的元素都放到相同bucket对应的链表中。 当插入的时候，只需要通过散列函数计算出对应的散列位置，插入到对应的链表中即可，所以插入的时间复杂度为O(1)。当查找、删除一个元素时，通过散列函数计算找到对应的位置，遍历链表查找或者删除。而查找、删除的时间复杂度是跟链表成正比的。当链表长度为k，时间复杂度即为O(k)。理论上讲，k=n/m，n表示散列表中数据的个数，m表示散列表的容量。","link":"/2020/03/23/2020-03-23-02/"},{"title":"事件穿透","text":"在事件响应和传递这篇文章中，讲了iOS中的事件响应和传递，今天在做项目的时候，正好碰到了一个应用的场景，因此记录下来。 需求首页头部需要添加这样一个视图点击左右两个按钮，底部的滑块跟着滑动，同时也可以拖动滑块到选中的按钮位置。 思路和问题看到这个设计图一开始的想法就是，左右两个按钮，底部一个滑块视图，然后到做的时候，发现如果要做手势拖拽的话，那么由于层级关系，滑块肯定是在两个按钮下面的，如果要触发滑动手势，势必会被按钮的点击事件阻止。 通过重写hitTest方法解决首先判断点击点是位于左侧按钮区域还是右侧按钮区域，在根据按钮的选中状态来判断。初始状态时左侧按钮选中，右侧没选中，同时滑块位于左侧。如果触摸点在右侧按钮区域，此时应该走的流程是响应右侧按钮事件。如果触摸点在左侧区域，此时左侧区域是选中状态，应该响应的是滑块的拖动事件。依照这个思路，就有了下面的这段代码 12345678910111213141516171819202122override func hitTest(_ point: CGPoint, with event: UIEvent?) -&gt; UIView? { let superHitPoint = self.convert(point, to: self.superview) if superHitPoint.x &lt;= self.frame.width { if self.frame.minX &gt; 0 { // 点击左侧按钮，但是现在响应的是右侧按钮，原样传递上去 return super.hitTest(point, with: event) } if self.isSelected { return strikeView } else { return super.hitTest(point, with: event) } } else { if self.frame.minX == 0 { // 同理 return super.hitTest(point, with: event) } if self.isSelected { return strikeView } else { return super.hitTest(point, with: event) } }} 这里要注意的一点是，由于事件响应链是系统会从后往前遍历子视图，我们点击任何一个区域，两个按钮都会响应hitTest方法，在判断触摸点的区域之后，还要判断一下当期响应的按钮是不是我们期望的按钮，如果不是，则不作任何改动。","link":"/2020/03/11/2020-03-11-01/"},{"title":"NSTimer处理内存泄露","text":"一般在一个viewController使用NSTimer 1234567- (void)viewDidLoad { [super viewDidLoad]; self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(doTask) userInfo:nil repeats:true];}- (void)doTask { NSLog(@\"to do something\");} 但是这样会有一个问题，我们退出这个页面的时候，发现定时器还是在运行。 这是因为NSTimer和viewController之间形成了循环引用。 那么如果打破这种循环引用呢？ 两种方法： 手动打破，在viewWillDisappear或者viewDidDisappear中设置为nil。 123456- (void)viewWillDisappear:(BOOL)animated { [super viewDidDisappear:animated]; [self.timer invalidate]; self.timer = nil;} 在NSTimer和viewController之间建立一个中间类来接管target。这里要用到NSProxy，NSProxy是一个抽象的超类，用来充当其它对象或者一些不存在的对象的替身。通常，发送给Proxy的消息会被转发给实际对象，或使Proxy加载（转换为）实际对象。使用的时候需要继承NSProxy，并且重写下面的2个方法： (NSMethodSignature *)methodSignatureForSelector:(SEL)sel (void)forwardInvocation:(NSInvocation *)invocation 1234567891011121314+ (instancetype)proxyWithTarget:(id)target { // NSProxy对象不需要调用init，因为它本来就没有init方法 MyProxy *proxy = [MyProxy alloc]; proxy.target = target; return proxy;}- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel { return [self.target methodSignatureForSelector:sel];}- (void)forwardInvocation:(NSInvocation *)invocation { [invocation invokeWithTarget:self.target];} 在使用的时候 1self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:[MyProxy proxyWithTarget:self] selector:@selector(doTask) userInfo:nil repeats:YES];","link":"/2020/04/02/2020-04-02-02/"},{"title":"了解Category","text":"简单了解OC2.0之后添加的语言特性，主要为已经存在的类添加方法。Apple推荐的两个使用场景： 把类的实现分开在不同的文件里面。 可以减少单个文件的体积 可以把不同的功能组织到不同的Category里 可以由多个开发者共同开发一个类 可以按需加载想要的Category 声明私有方法 衍生的使用场景： 模拟多继承 把framework的私有方法公开 和extension区别 extension在编译器决定，它就是类的一部分，在编译期和头文件里的@interface和实现文件里的@implementation一起形成一个完整的类。它伴随类的产生而产生，也随类一起消亡。 extension一般用来隐藏类的私有信息，你必须有一个类的源码才能为一个类添加extension，我们无法为系统类比如NSString添加extension。 category是在运行期决定的。 category无法添加实例变量，而extension可以。因为在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局。 内部探究分类结构所有的OC类和对象，在runtime层都是用struct来表示的，category也不例外，才runtime层，category用结构体category_t（objc-runtime-new.h中）表示。 1234567891011121314151617struct category_t { const char *name; classref_t cls; struct method_list_t *instanceMethods; struct method_list_t *classMethods; struct protocol_list_t *protocols; struct property_list_t *instanceProperties; // Fields below this point are not always present on disk. struct property_list_t *_classProperties; method_list_t *methodsForMeta(bool isMeta) { if (isMeta) return classMethods; else return instanceMethods; } property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);}; 类名（name） 类（cls） category中所有给类添加的实例方法的列表（instanceMethods） category中所有添加的类方法的列表（classMethods） category中实现的所有协议的列表（protocols） category中添加的所有属性（instanceProperties） category中添加的所有类属性（classProperties），这里说明了不是在所有的版本中都有。因为类属性这个概念也是后来才加上去的。 获取方法列表函数，根据传入的参数是否是元类，来决定返回类方法还是实例方法。 获取属性列表函数，第二个参数还没弄明白是干什么的。 从定义上可以看出，category可以为类添加实例方法、类方法、实现协议、添加属性、添加类属性，但是无法添加实例变量。 用clang转换一下代码我们先写一个分类 12345678910111213141516171819202122232425262728293031// .h@interface MyClass : NSObject- (void)printName;@end@interface MyClass (MyAddition)@property (nonatomic, copy) NSString *name;- (void)printName;@end// .m@implementation MyClass- (void)printName { NSLog(@\"%@\", @\"MyClass\");}@end@implementation MyClass (MyAddition)- (void)printName { NSLog(@\"%@\", @\"MyAddition\");}@end 然后用clang指令：clang -rewrite-objc MyClass.m 生成.cpp文件，打开翻到最后面的Category部分 1234567891011121314151617181920212223242526272829303132333435363738394041424344static struct /*_method_list_t*/ { unsigned int entsize; // sizeof(struct _objc_method) unsigned int method_count; struct _objc_method method_list[1];} _OBJC_$_CATEGORY_INSTANCE_METHODS_MyClass_$_MyAddition __attribute__ ((used, section (“__DATA,__objc_const”))) = { sizeof(_objc_method), 1, {{(struct objc_selector *)”printName”, “v16@0:8”, (void *)_I_MyClass_MyAddition_printName}}};static struct /*_prop_list_t*/ { unsigned int entsize; // sizeof(struct _prop_t) unsigned int count_of_properties; struct _prop_t prop_list[1];} _OBJC_$_PROP_LIST_MyClass_$_MyAddition __attribute__ ((used, section (\"__DATA,__objc_const\"))) = { sizeof(_prop_t), 1, {{\"name\",\"T@\\\"NSString\\\",C,N\"}}};extern \"C\" __declspec(dllexport) struct _class_t OBJC_CLASS_$_MyClass;static struct _category_t _OBJC_$_CATEGORY_MyClass_$_MyAddition __attribute__ ((used, section (\"__DATA,__objc_const\"))) = { \"MyClass\", 0, // &amp;OBJC_CLASS_$_MyClass, (const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_MyClass_$_MyAddition, 0, 0, (const struct _prop_list_t *)&amp;_OBJC_$_PROP_LIST_MyClass_$_MyAddition,};static void OBJC_CATEGORY_SETUP_$_MyClass_$_MyAddition(void ) { _OBJC_$_CATEGORY_MyClass_$_MyAddition.cls = &amp;OBJC_CLASS_$_MyClass;}#pragma section(“.objc_inithooks$B”, long, read, write)__declspec(allocate(“.objc_inithooks$B”)) static void *OBJC_CATEGORY_SETUP[] = { (void *)&amp;OBJC_CATEGORY_SETUP_$_MyClass_$_MyAddition,};static struct _class_t *L_OBJC_LABEL_CLASS_$ [1] __attribute__((used, section (\"__DATA, __objc_classlist,regular,no_dead_strip\")))= { &amp;OBJC_CLASS_$_MyClass,};static struct _category_t *L_OBJC_LABEL_CATEGORY_$ [1] __attribute__((used, section (\"__DATA, __objc_catlist,regular,no_dead_strip\")))= { &amp;_OBJC_$_CATEGORY_MyClass_$_MyAddition,}; 首先编译器生成了实例方法列表_OBJC_$_CATEGORY_INSTANCE_METHODS_MyClass_$_MyAddition和属性列表_OBJC_$_PROP_LIST_MyClass_$_MyAddition都遵循了公共前缀+类名+Category名字的命名方式，所以这里的Category名是不能重复的，否则就会出现编译错误。我们可以在里面看到printName方法和name属性。 然后生成了_OBJC_$_CATEGORY_MyClass_$_MyAddition，它的类型是_category_t也就是Category本身。用了： 类名（”MyClass”） 类（0） 实例方法（(const struct method_list_t *)&amp;_OBJC$CATEGORY_INSTANCE_METHODS_MyClass$_MyAddition） 类方法（0） 实现协议（0） 属性（(const struct prop_list_t *)&amp;_OBJC$PROP_LIST_MyClass$_MyAddition）这6个参数来初始化分类。 最后，编译器在DATA段下的_objc_catlist section里保存了一个大小为1的category_t的数组L_OBJC_LABEL_CATEGORY$（如果有多个Category，会生成对应长度的数组），用于运行期Category的加载。 运行期加载我们知道，OC的运行是依赖OC的runtime，而OC的runtime和其它系统库一样，是OS X和iOS通过dyld动态加载的。看一下OC运行时的入口方法： 12345678910111213141516171819202122/************************************************************************ _objc_init* Bootstrap initialization. Registers our image notifier with dyld.* Called by libSystem BEFORE library initialization time引导程序初始化。用dyld注册我们的图像通知。在库初始化之前由libSystem调用**********************************************************************/void _objc_init(void){ static bool initialized = false; if (initialized) return; initialized = true; // fixme defer initialization until an objc-using image is found? environ_init(); tls_init(); static_init(); lock_init(); exception_init(); _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);} category被附加到类上是在map_images的时候发生的 1234567891011121314/************************************************************************ map_images* Process the given images which are being mapped in by dyld.* Calls ABI-agnostic code after taking ABI-specific locks.** Locking: write-locks runtimeLock**********************************************************************/voidmap_images(unsigned count, const char * const paths[], const struct mach_header * const mhdrs[]){ mutex_locker_t lock(runtimeLock); return map_images_nolock(count, paths, mhdrs);} map_images_nolock函数是定义在objc-os.mm文件中，在最后调用了_read_images函数，我们去objc-runtime-new.mm文件中可以看到_read_images函数。这个函数很长，找到关于Category的部分。 123456789101112131415161718/************************************************************************ _read_images* Perform initial processing of the headers in the linked * list beginning with headerList. ** Called by: map_images_nolock** Locking: runtimeLock acquired by map_images**********************************************************************/void _read_images(header_info **hList, uint32_t hCount, int totalClasses, int unoptimizedTotalClasses) { // … for (EACH_HEADER) { category_t **catlist = _getObjc2CategoryList(hi, &amp;count); bool hasClassProperties = hi-&gt;info()-&gt;hasCategoryClassProperties(); // 往下 } // …} 先忽略掉所有的print打印相关的代码。然后慢慢来看，首先会拿到所有的category_t数组，具体怎么获取的这里先不管。然后遍历category_t数组。 1234567891011for (i = 0; i &lt; count; i++) { category_t *cat = catlist[i]; Class cls = remapClass(cat-&gt;cls); if (!cls) { // Category's target class is missing (probably weak-linked). // Disavow any knowledge of this category. catlist[i] = nil; continue; } // 往下 这里首先会拿到分类的class，如果为空就continue。因为Category的目标类可能是弱引用的关系而丢失了。往下看 123456789101112// Process this category. // First, register the category with its target class. // Then, rebuild the class's method lists (etc) if // the class is realized. bool classExists = NO;if (cat-&gt;instanceMethods || cat-&gt;protocols || cat-&gt;instanceProperties) { addUnattachedCategoryForClass(cat, cls, hi); if (cls-&gt;isRealized()) { remethodizeClass(cls); classExists = YES; }} 首先把这个category注册到目标类上，然后如果实现了类就重建它的方法列表。这里我们要跳过去看一下addUnattachedCategoryForClass这个函数。不是很长。 123456789101112131415161718192021222324/************************************************************************ addUnattachedCategoryForClass* Records an unattached category. 记录一个未附加的category* Locking: runtimeLock must be held by the caller.**********************************************************************/static void addUnattachedCategoryForClass(category_t *cat, Class cls, header_info *catHeader){ runtimeLock.assertLocked(); // DO NOT use cat-&gt;cls! cls may be cat-&gt;cls-&gt;isa instead NXMapTable *cats = unattachedCategories(); category_list *list; list = (category_list *)NXMapGet(cats, cls); if (!list) { list = (category_list *) calloc(sizeof(*list) + sizeof(list-&gt;list[0]), 1); } else { list = (category_list *) realloc(list, sizeof(*list) + sizeof(list-&gt;list[0]) * (list-&gt;count + 1)); } list-&gt;list[list-&gt;count++] = (locstamped_category_t){cat, catHeader}; NXMapInsert(cats, cls, list);} 先获取未附加的category，创建数组，分配内存空间，NXMapInsert这里的作用是，把类和category、list做一个关联映射。所以真正的添加还不是在这里，我们在回到外层函数去。如果cls-&gt;isRealized()也就是说这个类被实现了，那么就执行remethodizeClass(cls)重新排列类。找到类的实现如下： 12345678910111213141516171819202122232425/************************************************************************ remethodizeClass* Attach outstanding categories to an existing class.将未完成的category附加到现有类。* Fixes up cls's method list, protocol list, and property list.修复类的方法列表、协议列表、属性列表。* Updates method caches for cls and its subclasses.更新类和子类的方法缓存。* Locking: runtimeLock must be held by the caller**********************************************************************/static void remethodizeClass(Class cls){ category_list *cats; bool isMeta; runtimeLock.assertLocked(); isMeta = cls-&gt;isMetaClass(); // Re-methodizing: check for more categories if ((cats = unattachedCategoriesForClass(cls, false/*not realizing*/))) { attachCategories(cls, cats, true /*flush caches*/); free(cats); }} 先插播一个unattachedCategoriesForClass函数 1234567891011121314/************************************************************************ unattachedCategoriesForClass* Returns the list of unattached categories for a class, and * deletes them from the list. * The result must be freed by the caller. 返回类的未附加类别列表，并从列表中删除它们。调用者必须释放结果。* Locking: runtimeLock must be held by the caller.**********************************************************************/static category_list *unattachedCategoriesForClass(Class cls, bool realizing){ runtimeLock.assertLocked(); return (category_list *)NXMapRemove(unattachedCategories(), cls);} 就是从map表中获取列表，然后再移除。 好，接下来我们看关键函数：attachCategories(cls, cats, true /*flush caches*/); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// Attach method lists and properties and protocols from categories to a class.// Assumes the categories in cats are all loaded and sorted by load order, // oldest categories first.// 将类别中的方法列表、属性和协议附加到类中。假设cats中的类别都是按加载顺序加载和排序的，最早的类别是第一个。static void attachCategories(Class cls, category_list *cats, bool flush_caches){ if (!cats) return; if (PrintReplacedMethods) printReplacements(cls, cats); bool isMeta = cls-&gt;isMetaClass(); // fixme rearrange to remove these intermediate allocations method_list_t **mlists = (method_list_t **) malloc(cats-&gt;count * sizeof(*mlists)); property_list_t **proplists = (property_list_t **) malloc(cats-&gt;count * sizeof(*proplists)); protocol_list_t **protolists = (protocol_list_t **) malloc(cats-&gt;count * sizeof(*protolists)); // Count backwards through cats to get newest categories first int mcount = 0; int propcount = 0; int protocount = 0; int i = cats-&gt;count; bool fromBundle = NO; while (i--) { auto&amp; entry = cats-&gt;list[i]; method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta); if (mlist) { mlists[mcount++] = mlist; fromBundle |= entry.hi-&gt;isBundle(); } property_list_t *proplist = entry.cat-&gt;propertiesForMeta(isMeta, entry.hi); if (proplist) { proplists[propcount++] = proplist; } protocol_list_t *protolist = entry.cat-&gt;protocols; if (protolist) { protolists[protocount++] = protolist; } } auto rw = cls-&gt;data(); prepareMethodLists(cls, mlists, mcount, NO, fromBundle); rw-&gt;methods.attachLists(mlists, mcount); free(mlists); if (flush_caches &amp;&amp; mcount &gt; 0) flushCaches(cls); rw-&gt;properties.attachLists(proplists, propcount); free(proplists); rw-&gt;protocols.attachLists(protolists, protocount); free(protolists);} 也就是说，按加载顺序，最先添加的category会先被添加。首先分别创建三个大列表：mlists, proplists, protolists。从后往前遍历，获取每一个category的方法列表，属性列表和协议列表，放到对应列表中。遍历完成后，开始最后的附加列表操作。 123456789101112131415161718192021222324252627282930void attachLists(List* const * addedLists, uint32_t addedCount) { if (addedCount == 0) return; if (hasArray()) { // many lists -&gt; many lists uint32_t oldCount = array()-&gt;count; uint32_t newCount = oldCount + addedCount; setArray((array_t *)realloc(array(), array_t::byteSize(newCount))); array()-&gt;count = newCount; memmove(array()-&gt;lists + addedCount, array()-&gt;lists, oldCount * sizeof(array()-&gt;lists[0])); memcpy(array()-&gt;lists, addedLists, addedCount * sizeof(array()-&gt;lists[0])); } else if (!list &amp;&amp; addedCount == 1) { // 0 lists -&gt; 1 list list = addedLists[0]; } else { // 1 list -&gt; many lists List* oldList = list; uint32_t oldCount = oldList ? 1 : 0; uint32_t newCount = oldCount + addedCount; setArray((array_t *)malloc(array_t::byteSize(newCount))); array()-&gt;count = newCount; if (oldList) array()-&gt;lists[addedCount] = oldList; memcpy(array()-&gt;lists, addedLists, addedCount * sizeof(array()-&gt;lists[0])); }} 注意这里的memmove和memcpy操作，它是把原来的方法列表先放到后面，再把新的方法列表放在前面，所以： 其实category附加完成之后，如果category和原来类都有methodA，那么类的方法列表里面会有两个methodA； 运行时在查找方法列表时，会按顺序查找，就只会找到category的方法。这就是我们平常说的category的方法会“覆盖”原来类的方法。 到这里，关于category的运行时加载算是结束了。","link":"/2020/03/25/2020-03-25-01/"},{"title":"简单了解iOS中的锁","text":"为什么会有线程不安全呢？多个线程并发，就会出现同时访问一个资源的情况。 123456789101112131415161718192021- (void)ticketTest { self.ticketsCount = 50; dispatch_queue_t queue = dispatch_get_global_queue(0, 0); for (int i = 0; i &lt; 5; i++) { dispatch_async(queue, ^{ for (int i = 0; i &lt; 10; i++) { [self sellingTickets]; } }); }}- (void)sellingTickets { NSInteger oldMoney = self.ticketsCount; sleep(.2); oldMoney -= 1; self.ticketsCount = oldMoney; NSLog(@\"当前剩余票数-&gt; %ld\", oldMoney);} 一个经典的卖票demo。ticketsCount被多个线程同时访问，就有可能读取到的值是相同的，那么票就会显示少买。 12342020-04-01 23:35:19.022896+0800 AwesomeOC[7740:2183272] 当前剩余票数-&gt; 72020-04-01 23:35:19.023000+0800 AwesomeOC[7740:2183274] 当前剩余票数-&gt; 62020-04-01 23:35:19.023170+0800 AwesomeOC[7740:2183275] 当前剩余票数-&gt; 52020-04-01 23:35:19.023767+0800 AwesomeOC[7740:2183275] 当前剩余票数-&gt; 4 最后打印结果就和实际不同。 怎么解决呢？加锁！自旋锁如果自旋锁已经被别的执行单元保持，那么调用者就一直循环在那里看是否该自旋锁的保持着已经释放了锁，所以称为“自旋”。自旋锁会一直循环，所以不会引起调用者睡眠，且自旋锁的效率远高于互斥锁。但是有缺点：1.由于一直循环，所以会一直占用CPU，如果不能在短时间内获得锁，会使CPU效率降低，CPU消耗是线性增长的；2.容易造成死锁，比如递归调用，调用其他函数 互斥锁属于sleep-waiting类型的锁。例如在一个双核的机器上有线程A和线程B，分别运行在core0和core1上。假设A想通过pthread_mutex_lock操作去得到一个临界区的锁，而此时这个锁正被B所持有，那么A就会被阻塞(blocking)，Core0会在此时进行上下文切换(Context Switch)将线程A置于等待队列中，此时Core0就可以运行其他的任务不再等待。 所以和自旋锁一比，自旋锁属于“busy-waiting”类型的锁，如果线程A是使用pthread_spin_lock操作去请求锁，那么线程A就会一直在Core0上进行忙等并不停的进行锁请求，直到得到这个锁位置。 两种锁的加锁原理互斥锁：线程会从sleep（加锁）-&gt; running（解锁），过程会有上下文的切换，CPU的抢占，信号的发送等开销。自旋锁：线程一直是running（加锁 -&gt; 解锁），死循环检测锁的标志位。 两种锁的应用互斥锁用于临界区持锁时间比较长的操作 临界区有IO操作 临界区代码复杂或者循环量大 临界区竞争非常激烈 单核处理器 自旋锁一般用于CPU资源比较充足，临界区持锁时间非常短的情况下，自旋锁一般用于多核的服务器。 13种锁OSSpinLock这个已经被移除了，因为有一个关于优先级反转的bug。当一个低优先级的线程持有自旋锁执行操作的时候，此时一个高优先级的线程也需要获取锁，此时会进入忙等状态，但是高优先级的线程会优先分配更多的CPU资源，此时又因为处于忙等状态会一直消耗CPU，就会导致低优先级的线程没有CPU资源可供调用，操作就没发完成下去或者执行很慢。而高优先级的线程就会一直等待。这就是优先级反转的问题。所以从iOS10开始，就推荐使用os_unfair_lock。 1234567891011121314151617#import &lt;libkern/OSAtomic.h&gt;@interface OSSpinLockDemo ()@property (nonatomic, assign) OSSpinLock ticketLock;@end@implementation OSSpinLockDemo- (instancetype)init { self = [super init]; if (self) { _ticketLock = OS_SPINLOCK_INIT; } return self;}- (void)sellingTickets { OSSpinLockLock(&amp;_ticketLock); [super sellingTickets]; OSSpinLockUnlock(&amp;_ticketLock);} os_unfair_lock等待os_unfair_lock锁的线程会处于休眠状态，并非忙等。 1234567891011121314151617#import &lt;os/lock.h&gt;@interface OSUnfairLockDemo ()@property (nonatomic, assign) os_unfair_lock ticketLock;@end@implementation OSUnfairLockDemo- (instancetype)init { self = [super init]; if (self) { _ticketLock = OS_UNFAIR_LOCK_INIT; } return self;}- (void)sellingTickets { os_unfair_lock_lock(&amp;_ticketLock); [super sellingTickets]; os_unfair_lock_unlock(&amp;_ticketLock);} pthread_mutex互斥锁 123456789101112131415161718192021222324252627282930@interface PThreadLockDemo ()@property (nonatomic, assign) pthread_mutex_t ticketLock;@end@implementation PThreadLockDemo- (instancetype)init { self = [super init]; if (self) { // 初始化属性 pthread_mutexattr_t attr; pthread_mutexattr_init(&amp;attr); pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_DEFAULT); // 初始化锁 pthread_mutex_init(&amp;_ticketLock, &amp;attr); // 销毁属性 pthread_mutexattr_destroy(&amp;attr); } return self;}- (void)sellingTickets { pthread_mutex_lock(&amp;_ticketLock); [super sellingTickets]; [self sellingTickets2]; pthread_mutex_unlock(&amp;_ticketLock);}// 假设有一种死锁情况- (void)sellingTickets2 { pthread_mutex_lock(&amp;_ticketLock); NSLog(@\"%s\", __func__); pthread_mutex_unlock(&amp;_ticketLock);} 如果碰到死锁的情况，在sellingTickets2中，又执行加锁操作，抢占ticketLock锁，此时出现死锁。我们都知道是因为sellingTickets在持有锁的情况下，sellingTickets2又去抢占。那么把sellingTickets2抢占的锁换一个对象就可以解除了。这里还有一种办法，就是pthread_mutex_t里的属性可以解决：PTHREAD_MUTEX_RECURSIVE这个表示递归锁，允许同一个线程对同一把锁进行重复加锁。 假设：我们有一个数组，有两个线程，一个是添加数组，一个是删除数组，我们先调用删除数组，再调用添加数组，但是在数组为空的时候不调用删除数组。这时候要用到条件这个接口删除的线程需要等待添加的线程添加完数据之后，再执行删除操作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@interface PthreadMutexDemo1 ()@property (nonatomic, assign) pthread_mutex_t mutex;@property (nonatomic, assign) pthread_cond_t cond;@property (nonatomic, strong) NSMutableArray *data;@end@implementation PthreadMutexDemo1- (instancetype)init { self = [super init]; if (self) { pthread_mutexattr_t attr; pthread_mutexattr_init(&amp;attr); pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE); pthread_mutex_init(&amp;_mutex, &amp;attr); pthread_mutexattr_destroy(&amp;attr); pthread_cond_init(&amp;_cond, NULL); self.data = @[].mutableCopy; } return self;}- (void)otherTest { [[[NSThread alloc] initWithTarget:self selector:@selector(__remove) object:nil] start]; [[[NSThread alloc] initWithTarget:self selector:@selector(__add) object:nil] start];}- (void)__remove { pthread_mutex_lock(&amp;_mutex); NSLog(@\"__remove - begin\"); if (self.data.count == 0) { pthread_cond_wait(&amp;_cond, &amp;_mutex); } [self.data removeLastObject]; NSLog(@\"删除了元素\"); pthread_mutex_unlock(&amp;_mutex);}- (void)__add { pthread_mutex_lock(&amp;_mutex); sleep(1); [self.data addObject:@\"Test\"]; NSLog(@\"添加了元素\"); // 激活一个等待该条件的线程 激活所有等待该条件的线程: pthread_cond_broadcast(&amp;_cond); pthread_cond_signal(&amp;_cond); pthread_mutex_unlock(&amp;_mutex);}- (void)dealloc { pthread_mutex_destroy(&amp;_mutex); pthread_cond_destroy(&amp;_cond);} NSLock是对mutex普通锁的封装。pthread_mutex_init(mutex, NULL) 12345- (void)sellingTickets { [self.ticketLock lock]; [super sellingTickets]; [self.ticketLock unlock];} NSRecursiveLock是对mutex递归锁的封装，API跟NSLock基本一致 NSCondition是对mutex和cond的封装。上面操作数组的例子就变成下面这样 12345678910111213141516171819202122232425262728- (void)__remove {// pthread_mutex_lock(&amp;_mutex); [self.condition lock]; NSLog(@\"__remove - begin\"); if (self.data.count == 0) {// pthread_cond_wait(&amp;_cond, &amp;_mutex); [self.condition wait]; } [self.data removeLastObject]; NSLog(@\"删除了元素\");// pthread_mutex_unlock(&amp;_mutex); [self.condition unlock];}- (void)__add {// pthread_mutex_lock(&amp;_mutex); [self.condition lock]; sleep(1); [self.data addObject:@\"Test\"]; NSLog(@\"添加了元素\"); // 激活一个等待该条件的线程// pthread_cond_signal(&amp;_cond); [self.condition signal]; // pthread_mutex_unlock(&amp;_mutex); [self.condition unlock];} NSConditionLock对NSCondition的进一步封装，可以设置具体的值。 initWithCondition：初始化Condition，并且设置状态值 lockWhenCondition:(NSInteger)condition: 当状态值为condition的时候加锁 unlockWithCondition:(NSInteger)condition 当状态值为condition的时候解锁123456789101112131415- (void)otherTest { [[[NSThread alloc] initWithTarget:self selector:@selector(__one) object:nil] start]; [[[NSThread alloc] initWithTarget:self selector:@selector(__two) object:nil] start];}- (void)__one { [self.conditionLock lock]; NSLog(@“__one”); sleep(1); [self.conditionLock unlockWithCondition:2];}- (void)__two { [self.conditionLock lockWhenCondition:2]; NSLog(@“__two”); [self.conditionLock unlockWithCondition:3];} dispatch_semaphore信号量的初始值为1，代表同时只允许1条线程访问资源，保证线程同步。 1234567// 表示最多开启5个线程dispatch_semaphore_create(5);// 如果信号量的值 &gt;0，就让信号量的值减1，然后继续往下执行// 如果信号量的值 &lt;=0，就会休眠等待，知道信号量的值变成&gt;0，就让信号量的值减1，然后继续往下执行代码dispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER);// 让信号量的值+1dispatch_semaphore_signal(self.semaphore) 12345678910111213141516171819- (instancetype)init { self = [super init]; if (self) { self.semaphore = dispatch_semaphore_create(1); } return self;}- (void)otherTest { for (int i = 0; i &lt; 20; i++) { [[[NSThread alloc] initWithTarget:self selector:@selector(test) object:nil] start]; }}- (void)test { dispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER); sleep(2); NSLog(@“test - %@“, [NSThread currentThread]); dispatch_semaphore_signal(self.semaphore);} 虽然同时开启了20个线程，但是信号量设置为1，每次只执行一个线程。 dispatch_queue使用GCD串行队列实现线程同步 12345678910111213- (void)otherTest { dispatch_queue_t queue = dispatch_queue_create(“test”, DISPATCH_QUEUE_SERIAL); dispatch_sync(queue, ^{ for (int i = 0; i &lt; 2; i++) { NSLog(@\"1----%@\", [NSThread currentThread]); } }); dispatch_sync(queue, ^{ for (int i = 0; i &lt; 2; i++) { NSLog(@\"2----%@\", [NSThread currentThread]); } });} @synchronized是对mutex递归锁的封装，@synchronized(obj)内部会生成obj对应的递归锁，然后进行加锁、解锁操作 12345- (void)sellingTickets { @synchronized ([self class]) { [super sellingTickets]; }} 我们可以查看源码objc-sync.mm 123456789101112131415161718192021222324252627282930313233343536373839404142434445// Begin synchronizing on ‘obj'. // Allocates recursive mutex associated with ‘obj’ if needed.// Returns OBJC_SYNC_SUCCESS once lock is acquired. int objc_sync_enter(id obj){ int result = OBJC_SYNC_SUCCESS; if (obj) { SyncData* data = id2data(obj, ACQUIRE); assert(data); data-&gt;mutex.lock(); } else { // @synchronized(nil) does nothing if (DebugNilSync) { _objc_inform(“NIL SYNC DEBUG: @synchronized(nil); set a breakpoint on objc_sync_nil to debug”); } objc_sync_nil(); } return result;}// End synchronizing on 'obj'. // Returns OBJC_SYNC_SUCCESS or OBJC_SYNC_NOT_OWNING_THREAD_ERRORint objc_sync_exit(id obj){ int result = OBJC_SYNC_SUCCESS; if (obj) { SyncData* data = id2data(obj, RELEASE); if (!data) { result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR; } else { bool okay = data-&gt;mutex.tryUnlock(); if (!okay) { result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR; } } } else { // @synchronized(nil) does nothing } return result;} atomic用于保证属性setter、getter的原子性操作，就是在内部加了锁，可以在objc-accessors.mm中查看。注意它并不能保证使用属性的过程是线程安全的。 pthread_rwlock读写锁经常用于文件等数据的读写操作，需要导入头文件#import &lt;pthread.h&gt;iOS中的读写安全方案需要注意一下场景 同一时间，只能有一个线程进行写的操作 同一时间，允许有多个线程进行读的操作 同一时间，不允许既有写的操作，又有读的操作1234567891011121314151617181920pthread_rwlock_init(&amp;_lock, NULL);- (void)read { pthread_rwlock_rdlock(&amp;_lock); sleep(1); NSLog(@\"%s\", __func__); pthread_rwlock_unlock(&amp;_lock);}- (void)write { pthread_rwlock_wrlock(&amp;_lock); sleep(1); NSLog(@“%s”, __func__); pthread_rwlock_unlock(&amp;_lock);}- (void)dealloc { pthread_rwlock_destroy(&amp;_lock);} dispatch_barrier_async传入的并发队列必须是自己通过dispatch_queue_create创建的，如果传入的是一个串行或是一个全局并发队列，这个函数就等同于dispatch_async函数的效果 1234567dispatch_queue_t queue = dispatch_queue_create(“rw_queue”, DISPATCH_QUEUE_CONCURRENT);dispatch_async(queue, ^{ NSLog(@“读操作: %d”, i);});dispatch_barrier_async(queue, ^{ NSLog(@“写操作: %d”, i);}); 锁的性能比较 os_unfair_lock OSSpinLock dispatch_semaphore pthread_mutex dispatch_queue(DISPATCH_QUEUE_SERIAL) NSLock NSCondition pthread_mutex(recursive) NSRecursiveLock NSConditionLock @synchronized","link":"/2020/04/02/2020-04-02-01/"},{"title":"My First Post","text":"尝试用MarkDown语法写博客标题这是一级标题这是二级标题三级标题四级标题五级标题六级标题无序列表 文本1 文本2 文本3 有序列表 文本1 文本2 文本3 连接和图片 超链接 百度 图片 引用 一盏灯，一片黄昏；一简书，一杯淡茶。守着那一份淡定，品读属于自己的寂寞。 粗体和斜体斜体粗体 代码引用单行代码使用 1多行代码使用 表格 Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 dog bird cat foo foo foo bar bar bar baz baz baz","link":"/2019/08/20/My-First-Post/"},{"title":"Swift enum类型添加Codable默认值","text":"Swift开发中在数据转model这一层，我采用了苹果官方的Codable协议来实现。Codable的具体步骤可以参考网上一大堆教程。后台有时候会返回一些表示枚举的字符串数值，在转成model的过程中，会把这个字段设置成对应的Swift枚举。 123456789101112131415161718192021222324enum ToolType: String, Codable { /// 自行车 case Bike = \"1\" /// 电瓶车 case Electromobile = \"2\" /// 大踏板车 case Scooter = \"3\" /// 摩托车 case Motorbike = \"4\" /// 轿车 case Sedan = \"5\" /// 小货车 case Buggy = \"6\"}struct Model { var toolType: ToolType?}extension Model: Codable { enum CodingKeys: String, CodingKey { case toolType = \"tool_type\" }} 这样就可以很方便的实现数据转model。 但是如果后台返回的数据对应值不止 1~6 会怎么样呢？答案是解析会抛出异常直接报错。 当数据转model的时候，实际调用的是这个方法 1init(from decoder: Decoder) throws 如果出现value和enum的值都匹配不上的情况，并不会返回nil而是直接抛出异常。 所以我们要做的就是当解析出错的时候设置一个默认值 通过extension给Codable协议添加默认值123456789101112131415161718192021222324protocol CaseIterableDefaultsLast: Encodable &amp; Decodable &amp; CaseIterable &amp; RawRepresentable where RawValue: Decodable, AllCases: BidirectionalCollection {}extension CaseIterableDefaultsLast { init(from decoder: Decoder) throws { self = try Self(rawValue: decoder.singleValueContainer().decode(RawValue.self)) ?? Self.allCases.last! }}enum ToolType: String, CaseIterableDefaultsLast { /// 自行车 case Bike = \"1\" /// 电瓶车 case Electromobile = \"2\" /// 大踏板车 case Scooter = \"3\" /// 摩托车 case Motorbike = \"4\" /// 轿车 case Sedan = \"5\" /// 小货车 case Buggy = \"6\" /// 未知 case Unknown} 如果初始化失败返回nil，则默认取最后一个为默认值。","link":"/2020/07/06/Swift-enum类型添加Codable默认值/"},{"title":"UITextView实现点击富文本响应事件","text":"前因：开发中常常会遇到点击富文本链接跳转的情况，最常碰到的是在注册的时候会有同意各种协议的文本，点击会跳转显示对应协议。 通过UITextView添加带有超链接的富文本，就可以在delegate的 123456- (BOOL)textView:(UITextView *)textView shouldInteractWithURL:(NSURL *)URL inRange:(NSRange)characterRange interaction:(UITextItemInteraction)interaction { NSLog(@\"%@\", URL); return YES;} 监听到点击链接的事件。 这样就不用写两个button或者其他方式实现点击效果，方便快捷。 具体设置如下： 1234567891011121314151617NSMutableAttributedString *mAttr = [[NSMutableAttributedString alloc] initWithString:@\"点击“注册”即表示您同意\"];NSAttributedString *registPolicyAttr = [[NSAttributedString alloc] initWithString:@\"《用户注册服务协议》\" attributes:@{ NSForegroundColorAttributeName: [UIColor colorWithRed:78/255.0 green:187/255.0 blue:192/255.0 alpha:1.0], NSLinkAttributeName: @\"www.baidu.com\"}];NSAttributedString *privacyPolicyAttr = [[NSAttributedString alloc] initWithString:@\"&amp;《用户隐私协议》\" attributes:@{ NSForegroundColorAttributeName: [UIColor colorWithRed:78/255.0 green:187/255.0 blue:192/255.0 alpha:1.0], NSLinkAttributeName: @\"www.google.com\"}];[mAttr appendAttributedString:registPolicyAttr];[mAttr appendAttributedString:privacyPolicyAttr];textView.attributedText = mAttr.copy;textView.delegate = self;textView.scrollEnabled = NO;textView.editable = NO; 但是还有一些细节的地方需要调整一下。 UITextView的超链接一直是蓝色这是因为UITextView自带了样式，我们只需要在设置textView.attributedText之前，把样式清空就行。 1textView.linkTextAttributes = @{}; 点击超链接的时候，会有底色为灰色的高亮显示这种系统默认的实现，好像没有找到可以修改的地方（如果有希望大家在评论区告诉我）。只能用别的办法解决，幸好UITextView给我们提供了一个方法，可以根据点击的点获取最近区域的富文本状态，通过判断获取到的富文本是否包含超链接，来响应超链接事件。 123456789- (void)handleTap:(UITapGestureRecognizer *)tap { UITextView *textView = (UITextView *)tap.view; CGPoint tapLocation = [tap locationInView:textView]; UITextPosition *position = [textView closestPositionToPoint:tapLocation]; NSDictionary *attr = [textView textStylingAtPosition:position inDirection:UITextStorageDirectionForward]; if ([attr.allKeys containsObject:NSLinkAttributeName]) { NSLog(@\"%@\", attr[NSLinkAttributeName]); }} 禁用文本选择和复制粘贴为了让实现效果看起来更像点击了两个按钮，要取消掉UITextView的文本选择和复制粘贴功能。 123- (BOOL)textViewShouldBeginEditing:(UITextView *)textView { return NO;} 返回NO即可。","link":"/2020/07/06/UITextView实现点击富文本响应事件/"},{"title":"iOS绘制五角星，实现小数点分数填充","text":"最近有一个需求是要显示分数和星星图标，如果是4.8分就显示4个星星+80%填充的星星。 参考美团 一开始想的是通过UIBezierPath+CAShapeLayer手动绘制然后上网找了一大堆五角星的坐标系算法，最后发现要么算的不对，要么太过于复杂，整个过程还是很麻烦的，而且一旦设计要的五角星图标还有各种弧线圆角，那算起来就更是一个无底洞了。所以这个方案直接pass。 图层蒙版最近刚看完了《Core Animation》这本书（PS：讲的非常好，推荐大家一读），了解到CALayer有一个contents属性。 CALayer 有一个属性叫做 contents ，这个属性的类型被定义为id，意味着它可以 是任何类型的对象。在这种情况下，你可以给 contents属性赋任何值，你的app 仍然能够编译通过。但是，在实践中，如果你给 contents赋的不是CGImage， 那么你得到的图层将是空白的。contents 这个奇怪的表现是由Mac OS的历史原因造成的。它之所以被定义为id 类型，是因为在Mac OS系统上，这个属性对CGImage和NSImage类型的值都起作 用。如果你试图在iOS平台上将UIImage的值赋给它，只能得到一个空白的图层。 一些初识Core Animation的iOS开发者可能会对这个感到困惑。头疼的不仅仅是我们刚才提到的这个问题。事实上，你真正要赋值的类型应该是 CGImageRef，它是一个指向CGImage结构的指针。UIImage有一个CGImage属 性，它返回一个”CGImageRef”,如果你想把这个值直接赋值给CALayer的 contents ，那你将会得到一个编译错误。因为CGImageRef并不是一个真正的 Cocoa对象，而是一个Core Foundation类型。尽管Core Foundation类型跟Cocoa对象在运行时貌似很像(被称作toll-free bridging)，他们并不是类型兼容的，不过你可以通过bridged关键字转换。如果要 给图层的寄宿图赋值，你可以按照以下这个方法:layer.contents = (__bridge id)image.CGImage; 同时CALayer有一个mask属性， CALayer有一个属性叫做 mask 可以解决这个问题。这个属性本身就是个 CALayer类型，有和其他图层一样的绘制和布局属性。它类似于一个子图层，相对 于父图层(即拥有该属性的图层)布局，但是它却不是一个普通的子图层。不同于 那些绘制在父图层中的子图层， mask 图层定义了父图层的部分可见区域。mask 图层的 Color 属性是无关紧要的，真正重要的是图层的轮廓。 mask 属 性就像是一个饼干切割机， mask 图层实心的部分会被保留下来，其他的则会被抛 弃。如果 mask 图层比父图层要小，只有在 mask 图层里面的内容才是它关心的， 除此以外的一切都会被隐藏起来。 最终方案那么，我们是不是就可以这样：我通过contents属性读取一张星星的图片赋值给一个layer图层，这个图层的绘制区域就会是整个图片区域，然后把这个图层作为mask赋值给我们的星星视图（就叫StarView）。那么StarView的可见区域只会是星星区域，其它部分都会被抛弃。 12345UIImage *starImage = [UIImage imageNamed:@\"star\"];CALayer *maskLayer = [CALayer layer];maskLayer.frame = CGRectMake(0, 0, w, h);maskLayer.contents = (__bridge id)starImage.CGImage;self.layer.mask = maskLayer; 这样我们的星星图案就出来了，这时候我在加一个view或者layer作为填充色覆盖 1234CALayer *fillLayer = [[CALayer alloc] init];fillLayer.frame = CGRectMake(-w + w*0.7, 0, w, h);fillLayer.backgroundColor = [UIColor orangeColor].CGColor;[self.layer addSublayer:fillLayer]; 这样，我们就实现了按照小数点多少来填充星星的效果了！ 最后强烈推荐没看过《Core Animation》这本书的同学看一遍，里面讲的很多知识点都是非常实用的。相信大家也都会收获良多。","link":"/2021/04/13/iOS绘制五角星，实现小数点分数填充/"},{"title":"iOS绘制仪表盘，游标沿圆形轨迹移动动画","text":"最近碰到一个需求，需要画一个仪表盘的页面。图上所示。 圆弧部分还好，用CAShapeLayer+UIBezierPath曲线，只要确定好圆心部分和左右两边的角度就行。这里正好说明一下 1- (void)addArcWithCenter:(CGPoint)center radius:(CGFloat)radius startAngle:(CGFloat)startAngle endAngle:(CGFloat)endAngle clockwise:(BOOL)clockwise API_AVAILABLE(ios(4.0)); 这个接口startAngle、endAngle和clockwise的关系，之前一直记不太清。 我们需要看一下下面这张图 clockwise为true的时候，就会从startAngle按顺时针方向画弧。为false的时候，按逆时针方向画弧。这里有一个要注意的地方是 顺时针的360°表示的值，必须是0~2*M_PI， 逆时针的360°表示的值必须是0~-2*M_PI。 同一个角度表示的值，在clockwise取true或者false的情况下，是需要转换的。 了解了上面的注意点之后，三条圆弧还是能很方便的画出来的。 接下来就是动态的显示进度。即白色圆弧每次数值变化，弧线动态增长或减少。 一开始想的是每次都重新绘制贝塞尔曲线，但是发现从动画效果上来看，每次重新绘制，都会从起点位置绘制到终点位置。不是想要的效果。然后又想着设置layer.masksToBounds=true然后，画一条半圆，通过旋转来达到左右移动的效果，这样超出layer的部分就不会显示了，但是又发现背景的圆弧不是一块半圆，会存在覆盖不全的情况。后来查看CAShaperLayer的说明，发现这样一个属性 123456789/* These values define the subregion of the path used to draw the * stroked outline. The values must be in the range [0,1] with zero * representing the start of the path and one the end. Values in * between zero and one are interpolated linearly along the path * length. strokeStart defaults to zero and strokeEnd to one. Both are * animatable. */@property CGFloat strokeStart;@property CGFloat strokeEnd; 这两个值默认是0和1，对应的就是起始点和终点的比例，当storkeEnd=0.5的时候，原来圆弧终点的值就会减少为原来的一半那么我就可以这样了，我先画一套完整的覆盖背景圆弧的实线圆弧，设置strokeEnd=0，这样圆弧长度就为0了。当值变化的时候，在调整strokeEnd的值。就可以动态的变化圆弧长度了。 12345678CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@\"strokeEnd\"];animation.duration = 1;animation.fromValue = @(oldValue/100.0);animation.toValue = @(value/100.0);animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionLinear];animation.removedOnCompletion = NO;animation.fillMode = kCAFillModeForwards;[self.valueLayer addAnimation:animation forKey:@\"valueProgress\"]; 搞定了圆弧的变化之后，还有一部分是小圆点的移动，它是按照圆弧的轨迹移动的，那么在做动画效果的时候，就要让小圆点按照圆弧的轨迹移动位置。 1234567891011121314151617181920212223242526UIBezierPath *bezierPath = [UIBezierPath bezierPath];CGFloat outerWidth = 226;if (oldValue &gt; value) { // &lt;- CGFloat valueAngle = value/100.0 * (2*M_PI - (self.startAngle - self.endAngle)) + self.startAngle; CGFloat oldAngle = oldValue/100.0 * (2*M_PI - (self.startAngle - self.endAngle)) + self.startAngle; valueAngle = valueAngle - 2*M_PI; oldAngle = oldAngle - 2*M_PI; [bezierPath addArcWithCenter:CGPointMake(outerWidth/2, outerWidth/2) radius:outerWidth/2 startAngle:oldAngle endAngle:valueAngle clockwise:NO];} else if (oldValue &lt; value) { // -&gt; CGFloat valueAngle = value/100.0 * (2*M_PI - (self.startAngle - self.endAngle)) + self.startAngle; CGFloat oldAngle = oldValue/100.0 * (2*M_PI - (self.startAngle - self.endAngle)) + self.startAngle; [bezierPath addArcWithCenter:CGPointMake(outerWidth/2, outerWidth/2) radius:outerWidth/2 startAngle:oldAngle endAngle:valueAngle clockwise:YES];} else { return;}CAKeyframeAnimation *positionKF = [CAKeyframeAnimation animationWithKeyPath:@\"position\"];positionKF.duration = 1;positionKF.path = bezierPath.CGPath;positionKF.calculationMode = kCAAnimationPaced;positionKF.removedOnCompletion = NO;positionKF.fillMode = kCAFillModeForwards;[self.cursorLayer addAnimation:positionKF forKey:@\"rotateCursorAnimated\"]; 我们根据起点和终点绘制一段小圆点移动的路径，设置CAKeyframAnimation即可。这里比较绕的时候，当小圆点从左往右移动和从右往左移动，一个是顺时针clock=YES一个是逆时针clock=NO，这里就要注意我们前面说的了，相同角度下，顺时针和逆时针需要换算一下。参考上面的代码。 完整代码如下，仅供参考 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257#import \"PointView.h\"@interface PointView ()@property (nonatomic, strong) CAShapeLayer *valueLayer;@property (nonatomic, strong) CALayer *cursorLayer;@property (nonatomic, strong) UIBezierPath *valuePath;@property (nonatomic, assign) CGFloat startAngle;@property (nonatomic, assign) CGFloat endAngle;@property (nonatomic, assign) CGFloat currenAngle;@property (nonatomic, strong) CADisplayLink *link;@property (nonatomic, strong) UILabel *numberLabel;@property (nonatomic, assign) NSInteger oldValue;@end@implementation PointView- (instancetype)initWithFrame:(CGRect)frame { self = [super initWithFrame:frame]; if (self) { _startAngle = M_PI*15.2/18; _endAngle = M_PI*2.8/18; [self setupViews]; } return self;}- (void)dealloc { [self.link invalidate]; self.link = nil;}/** p1********************************************p6 * * * * * * * * p2******************p3 p4******************p5 p3.1 * p4.1 */- (void)setupViews { CGFloat x = 0; CGFloat y = 0; CGFloat width = self.frame.size.width; CGFloat height = self.frame.size.height; CGFloat radius = 15; CGPoint p1 = CGPointMake(x, y); CGPoint p2 = CGPointMake(x, height-radius); CGPoint p3 = CGPointMake(width/2-radius, height-radius); CGPoint p3_1 = CGPointMake(width/2-radius, height); CGPoint p4 = CGPointMake(width/2+radius, height-radius); CGPoint p4_1 = CGPointMake(width/2+radius, height); CGPoint p5 = CGPointMake(width, height-radius); CGPoint p6 = CGPointMake(width, y); CAGradientLayer *gradientLayer = [[CAGradientLayer alloc] init]; UIColor *startColor = [UIColor colorWithRed:225/255.0 green:187/255.0 blue:118/255.0 alpha:1]; UIColor *endColor = [UIColor colorWithRed:209/255.0 green:162/255.0 blue:92/255.0 alpha:1]; gradientLayer.colors = @[(__bridge id)startColor.CGColor, (__bridge id)endColor.CGColor]; gradientLayer.startPoint = CGPointMake(0.5, 0); gradientLayer.endPoint = CGPointMake(0.5, 1); gradientLayer.frame = self.bounds; [self.layer addSublayer:gradientLayer]; CAShapeLayer *shapeLayer = [CAShapeLayer layer]; UIBezierPath *bezierPath = [UIBezierPath bezierPath]; [bezierPath moveToPoint:p1]; [bezierPath addLineToPoint:p2]; [bezierPath addLineToPoint:p3]; [bezierPath addArcWithCenter:p3_1 radius:radius startAngle:1.5*M_PI endAngle:0 clockwise:YES]; [bezierPath addArcWithCenter:p4_1 radius:radius startAngle:-1*M_PI endAngle:-0.5*M_PI clockwise:YES]; [bezierPath moveToPoint:p4]; [bezierPath addLineToPoint:p5]; [bezierPath addLineToPoint:p6]; [bezierPath addLineToPoint:p1]; shapeLayer.path = bezierPath.CGPath; self.layer.mask = shapeLayer; // inner circle CAShapeLayer *innerLayer = [CAShapeLayer layer]; CGFloat innerWidth = 170; CGFloat innerHeight = 135; innerLayer.frame = CGRectMake(width/2-innerWidth/2, 54, innerWidth, innerHeight); UIBezierPath *innerPath = [UIBezierPath bezierPath]; [innerPath addArcWithCenter:CGPointMake(innerWidth/2, innerWidth/2) radius:innerWidth/2 startAngle:M_PI*14.4/18 endAngle:M_PI*3.6/18 clockwise:YES]; innerLayer.path = innerPath.CGPath; innerLayer.strokeColor = [[UIColor whiteColor] colorWithAlphaComponent:0.4].CGColor; innerLayer.fillColor = [UIColor clearColor].CGColor; innerLayer.lineDashPattern = @[@4, @3]; [self.layer addSublayer:innerLayer]; // middle circle CAShapeLayer *middleLayer = [CAShapeLayer layer]; CGFloat middleWidth = 199; CGFloat middleHeight = 158; middleLayer.frame = CGRectMake(width/2-middleWidth/2, 37, middleWidth, middleHeight); UIBezierPath *middlePath = [UIBezierPath bezierPath]; [middlePath addArcWithCenter:CGPointMake(middleWidth/2, middleWidth/2) radius:middleWidth/2 startAngle:M_PI*15/18 endAngle:M_PI*3/18 clockwise:YES]; middleLayer.path = middlePath.CGPath; middleLayer.strokeColor = [[UIColor whiteColor] colorWithAlphaComponent:0.4].CGColor; middleLayer.fillColor = [UIColor clearColor].CGColor; middleLayer.lineWidth = 10; middleLayer.lineCap = kCALineCapRound; [self.layer addSublayer:middleLayer]; // outer circle CAShapeLayer *outerLayer = [CAShapeLayer layer]; CGFloat outerWidth = 226; CGFloat outerHeight = 165; outerLayer.frame = CGRectMake(width/2-outerWidth/2, 24, outerWidth, outerHeight); UIBezierPath *outerPath = [UIBezierPath bezierPath]; [outerPath addArcWithCenter:CGPointMake(outerWidth/2, outerWidth/2) radius:outerWidth/2 startAngle:M_PI*15.2/18 endAngle:M_PI*2.8/18 clockwise:YES]; outerLayer.path = outerPath.CGPath; outerLayer.strokeColor = [[UIColor whiteColor] colorWithAlphaComponent:0.4].CGColor; outerLayer.fillColor = [UIColor clearColor].CGColor; outerLayer.lineWidth = 3; outerLayer.lineCap = kCALineCapRound; [self.layer addSublayer:outerLayer]; // value circle CAShapeLayer *valueLayer = [CAShapeLayer layer]; valueLayer.frame = CGRectMake(width/2-outerWidth/2, 24, outerWidth, outerHeight); self.valuePath = [UIBezierPath bezierPath]; [self.valuePath addArcWithCenter:CGPointMake(outerWidth/2, outerWidth/2) radius:outerWidth/2 startAngle:self.startAngle endAngle:self.endAngle clockwise:YES]; valueLayer.path = self.valuePath.CGPath; valueLayer.strokeColor = [UIColor whiteColor].CGColor; valueLayer.fillColor = [UIColor clearColor].CGColor; valueLayer.lineWidth = 3; valueLayer.lineCap = kCALineCapRound; self.cursorLayer = [CALayer layer]; self.cursorLayer.backgroundColor = [UIColor whiteColor].CGColor; self.cursorLayer.cornerRadius = 4; self.cursorLayer.masksToBounds = YES; CGPoint startPoint = [[self pointsFromBezierPath:self.valuePath].firstObject CGPointValue]; self.cursorLayer.frame = CGRectMake(startPoint.x, startPoint.y, 8, 8); [valueLayer addSublayer:self.cursorLayer]; [self.layer addSublayer:valueLayer]; self.valueLayer = valueLayer; self.valueLayer.strokeEnd = 0; self.value = 0; self.numberLabel = [[UILabel alloc] initWithFrame:CGRectMake(width/2-100/2, 102, 100, 63)]; self.numberLabel.textColor = [UIColor whiteColor]; self.numberLabel.font = [UIFont systemFontOfSize:45]; self.numberLabel.textAlignment = NSTextAlignmentCenter; self.numberLabel.text = @\"0\"; [self addSubview:self.numberLabel]; self.link = [CADisplayLink displayLinkWithTarget:self selector:@selector(displayNumber)]; [self.link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode]; self.link.paused = YES;}- (void)displayNumber { NSLog(@\"display link变化\"); NSInteger currentNumber = [self.numberLabel.text integerValue]; if (self.value &lt; currentNumber) { currentNumber -= 1; } else if (self.value &gt; currentNumber) { currentNumber += 1; } if (currentNumber == self.value) { self.link.paused = YES; } self.numberLabel.text = [NSString stringWithFormat:@\"%ld\", currentNumber];}- (void)setValue:(NSInteger)value { NSInteger oldValue = _value; _oldValue = oldValue; _value = value; NSLog(@\"旧值：%f | 新值：%f\", oldValue/100.0, value/100.0); CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@\"strokeEnd\"]; animation.duration = 1; animation.fromValue = @(oldValue/100.0); animation.toValue = @(value/100.0); animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionLinear]; animation.removedOnCompletion = NO; animation.fillMode = kCAFillModeForwards; [self.valueLayer addAnimation:animation forKey:@\"valueProgress\"];// self.valueLayer.strokeEnd = value/100.0; self.link.paused = NO; // [CATransaction begin]; UIBezierPath *bezierPath = [UIBezierPath bezierPath]; CGFloat outerWidth = 226; if (oldValue &gt; value) { // &lt;- CGFloat valueAngle = value/100.0 * (2*M_PI - (self.startAngle - self.endAngle)) + self.startAngle; CGFloat oldAngle = oldValue/100.0 * (2*M_PI - (self.startAngle - self.endAngle)) + self.startAngle; valueAngle = valueAngle - 2*M_PI; oldAngle = oldAngle - 2*M_PI; [bezierPath addArcWithCenter:CGPointMake(outerWidth/2, outerWidth/2) radius:outerWidth/2 startAngle:oldAngle endAngle:valueAngle clockwise:NO]; } else if (oldValue &lt; value) { // -&gt; CGFloat valueAngle = value/100.0 * (2*M_PI - (self.startAngle - self.endAngle)) + self.startAngle; CGFloat oldAngle = oldValue/100.0 * (2*M_PI - (self.startAngle - self.endAngle)) + self.startAngle; [bezierPath addArcWithCenter:CGPointMake(outerWidth/2, outerWidth/2) radius:outerWidth/2 startAngle:oldAngle endAngle:valueAngle clockwise:YES]; } else { return; } CAKeyframeAnimation *positionKF = [CAKeyframeAnimation animationWithKeyPath:@\"position\"]; positionKF.duration = 1; positionKF.path = bezierPath.CGPath; positionKF.calculationMode = kCAAnimationPaced; positionKF.removedOnCompletion = NO; positionKF.fillMode = kCAFillModeForwards; [self.cursorLayer addAnimation:positionKF forKey:@\"rotateCursorAnimated\"];}void getPointsFromBezier(void *info, const CGPathElement *element) { NSMutableArray *bezierPoints = (__bridge NSMutableArray *)info; CGPathElementType type = element-&gt;type; CGPoint *points = element-&gt;points; if (type != kCGPathElementCloseSubpath) { [bezierPoints addObject:[NSValue valueWithCGPoint:points[0]]]; if (type != kCGPathElementAddLineToPoint &amp;&amp; type != kCGPathElementMoveToPoint) { [bezierPoints addObject:[NSValue valueWithCGPoint:points[1]]]; } } if (type == kCGPathElementAddCurveToPoint) { [bezierPoints addObject:[NSValue valueWithCGPoint:points[2]]]; }}- (NSArray *)pointsFromBezierPath:(UIBezierPath *)path { NSMutableArray *points = [NSMutableArray array]; CGPathApply(path.CGPath, (__bridge void *)points, getPointsFromBezier); return points;}@end","link":"/2020/11/20/iOS绘制仪表盘，游标沿圆形轨迹移动动画/"},{"title":"schema实现iOS项目多环境配置","text":"当前公司项目有test1，test2，stage，pre，prod5套环境，每次不同环境下测试都要手动修改url和一些第三方服务的APPID，手动修改往往会出错，造成很多不便，也不利于以后的自动化打包发布。 添加环境变量第一次遇到这个需求，首先想到的就是通过环境变量来区分，之前开发的时候一般用到DEBUG这个环境变量 123#ifdef DEBUG// xxx#end 系统默认会提供Debug和Release两套环境。我们在build settings里面搜索Macros也会找到Preprocessor Macros这个配置。 我现在有5套环境，同时有Debug和Release的情况，那就是总共要添加10个环境变量。我们可以去PROJECT -&gt; Info -&gt; Configurations下添加需要的环境变量。把Debug作为本地运行的正式服环境，Release作为打包发布的正式服环境，点击+号分别Duplicate另外4套环境。最后结果就是这样在PROJECT -&gt; Build Settings下找到Preprocessor Macros，就可以添加对应环境的环境变量了 当然有了环境变量，我们还要有不同的环境 配置Schema实现不同环境点击Xcode左上角的Schema，一般项目只有一个主Schema，可能创建工厂的时候勾选了Test啥的那都不用管。点击Edit Schema可以看到里面的配置我们平常本地跑都默认的事Debug那套环境，打包用的是Release。点击Build Configurations可以看到已经有我们刚才添加的环境了。那么现在就很简单了，在当前target下添加新的Schema我要添加的有Test1，Test2，Stage，Pre四套同时配置Run和Archive下的对应的build configuration到现在算是差不多完成了，要跑不同的环境选择不同的Schema编译运行就OK了！ 12345678910111213141516171819202122// config.h#ifdef TEST1#define BASE_URL = @\"https://test1.com\"#elif TEST2#define BASE_URL = @\"https://test2.com\"#elif STAGE#define BASE_URL = @\"https://stage.com\"#elif PRE#define BASE_URL = @\"https://pre.com\"#else#define BASE_URL = @\"https://prod.com\"#endif Pod的一些问题新建的Configurations设置的环境变量在Pod -&gt; Target里面没有添加上去。当我切换Schema本地运行的时候，发现报错了，原因是用到的第三方库有一个判断DEBUG环境的的地方始终没有通过，导致走了Release的流程。去Pods对应的的配置里面看到无论是PROJECT的Pods还是下面Target里面的环境变量，虽然有之前在主工程添加的环境，但是环境变量却没有带过来。当我手动在PROJECT -&gt; Pods -&gt; Build Settings下添加对应的DEBUG=1后发现可以解决，但是当我重新pod install后，Pods的配置又全都重置了。这就有点尴尬了。 谷歌一番后…… 原来要想修改Pods工程的配置，只能在Podfile里通过代码修改。具体的关于Podfile资料大家可以自行网上了解。 1234567891011121314151617181920212223def schema_post_install(installer) installer.pods_project.targets.each do |target| target.build_configurations.each do |config| if config.name == &apos;Debug_Test1&apos; config.build_settings[&apos;GCC_PREPROCESSOR_DEFINITIONS&apos;] ||= [&apos;$(inherited)&apos;,&apos;DEBUG=1&apos;] elsif config.name == &apos;Debug_Test2&apos; config.build_settings[&apos;GCC_PREPROCESSOR_DEFINITIONS&apos;] ||= [&apos;$(inherited)&apos;,&apos;DEBUG=1&apos;] elsif config.name == &apos;Debug_Stage&apos; config.build_settings[&apos;GCC_PREPROCESSOR_DEFINITIONS&apos;] ||= [&apos;$(inherited)&apos;,&apos;DEBUG=1&apos;] elsif config.name == &apos;Debug_Pre&apos; config.build_settings[&apos;GCC_PREPROCESSOR_DEFINITIONS&apos;] ||= [&apos;$(inherited)&apos;,&apos;DEBUG=1&apos;] end end endendtarget &apos;TestDemo&apos; do # 省略代码 post_install do |installer| flipper_post_install(installer) schema_post_install(installer) endend 手动加上DEBUG=1即可。 新建的Configurations在Pods下是release模式当我能成功运行的时候发现build的时间和tasks数量和原来debug模式下的不一样。最后发现原来是Pods下的新加的configurations的那些第三方库的模式都是Release。要想修改也需要在Podfile下指定build configurations的模式 1project &apos;TestDemo&apos;, &apos;Debug_Test1&apos; =&gt; :debug, &apos;Debug_Test2&apos; =&gt; :debug, &apos;Debug_Stage&apos; =&gt; :debug, &apos;Debug_Pre&apos; =&gt; :debug 当重新pod install之后 总结以上就是通过schema实现多环境配置的全部流程了，算是实现了自动化打包的第一步吧，通过配置环境变量来实现不同环境区分。后面再通过fastlane实现自动打包，再写一个脚本自动更新代码和依赖，执行fastlane打包命令，测试环境下打包自动上传蒲公英给测试，正式环境上传App Store。","link":"/2020/12/09/schema实现iOS项目多环境配置/"},{"title":"关于结构体的内存对齐以及嵌套结构体的内存计算","text":"8中基本类型所占字节数byte 1short 2int 4long 8float 4double 8char 2bool 1 前面的地址必须是下一个大小的整数倍比如前面是0 ~ 11，下一位是一个char类型的变量，只占1个字节，第12位是1字节的整数倍，那么第12位就可以存放这个变量。再下一位是一个int型的变量，占4个字节，此时0~12位存放了数据，往下第13位不是4的倍数，必须补齐到最近的16才可以，那么就需要从16位开始存：16，17，18，19 整个Struct的地址必须是最大字节的整数倍如果最后计算大小是14，最大的变量大小是4，那么整个必须是4的倍数才行，最后大小为16。 内嵌结构体需要展开计算在计算内存大小的时候，内嵌结构体的变量都被解包放在最外层计算。就像多维数组转为一维数组一样。 计算一个结构体的大小123456struct Foo { int a; // 占4个字节 0,1,2,3 double b; // 占8个字节，4不是8的倍数，所以要从8开始 8,9,10,11,12,13,14,15 short c; // 占2个字节 16,17 char d; // 占2个字节 18,19} 计算出的大小是20，但是总大小必须是最大字节的整数倍，所以是24. 内嵌结构体大小123456struct Soo { double a; int b; char c; struct Foo f;} 在计算的时候，会把Foo类型的变量都拿到最外层，就会变成下面这样 123456789struct Soo { double a; // 0,1,2,3,4,5,6,7 int b; // 8,9,10,11 char c; // 12,13 int fa; // 16,17,18,19 double fb; // 24,25,26,27,28,29,30,31 short fc; // 32,33 char fd; // 34,35} 计算出的大小是36，最大字节是8，所以最后是40.","link":"/2020/09/19/关于结构体的内存对齐以及嵌套结构体的内存计算/"},{"title":"如何继承一个带有Xib的ViewController","text":"先来看看一个UIViewController的初始化过程 如果这个ViewController是在Storyboard创建显示的，那么会走initWithCode的方法，否则都会走initWithNibName:bundle。 但是我们发现，在展示一个Xib的UIViewController和纯代码的UIViewController的时候，他们的方式是一样的，即 12XibViewController *ctrl = [[XibViewController alloc] init];[self.navigationController pushViewController:ctrl animated:YES]; 而且打印发现，传入的nib name都是null 12020-07-15 19:03:00.721069+0800 AwesomeOC[19613:229780] XibViewController init with nib name: (null) | (null) 那么xib上的视图又是什么时候关联到对应的ViewController上的呢？ loadView的作用 这个方法中，要正式加载View了。首先我们得知道，控制器 view 是通过懒加载的方式进行加载的，即用到的时候再加载。永远不要主动调用这个方法。当我们用到控制器 view 时，就会调用控制器 view 的 get 方法，在 get 方法内部，首先判断 view 是否已经创建，如果已存在，则直接返回存在的 view，如果不存在，则调用控制器的 loadView 方法，在控制器没有被销毁的情况下，loadView 也可能会被执行多次。 当ViewController有以下情况时，都会在此方法中从nib文件加载view： ViewController是通过storyboard中实例化的 通过initWithNibName:bundle:初始化 在App Bundle中有一个nib文件名称和本类名相同 所以，当我们push一个带有xib的ViewController时，虽然和纯代码创建的ViewController一样初始化都是传入的nil，但是在loadView这一步会加载对应nib文件中的view。而没有关联xib文件的ViewController，就会默认创建一个空白的UIView对象，然后让这个对象成为ViewController的主view。 那么该如何继承在ViewController的生命周期中，在loadView那一步才算是真正的把View关联到ViewController上，在这一步，默认是一个空白的View，如果有对应nib文件或指定了nib文件，那么就从nib文件加载，还可以自定义view然后关联到ViewController上。 所以要想实现继承ViewController，复用父ViewController的页面的话，那么就要想办法加载到父ViewController的view。现在默认有这样两个ViewController SubXibViewController继承自XibViewController。 当我用普通的方式展示SubXibViewController的时候。 12SubXibViewController *ctrl = [[SubXibViewController alloc] init];[self.navigationController pushViewController:ctrl animated:YES]; SubXibViewController不符合从nib文件加载view的三个条件，它只会创建一个空白的View。它的父VC并没有在ViewDidLoad中有任何代码创建视图的操作。 我们这时候看一下条件2：通过initWithNibName:bundle:初始化。也就是说，如果我们指定一个nib文件来初始化，在loadView的那一步，他就会从nib文件加载view。即 12SubXibViewController *ctrl = [[SubXibViewController alloc] initWithNibName:@\"XibViewController\" bundle:nil];[self.navigationController pushViewController:ctrl animated:YES]; 我们指定父VC的xib文件，最终效果大家可以试验一下，子VC会加载父VC的View，这样就实现了继承复用父类View的效果了！","link":"/2020/07/15/如何继承一个带有Xib的ViewController/"},{"title":"彻底区分isKindOfClass和isMemberOfClass","text":"以前用到这两个函数的时候，总是会分不清这两个函数的作用，记了笔记也经常翻出来看，这次就来彻底了解一下 以前的笔记 先看一下isKindOfClass作用都清楚了，我们直接去objc的源码项目里去看，先看isKindOfClass 实例方法是查找对象所属的类，然后比较，不相等就再找父类，直到NSObject（因为NSObject的superclass = nil)。类方法是查找类的ISA指针，实力的ISA指针指向类，类的ISA指针指向元类。元类的父类最后会找到NSObject上。 关于ISA的走势图，大家应该都熟悉这张图，这里就不再多说了。 所以关于isKindOfClass的实现原理差不多就是这样 再看看isMemberOfClass 也分实例方法和类方法。实例方法是把自身所属的类和传入的类作比较，静态方法是把自身的ISA指针和传入的类做比较。 通过这四个函数的实现，也符合了之前笔记的总结。 看一下一个面试题 BOOL res1 = [(id)[NSObject class] isKindOfClass:[NSObject class]];BOOL res2 = [(id)[NSObject class] isMemberOfClass:[NSObject class]];BOOL res3 = [(id)[TestObject class] isKindOfClass:[TestObject class]];BOOL res4 = [(id)[TestObject class] isMemberOfClass:[TestObject class]];他们的结果是多少？ 这些都是类方法的isKindOfClass和isMemberOfClass比较。NSObject的ISA会指向元类NSObject，元类NSObject的superClass又指向NSObject自己。TestObject的ISA指向TestObject元类，TestObject元类的superClass最后又会指向NSObject根元类，再指向NSObject。 所以上面的结果出了第一个是YES，剩下的都是NO。","link":"/2020/09/16/彻底区分isKindOfClass和isMemberOfClass/"},{"title":"记录一下个人网站的搭建上线过程","text":"参考 我如何使用 Django + Vue.js 快速构建项目 - 知乎 技术选型由于个人技术栈里面有Python和Vue，现在正好前后端分离是趋势，所以就选用了Django+Vue，部署用到了nginx和uwsgi 项目结构用django-admin创建项目后，新建frontend文件夹放前端打包的文件 12345678910total 280-rw-r--r-- 1 lijun staff 31B 4 16 14:54 README.mddrwxr-xr-x 10 lijun staff 320B 4 16 15:20 blog-rw-r--r-- 1 lijun staff 128K 4 16 15:20 db.sqlite3drwxr-xr-x 3 lijun staff 96B 4 16 15:18 frontenddrwxr-xr-x 3 lijun staff 96B 4 17 09:48 log-rwxr-xr-x 1 lijun staff 626B 4 16 14:05 manage.pydrwxr-xr-x 9 lijun staff 288B 4 17 09:48 mysite-rw-r--r-- 1 lijun staff 329B 4 17 09:48 mysite.inidrwxr-xr-x 6 lijun staff 192B 4 17 09:48 static 1234567891011121314frontend└── dist ├── favicon.ico ├── index.html └── static ├── css │ └── app.fb0c6e1c.css ├── img │ └── logo.82b9c7a5.png └── js ├── app.7cc09bbb.js ├── app.7cc09bbb.js.map ├── chunk-vendors.61405a0c.js └── chunk-vendors.61405a0c.js.map Django接入Vue要配置Django的templates 123456789101112131415TEMPLATES = [ { 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': ['frontend/dist'], // 这里加入目录路径 'APP_DIRS': True, 'OPTIONS': { 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], }, },] urls用TemplateView接入 12345678from django.contrib import adminfrom django.urls import pathfrom django.views.generic.base import TemplateViewurlpatterns = [ path('', TemplateView.as_view(template_name='index.html')), path('admin/', admin.site.urls),] 配置静态文件搜索路径 12345STATIC_URL = '/static/'STATICFILES_DIRS = [ os.path.join(BASE_DIR, \"frontend/dist/static\"),]STATIC_ROOT = os.path.join(BASE_DIR, \"static\") STATIC_ROOT设置的作用是让nginx那里找到静态文件用 服务器部分nginx的配置文件 12345678910111213141516171819202122server { listen 8888; server_name localhost; // 这里后续等域名审核通过了换上域名应该就可以了。 root /root/mysite; access_log /var/log/nginx/access_mysite.log; error_log /var/log/nginx/error_mysite.log; location / { uwsgi_pass 127.0.0.1:9292; include /etc/nginx/uwsgi_params; } location /static/ { root /root/mysite; access_log off; } location ^~ /admin/ { uwsgi_pass 127.0.0.1:9292; include /etc/nginx/uwsgi_params; }} uwsgi的配置文件 12345678910111213[uwsgi]socket = 127.0.0.1:9292chdir = /root/mysitemodule = mysite.wsgimaster = trueprocesses = 1threads = 2max-requests = 6000touch-reload = /root/mysitepy-auto-reload = 1pidfile = /var/run/mysite.piddaemonize = /root/mysite/log/run.log socket：指定uwsgi的通信端口chdir：服务器上项目所在的目录module：项目目录下的wsgi文件（即mysite/wsgi.py） 运行配置全都配好之后，浏览器打开域名发现nginx可以同，但是转到对应端口，发现出现 403（forbidden）的问题，路径都找对了，但是没有权限读到文件。最后发现是nginx.conf设置的问题 12345678910user root; // 这里原来是www-data，因为我项目是放在/root/下的，所以得改成rootworker_processes auto;pid /run/nginx.pid;include /etc/nginx/modules-enabled/*.conf;events { worker_connections 768; # multi_accept on;}… 搭建完成耗费了一些时间，本来就对nginx和uwsgi这些概念不了解，没有配置的经验，照着网上的教程来做。主要还是怎么快速的定位问题，这样就能分析、寻找解决方案，而不是一头雾水的把错误信息放到搜索框里直接谷歌。 问题解决，那么接下里就可以愉快的写个人网站了😋","link":"/2020/04/17/记录一下个人网站的搭建上线过程/"}],"tags":[{"name":"算法","slug":"算法","link":"/tags/算法/"},{"name":"报错","slug":"报错","link":"/tags/报错/"},{"name":"Mac使用","slug":"Mac使用","link":"/tags/Mac使用/"},{"name":"package","slug":"package","link":"/tags/package/"},{"name":"并发","slug":"并发","link":"/tags/并发/"},{"name":"字符串","slug":"字符串","link":"/tags/字符串/"},{"name":"性能","slug":"性能","link":"/tags/性能/"},{"name":"flag","slug":"flag","link":"/tags/flag/"},{"name":"位运算","slug":"位运算","link":"/tags/位运算/"},{"name":"日常反思","slug":"日常反思","link":"/tags/日常反思/"},{"name":"RunLoop","slug":"RunLoop","link":"/tags/RunLoop/"},{"name":"多线程","slug":"多线程","link":"/tags/多线程/"},{"name":"iOS","slug":"iOS","link":"/tags/iOS/"},{"name":"翻译","slug":"翻译","link":"/tags/翻译/"},{"name":"数据结构","slug":"数据结构","link":"/tags/数据结构/"},{"name":"队列","slug":"队列","link":"/tags/队列/"},{"name":"学习笔记","slug":"学习笔记","link":"/tags/学习笔记/"},{"name":"Swift","slug":"Swift","link":"/tags/Swift/"},{"name":"sql","slug":"sql","link":"/tags/sql/"},{"name":"基础","slug":"基础","link":"/tags/基础/"},{"name":"排序","slug":"排序","link":"/tags/排序/"},{"name":"正则表达式","slug":"正则表达式","link":"/tags/正则表达式/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Django","slug":"Django","link":"/tags/Django/"},{"name":"pip","slug":"pip","link":"/tags/pip/"},{"name":"Mysql","slug":"Mysql","link":"/tags/Mysql/"},{"name":"小感想","slug":"小感想","link":"/tags/小感想/"},{"name":"import","slug":"import","link":"/tags/import/"},{"name":"Event","slug":"Event","link":"/tags/Event/"},{"name":"底层","slug":"底层","link":"/tags/底层/"},{"name":"链表","slug":"链表","link":"/tags/链表/"},{"name":"优化","slug":"优化","link":"/tags/优化/"},{"name":"日常开发","slug":"日常开发","link":"/tags/日常开发/"},{"name":"小技巧","slug":"小技巧","link":"/tags/小技巧/"},{"name":"原理","slug":"原理","link":"/tags/原理/"},{"name":"KVO","slug":"KVO","link":"/tags/KVO/"},{"name":"Crash","slug":"Crash","link":"/tags/Crash/"},{"name":"Xcode","slug":"Xcode","link":"/tags/Xcode/"},{"name":"KVC","slug":"KVC","link":"/tags/KVC/"},{"name":"哈希表","slug":"哈希表","link":"/tags/哈希表/"},{"name":"定时器","slug":"定时器","link":"/tags/定时器/"},{"name":"内存","slug":"内存","link":"/tags/内存/"},{"name":"runtime","slug":"runtime","link":"/tags/runtime/"},{"name":"锁","slug":"锁","link":"/tags/锁/"},{"name":"MarkDown","slug":"MarkDown","link":"/tags/MarkDown/"},{"name":"Codable","slug":"Codable","link":"/tags/Codable/"},{"name":"UITextView","slug":"UITextView","link":"/tags/UITextView/"},{"name":"富文本","slug":"富文本","link":"/tags/富文本/"},{"name":"绘制","slug":"绘制","link":"/tags/绘制/"},{"name":"图层","slug":"图层","link":"/tags/图层/"},{"name":"动画","slug":"动画","link":"/tags/动画/"},{"name":"架构","slug":"架构","link":"/tags/架构/"},{"name":"结构体","slug":"结构体","link":"/tags/结构体/"},{"name":"Xib","slug":"Xib","link":"/tags/Xib/"},{"name":"ISA","slug":"ISA","link":"/tags/ISA/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"nginx","slug":"nginx","link":"/tags/nginx/"},{"name":"uwsgi","slug":"uwsgi","link":"/tags/uwsgi/"}],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","link":"/categories/数据结构与算法/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"日常","slug":"日常","link":"/categories/日常/"},{"name":"Go","slug":"Go","link":"/categories/Go/"},{"name":"朝花夕拾","slug":"朝花夕拾","link":"/categories/朝花夕拾/"},{"name":"iOS","slug":"iOS","link":"/categories/iOS/"},{"name":"数据库","slug":"数据库","link":"/categories/数据库/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"运维","slug":"运维","link":"/categories/运维/"}]}