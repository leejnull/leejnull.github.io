<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  
  <title>Run Loops 翻译篇 | lee的博客</title>
  <meta name="author" content="Lee JJ">
  
  <meta name="description" content="人一旦有了梦想，怎么活都是有灵魂的">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Run Loops 翻译篇"/>
  <meta property="og:site_name" content="lee的博客"/>

  
    <meta property="og:image" content=""/>
  

  <link rel="shortcut icon" href="/favicon.png">
  
  
<link rel="stylesheet" href="/css/style.css">

  <!--[if lt IE 9]><script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script><![endif]-->
  

<meta name="generator" content="Hexo 5.0.2"></head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">lee的博客</a></h1>
  <h2><a href="/">lee的博客</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/null">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article id="post-2019-12-27-02" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2019-12-27T05:44:33.000Z"><a href="/2019/12/27/2019-12-27-02/">2019-12-27</a></time>
      
      
  
    <h1 class="p-name title" itemprop="headline name">Run Loops 翻译篇</h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <h4 id="Run-Loops"><a href="#Run-Loops" class="headerlink" title="Run Loops"></a>Run Loops</h4><p><a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html">官方文档</a></p>
<p>Run Loops 是与线程相关的基础架构的一部分。一个 run loop 是一个事件处理循环，你使用来调度工作和协调收到的事件。run loop 的目的是有工作做的时候保持线程忙碌，没有事做的时候让线程睡眠。<br>Run loop 的管理并不是全自动的。你仍然必须设计你的线程在合适的时候启动 run loop 并响应即将到来的事件。Cocoa 和 Core Foundation 都提供了 run loop 对象来帮助配置和管理线程的 run loop。你的应用不需要显式的创建这些对象；每个线程，包括应用的主线程，有一个相关联的 run loop 对象。只是非主线程需要显式的跑它们的 run loop。App 框架会自动设置并跑起主线程上的 run loop，作为应用启动的一部分。<br>下面的部分提供了更多关于 run loops 的信息，怎么为你的应用配置它们。需要查看更多的信息，可以参见<em>NSRunLoop Class Reference</em> 和 <em>CFRunLoop Reference</em></p>
<a id="more"></a>

<h4 id="Run-Loops-的剖析"><a href="#Run-Loops-的剖析" class="headerlink" title="Run Loops 的剖析"></a>Run Loops 的剖析</h4><p>run loop 非常的人如其名。它是一个线程进入并调用事件 handler 来响应事件的循环。你的代码提供用来实现 run loop 的 loop 部分的控制语句 —— 换句话就是，你的代码提供了 while 或 for 循环来驱动 run loop。在你的循环内，你使用一个 run loop 对象来跑收到事件的事件处理代码，并调用安装的 handlers。<br>一个 run loop 从两种不同类型的 source 接受事件。<em>input source</em> 传递异步事件，通常消息来自其它线程或不同应用。<em>timer source</em> 传递同步事件，发生在规划的时间点或重复的间隔。两种类型的 source 使用应用特定的 handler 函数来处理这些到来的事件。<br>下图展示了一个 run loop 和各种 sources 的概念图。Input source 传递异步事件到相应的 handler，导致 runUntilDate (在线程关联的 NSRunLoop 对象上执行) 方法退出。Timer sources 传递事件到它们的 handler 函数但不导致 run loop 退出。</p>
<p><img src="/images/run-loop-structures.png" alt="image"></p>
<p>除了处理输入的源外，run loop 会产生关于 run loop 行为的通知。这些通知的观察者可以收到这些通知，使用它们在线程上进行额外的处理。你可以使用 Core Foundation 来安装线程上的 run loop observer。</p>
<p>下面的部分提供了 run loop 组件的更多信息，它们工作的 modes。也描述了在处理事件的不同阶段产生的通知。</p>
<h4 id="Run-Loop-Modes"><a href="#Run-Loop-Modes" class="headerlink" title="Run Loop Modes"></a>Run Loop Modes</h4><p>一个 <em>run loop mode</em> 是一个被监听的 input source 和 timer 的集合和需要被通知的 run loop observers 的集合。每次你跑你的 run loop 的时候，你指定 (显式或隐式的) 特定的 mode 来跑。在 run loop 的这次跑的过程中，只有那些与指定 mode 关联的被监听的 source 允许传递它们的事件 (同样，只有那些与该 mode 关联的 observers 被通知 run loop 的进程)。与其他 mode 相关联的 sources 会维持住任何新事件，直到 run loop 以指定的 mode 通过 loop 的时候才处理。</p>
<p>在你的代码中，你通过名字来标识 modes。Cocoa 和 Core Foundation 定义了一个默认 mode 和几个通用 modes，通过字符串在代码中指定这些 modes。你可以自定义 mode，只需要给自定义的 mode 指定一个自定义字符串就可以。尽管你赋给自定义 mode 的字符串是随意的，但是 mode 的内容却不是。你必须添加一个或多个 input sources，或 run-loop observers 到任何你创建的 mode 上，这样它们才是有用的。</p>
<p>在 run loop 的一个 pass through 中你可以使用 modes 从你不想要的 sources 中过滤出事件。大部分时候，你会想要你的 run loop 对象跑在系统定义的默认�模式。然而一个 modal panel 也许跑在 “modal” mode。在这个 mode 时，只有那些和 modal panel 相关的 sources 会给线程传送事件。对于非主线程，你也需要使用自定义的 modes 来阻止低优先级的 sources 在关键操作时传送事件。</p>
<blockquote>
<p>注意: modes 的区别在于事件的 source，不在于事件的类型。例如，你不会使用 mode 来单独匹配 mouse-down 事件或键盘事件。你可以使用 modes 来监听不同的 ports，暂停 timers，或改变目前被监听的 sources 和 run loop observers</p>
</blockquote>
<p>下表列出了 Cocoa 和 Core Foundation 定义的标准 modes，和什么时候使用这些 mode 的说明。name 列列出了你在代码中真实指定的常量。</p>
<table>
<thead>
<tr>
<th>Mode</th>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>Default</td>
<td>NSDefaultRunLoopMode (Cocoa) kCFRunLoopDefaultMode (Core Foundation)</td>
<td>大部分操作使用这个 mode。大部分时候你使用这个 mode 来启动你的 run loop 和 配置你的 input sources。</td>
</tr>
<tr>
<td>Connection</td>
<td>NSConnectionReplyMode (Cocoa)</td>
<td>Cocoa 使用这个 mode 和 NSConnection 对象来监听返回。你基本不会自己用到这个 mode。</td>
</tr>
<tr>
<td>Modal</td>
<td>NSModalPanelRunLoopMode</td>
<td>Cocoa 使用这个 mode 来标识专用于 modal panels 的事件。</td>
</tr>
<tr>
<td>Event tracking</td>
<td>NSEventTrackingRunLoopMode (Cocoa)</td>
<td>Cocoa 使用在 mouse-dragging loops 或其它用户交互的 tracking loop 中使用这个 mode 来限制收到的事件。</td>
</tr>
<tr>
<td>Common Modes</td>
<td>NSRunLoopCommonModes (Cocoa) kCFRunLoopCommonModes (Core Foundation)</td>
<td>这是一个可配置的常用 mode group。与这个 mode 相关联的 input source 也会和这个 group 中的 modes 相关联。对于 Cocoa 应用而言，这个集合默认包括 default，modal，event tracking 这些modes。Core Foundation 初始的时候包含 default 的mode。你可以使用 CFRunLoopAddCommonMode 函数添加自定义 mode 到这个集合。</td>
</tr>
</tbody></table>
<h4 id="Input-Sources"><a href="#Input-Sources" class="headerlink" title="Input Sources"></a>Input Sources</h4><p>Input sources 传递异步事件到线程。事件的来源依赖于你的 input source 的类型，input source 的类型通常是两类之一。基于 Port 的 input source 监听应用的 Mach ports。自定义 input sources 监听自定义事件来源。你的 run loop 不需要关心 input source 是自定义的还是基于 port 的。系统通常实现了两种类型的 input sources，你可以直接拿来用。这两种类型 input sources 的唯一区别是它们怎么被发送信号了。基于 Port-based input source 自动被内核发送信号，而自定义的 input source 必须手动的从另一个线程发送信号给它。</p>
<p>当你创建一个 input source 的时候，你赋给它一个或多个你的 run loop 的 modes。Modes 会影响在某刻哪些 input sources 被监听。大部分时候，你会将你的 run loop 跑在 default mode，但是你也可以指定自定义 modes。如果你一个 input source 目前没有在被监听的 mode 中，任何它产生的事件会被维持住直到 run loop 跑在正确的 mode 时。</p>
<h5 id="基于-Port-的-Sources"><a href="#基于-Port-的-Sources" class="headerlink" title="基于 Port 的 Sources"></a>基于 Port 的 Sources</h5><p>Cocoa 和 Core Foundation 提供了使用 port 相关的函数和对象创建 port-based input sources 的内建支持。例如，在 Cocoa 中，你从不需要直接创建一个 input source。你简单的创建一个 port 对象，使用 NSPort 的方法添加这个 port 到 run loop。这个 port 对象会为你负责创建和配置所需的 input source。</p>
<p>在 Core Foundation 中，你必须手动创建 port 对象和它的 input source。两种情况你都需要使用 port opaque type 相关的函数 CFMachPortRef, CFMessagePortRef, CFSocketRef) 来创建合适的对象。</p>
<h5 id="自定义-Input-Sources"><a href="#自定义-Input-Sources" class="headerlink" title="自定义 Input Sources"></a>自定义 Input Sources</h5><p>创建一个自定义 input source，你必须使用 Core Foundation 中 CFRunLoopSourceRef opaque type 相关的函数。你通过使用几个回调函数来创建自定义 input source。Core Foundation 在不同点调用这些毁掉函数配置 input source，处理到达的事件，释放 input source 当 input source 从 run loop 移除的时候。</p>
<p>除了定义事件到来时自定义 input source 的行为外，你也必须定义事件传递的机制。Input source 的这部分跑在单独的线程上，负责给 input source 提供数据，当数据可用的时候发送信号给 input source 来告知它。事件交付机制是由你决定的，但不要太过复杂。</p>
<h5 id="Cocoa-Perform-Selector-Sources"><a href="#Cocoa-Perform-Selector-Sources" class="headerlink" title="Cocoa Perform Selector Sources"></a>Cocoa Perform Selector Sources</h5><p>除了基于 port 的 source 外，Cocoa 定义了一个自定义 input source，你可以是用来在任一线程执行一个 selector。跟 port-based input source 相似，执行 selector 的请求在目标线程上是串行的，减去了多个 method 在一个线程上执行时可能发生的同步问题 (请看原文，这里不确定翻译得是否准确，因为一个线程上执行多个方法是没有问题的啊)。跟 port-based source 不同的是，一个 perform selector source 会在它执行了它的 selector 之后从 run loop 中移除自己。</p>
<blockquote>
<p>注意: 在 OSX v10.5 之前，perform selector source 大部分用在给主线程发送消息，但是在 OS X v10.5 之后和 iOS 中，你可以使用它们给任何线程发送消息。</p>
</blockquote>
<p>当在另一个线程执行 selector 时， 目标线程必须有一个 active 的run loop。对于你创建的线程，这意味着等到你显式的启动 run loop。因为主线程会启动自己的 run loop，因此，在应用调用了application delegate 的 applicationDidFinishLaunching: 方法后， 你就可以给主线程发送调用了。run loop 在一次 loop 迭代中处理掉所有排好队的 perform selector calls，而不是每次 loop 迭代只处理一个。</p>
<p>下表中列出了 NSObject 上可以用来在其它线程上 perform selector 的方法。因为这些方法在 NSObject 上申明，你可以在任何可以访问 Objectvie-C 对象的地方使用这些方法，包括 POSIX 线程。这些方法并不创建线程类执行 selector。</p>
<table>
<thead>
<tr>
<th>Methods</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>performSelectorOnMainThread: withObject: waitUntilDone: performSelectorOnMainThread: withObject:waitUntilDone:modes:</td>
<td>在应用的主线程上的下次 run loop 迭代中执行指定的 selector。这些方法允许你选择是否阻塞当前线程直到 selector 被执行。</td>
</tr>
<tr>
<td>performSelector: onThread:withObject: waitUntilDone: performSelector: onThread:withObject:waitUntilDone:modes:</td>
<td>在 NSThread 对象指定的线程上执行指定的 selector。这些方法允许你选择是否阻塞当前线程直到 selector 执行完。</td>
</tr>
<tr>
<td>performSelector: withObject: afterDelay: performSelector: withObject: afterDelay:inModes:</td>
<td>在当前线程的下次 run loop 迭代中执行指定的 selector，可以指定可选的 delay 时间。因为它会等到下次 run loop 迭代，这些方法天然的有一个 mini delay 相对于目前执行的代码。多个排好队的 selectors 以它们排队的顺序执行。</td>
</tr>
<tr>
<td>cancelPreviousPerformRequestsWithTarget: cancelPreviousPerformRequestsWithTarget:selector:object:</td>
<td>让你取消使用 performSelector: withObject: afterDelay: 或 performSelector: withObject: afterDelay:inModes: 发送给一个线程的消息。</td>
</tr>
</tbody></table>
<h4 id="Timer-Sources"><a href="#Timer-Sources" class="headerlink" title="Timer Sources"></a>Timer Sources</h4><p>Timer source 在未来的某个时刻发送同步事件到线程。Timers 是一种线程通知自己做些什么的一种方式。例如，一个搜索框使用一个 timer 来发起自动的搜索，一旦用户输入超过一段时间。这样的延迟给用户足够多的时间输入足够多的字符。</p>
<p>尽管它产生基于时间的通知，一个 timer 并不是一个实时的机制。跟 input source 一样，timers 是跟特定的 run loop modes 相关联的。如果一个 timer 不在 run loop 目前监听的 modes 中时，它会等待 run loop 跑在 timer 关联的 modes 时才 fire。同样，如果你一个 timer fire 了，但是 run loop 正在执行一个 handler 函数的过程中，timer 会等到 run loop 的下次迭代，再调用它的 handler 函数。如果 run loop 不运行了，timer 永远都不会 fire。</p>
<p>你更可以配置 timer 单次或重复的产生事件。一个重复的 timer 自动的基于调度的 fire time 来重新规划它的 fire 时间，而不是真正的 fire time。例如，一个 timer 规划在某个时刻和这个时刻之后的每 5 秒 fire，那么规划的 firing time 总会在原来的 5 秒间隔，即使真正的 firing time 被延迟了。如果 firing time 被延迟得超过了好几个规划的 firing times 的话，timer 对于错过的时间段只会 fire 一次。在为错过的时间 fire 之后，timer is rescheduled for the next scheduled firing time.</p>
<h4 id="Run-Loop-Observer"><a href="#Run-Loop-Observer" class="headerlink" title="Run Loop Observer"></a>Run Loop Observer</h4><p>相对于当异步或同步事件发生的时候 fire 的 sources，run loop observers 是 run loop 自身执行的特殊位置 fire。你可能使用 run loop observers 来准备好线程处理一个给定的事件，或准备好线程进入睡眠。你可以关联 run loop observers 到 run loop 的以下事件：</p>
<ul>
<li>进入 run loop</li>
<li>Run loop 准备开始处理一个 timer</li>
<li>Run loop 准备开始处理一个 input source</li>
<li>Run loop 准备进入睡眠状态</li>
<li>当 Run loop 被唤醒时，但在处理唤醒它的事件前</li>
<li>从 run loop 退出</li>
</ul>
<p>你可以使用 Core Foundation 添加 run loop observers。要创建一个 run loop observer，你可以创建一个 CFRunLoopObserverRef opaque type 的实例。这个类型持有你自定义的回调函数和你敢兴趣的行为的记录。</p>
<p>和 timers 相似，run-loop observers 可以被一次或重复的使用。一个一次的 observer 会在 fire 后从 run loop 移除，然而一个重复的 observer 会持续附着在 run loop 上。在创建它的时候你指定一个 observer 是否跑一次还是重复的跑。</p>
<h4 id="Run-Loop-事件的顺序"><a href="#Run-Loop-事件的顺序" class="headerlink" title="Run Loop 事件的顺序"></a>Run Loop 事件的顺序</h4><p>每次你跑 run loop，线程的 run loop 处理待处理的事件，给任 observers 产生通知。这些的顺序如下：</p>
<ol>
<li>通知 observers run loop 已经进入</li>
<li>通知 observers 任何 timers 准备 fire</li>
<li>通知 observers 任何不是基于 port 的 input source 准备 fire 了</li>
<li>Fire 任何非基于 port 准备好 fire 的 input sources</li>
<li>如果一个基于 port 的 input source 准备好并等待 fire 的话，立即处理事件，跳到步骤 9</li>
<li>通知 observers 线程将要睡眠</li>
<li>将线程置为睡眠状态，直到以下事件发生：<ul>
<li>一个给 port-based input source 的事件到达</li>
<li>一个 timer fires</li>
<li>给 run loop 设置的 timeout 值超时了</li>
<li>run loop 被显式的唤醒</li>
</ul>
</li>
<li>通知 observers 线程刚被唤醒</li>
<li>处理待处理的事件<ul>
<li>如果用户定义的 timer fired，处理 timer 事件并重启 loop。跳到步骤 2</li>
<li>如果一个 input source fired，处理 ( deliver 原文) 事件</li>
<li>如果 run loop 显示的被唤醒但是还没有 time out，重启 loop。跳到步骤2</li>
</ul>
</li>
<li>通知 observers run loop 已经退出</li>
</ol>
<p>因为 timer 和 input sources 的 observer 通知在事件发生之前被传递，可能在通知的时间和事件发生的时间之间有时间间隙。如果在这些事件之间的计时很重要的话，你可以使用 sleep 和 awake-from-sleep 通知来帮助纠正真实时间的计时。</p>
<p>因为 timers 和其他间隔事件是当你跑 run loop 的时候传递，绕过 run loop 会干扰这些事件的传递。这种行为发生的典型例子是你实现一个鼠标追踪的程序时，你的代码在进入 loop 中后，不断的重复的从应用中请求事件。因为你的应用直接拿取事件，而不是让应用正常的分发这些事件，active timers 将不能正常的 fire 直到你追踪鼠标的代码退出，并将控制返回给应用。</p>
<p>一个 run loop 可以显式的唤醒 run loop 对象。其它时间可能引起 run loop 被唤醒。例如，添加另一个不基于 port 的 input source 会唤醒 run loop，从而 input source 可以立即被处理，而不是等待直到其它的事件到达。</p>
<h4 id="什么时候使用一个-Run-Loop"><a href="#什么时候使用一个-Run-Loop" class="headerlink" title="什么时候使用一个 Run Loop"></a>什么时候使用一个 Run Loop</h4><p>唯一需要显式跑一个 run loop 的时候是你为你的应用创建非主线程的时候。应用主线程的 run loop 架构中的关键部分。结果是，app 框架提供了自动跑起主线程 run loop 的代码。UIApplication 的 run 方法启动了应用主线程的 run loop，作为应用启动的一部分。如果你使用 Xcode 模板项目来创建你的应用，你应该永远都不会显式调用这些函数。</p>
<p>对于非主线程，你需要决定一个 run loop 是否必要，如果是的，配置并启动它。你并不是总是需要启动线程的 run loop。例如，如果你使用一个线程执行一些长时间的具体任务，你可能会避免启动一个 run loop。Run loop 适用于你想要跟线程有更多交互的场景。例如，你需要启动一个 run loop如果你计划做以下事之一：</p>
<ul>
<li>使用 ports 或自定义 input sources 来与其它线程通讯</li>
<li>在线程上使用 timers</li>
<li>在 Cocoa 应用中使用任何 performSelector… 方法</li>
<li>维持住线程来进行间隔的任务</li>
</ul>
<p>如果你确定使用 run loop，配置和启动是很直接的。跟所有的多线程编程一样，你应该计划在合适的时机退出线程。干净的结束线程总是比暴力的终止线程好。</p>
<h4 id="使用-Run-Loop-对象"><a href="#使用-Run-Loop-对象" class="headerlink" title="使用 Run Loop 对象"></a>使用 Run Loop 对象</h4><p>一个 run loop 对象提供了添加 input sources，timers，和 run-loop observers 到你的 run loop，然后跑起它的接口。每个线程有一个 run loop 对象与之关联。在 Cocoa 中，这个对象是 NSRunLoop 类的实例。在应用的底层，它是一个指向 CFRunLoopRef opaque type 的实例。</p>
<h5 id="获取一个-Run-Loop-对象"><a href="#获取一个-Run-Loop-对象" class="headerlink" title="获取一个 Run Loop 对象"></a>获取一个 Run Loop 对象</h5><p>要获取当前线程的 run loop，你使用以下方法之一：</p>
<ul>
<li>在一个 Cocoa 应用中，使用 NSRunLoop 的 currentRunLoop 类方法获取 NSRunLoop 对象。</li>
<li>使用 CFRunLoopGetCurrent 函数</li>
</ul>
<p>尽管它们不是 toll-free bridged 类型，你可以从一个 NSRunLoop 对象中获得一个 CFRunLoopRef opaque type。NSRunLoop 类定义了一个 getCFRunLoop 方法返回一个 CFRunLoopRef 类型，你可以使用来传递给 Core Foundation 函数。这两个对象指向相同的对象，你可以根据需要混合的使用 NSRunLoop 对象和 CFRunLoopRef opage type.</p>
<h5 id="配置-Run-Loop"><a href="#配置-Run-Loop" class="headerlink" title="配置 Run Loop"></a>配置 Run Loop</h5><p>你在非主线程跑起一个 run loop 之前，你必须添加至少一个 input source 或 timer 到 run loop 上。如果一个 run loop 没有监听任何 sources，当你试着跑它的时候它会立马退出。怎么添加 input source 到 run loop， 请看后文。</p>
<p>除了安装 sources 外，你也可以安装 run loop observers，使用它们来检测 run loop 的不同执行阶段。要安装一个 run loop observer，你创建一个 CFRunLoopObserverRef opaque type，使用 CFRunLoopAddObserver 添加到 run loop 上。Run loop observers 必须要通过 Core Foundation 来创建，即使是 Cocoa 应用。</p>
<p>下例展示了线程的主函数，它添加一个 run loop observer 到它的 run loop。这个例子的目的是给你展示怎么创建一个 run loop observer 来监听 run loop 的行为。这些基本的 handler 函数只是简单的将 run loop 的行为打下 log。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)threadMain &#123;</span><br><span class="line">    <span class="comment">// The application uses garbage collection, so no autorelease pool is needed.</span></span><br><span class="line">    <span class="built_in">NSRunLoop</span>* myRunLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Create a run loop observer and attach it to the run loop.</span></span><br><span class="line">    <span class="built_in">CFRunLoopObserverContext</span> context = &#123;<span class="number">0</span>, <span class="keyword">self</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="built_in">CFRunLoopObserverRef</span> observer = <span class="built_in">CFRunLoopObserverCreate</span>(kCFAllocatorDefault, kCFRunLoopAllActivities, <span class="literal">YES</span>, <span class="number">0</span>, &amp;myRunLoopObserver, &amp;context);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (observer)  &#123;</span><br><span class="line">        <span class="built_in">CFRunLoopRef</span> cfLoop = [myRunLoop getCFRunLoop];</span><br><span class="line">        <span class="built_in">CFRunLoopAddObserver</span>(cfLoop, observer, kCFRunLoopDefaultMode);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Create and schedule the timer.</span></span><br><span class="line">    [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">0.1</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(doFireTimer:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">    <span class="built_in">NSInteger</span> loopCount = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// Run the run loop 10 times to let the timer fire.</span></span><br><span class="line">        [myRunLoop runUntilDate:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">1</span>]];</span><br><span class="line">        loopCount--;</span><br><span class="line">    &#125; <span class="keyword">while</span> (loopCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当给一个常驻的线程配置 run loop 的时候，至少添加一个 input source 来接受消息会更好。尽管只有一个 timer 附着在 run loop 上时，你可以可以进入 run loop，但是一旦 timers fires，通常它变为 invalidated，这会导致 run loop 退出。附着一个重复的 timer 可以保证你的 run loop 执行很长的一段时间，但会涉及到间隔性的 firing timer 来唤醒线程，本质上是另一种轮询的形式而已。对比下一个 input source 等待事件发生，保持线程 sleep 直到事件发生。</p>
<h5 id="启动-Run-Loop"><a href="#启动-Run-Loop" class="headerlink" title="启动 Run Loop"></a>启动 Run Loop</h5><p>启动一个 run loop 只对应用中的非主线程是必须的。一个 run loop 必须有一个 input source 或 timer 来监听。如果没有一个附着，run loop 会立即退出。</p>
<p>有几种方式启动 run loop，如下：</p>
<ul>
<li>无条件的</li>
<li>设置一个 time out</li>
<li>进入一个指定的 mode</li>
</ul>
<p>unconditionally 进入 run loop 是最简单的选项，但也是你最不想用的。无条件的跑你的 run loop 会使线程进入永久的循环，给你很少对 run loop 自身的控制。你可以添加和移除 input sources 和 timers，但是停止 run loop 的唯一方式是杀掉它。同样也没有方式将 run loop 跑再自定义的 mode。</p>
<p>与其 unconditionally 的跑一个 run loop，设置一个 timeout 来跑 run loop 会更好。当你使用一个 timeout 值时，run loop 在事件到来或被分配的时间过期之前一直跑。如果事件到来，事件被分发给 handler 处理，然后 run loop 退出。你的代码可能重新启动 run loop 来处理下一个事件。如果被分配的时间过期了，你可以简单的重启 run loop 或是用这个时间值做些必须的记录。</p>
<p>除了设置 timeout 外，你也可以在指定的 mode 来跑 run loop。 Modes 和 timeout 值并不相互排斥，可以同时使用来跑一个 run loop。Modes 限定了传递事件给 run loop 的 sources 类型。</p>
<p>下例展示了一个线程入口函数的基本结构。例子的关键部分展示 run loop 的基本结构。本质上，你添加 input sources 和 timers 到 run loop，然后重复调用一个 run loop 的函数之一来启动 run loop。每次 run loop 函数返回的时候，你检查条件是否满足退出线程。例子使用 Core Foundation run loop 函数以便检查返回值，决定 run loop 为什么退出。如果你用 Cocoa 且不需要检查返回值的话你也可以使用 NSRunLoop 的类似的方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)skeletonThreadMain &#123;</span><br><span class="line">    <span class="comment">// Set up an autorelease pool here if not using garbage collection.</span></span><br><span class="line">    <span class="built_in">BOOL</span> done = <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Add your sources or timers to the run loop and do any other setup.</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// Start the run loop but return after each source is handled.</span></span><br><span class="line">        SInt32    result = <span class="built_in">CFRunLoopRunInMode</span>(kCFRunLoopDefaultMode, <span class="number">10</span>, <span class="literal">YES</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// If a source explicitly stopped the run loop, or if there are no</span></span><br><span class="line">        <span class="comment">// sources or timers, go ahead and exit.</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ((result == kCFRunLoopRunStopped) || (result == kCFRunLoopRunFinished)) &#123;</span><br><span class="line">            done = <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Check for any other exit conditions here and set the</span></span><br><span class="line">        <span class="comment">// done variable as needed.</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!done);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Clean up code here. Be sure to release any allocated autorelease pools.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以嵌套的 run 一个 run loop。也就是说，你可以从 input source 或 timer 的 handler 函数中调用 CFRunLoopRun，CFRunLoopRunInMode，或任何 NSRunLoop 的跑 run loop 的方法。当你这么做的时候，你可以使用任何 mode 来跑嵌套的 run loop，包括被外围 run loop 使用的 mode。</p>
<h5 id="退出-Run-Loop"><a href="#退出-Run-Loop" class="headerlink" title="退出 Run Loop"></a>退出 Run Loop</h5><p>在 run loop 处理一个事件前，有两种方式来是一个 run loop 退出:</p>
<ul>
<li>使用一个 timeout 值来配置 run loop</li>
<li>告诉 run loop 停止</li>
</ul>
<p>使用一个 timeout 的值当然更受偏好，如果你可以管理 run loop 的话。指定一个 timeout 的值使得 run loop 完成它所有的正常处理流程，包括在退出前传递通知到 run loop observers。</p>
<p>使用 CFRunLoopStop 函数显式停止 run loop 产生与 timeout 值相似的结果。run loop 发送出任何剩余的 run-loop notifications 然后退出。不同点是你可以使用这个在那些你 unconditionally 启动的 run loop 上。</p>
<p>尽管移除一个 run loop 的 input sources 和 timers 同样可能使得一个 run loop 退出，但这不是一个可靠的方式停止一个 run loop。一些系统函数添加 input source 到 run loop 来处理所需的事件。因为你的代码可能不知道这些 input sources，这样将不能移除它们，这也就阻止了 run loop 退出。</p>
<h5 id="线程安全和-Run-Loop-对象"><a href="#线程安全和-Run-Loop-对象" class="headerlink" title="线程安全和 Run Loop 对象"></a>线程安全和 Run Loop 对象</h5><p>线程安全依赖于你使用哪个 API 来操作你的 run loop。在 Core Foundation 中的函数通常是线程安全的，可以从任何线程中调用。然而如果你进行改变 run loop 配置的操作，在那些拥有 run loop 的线程上仍然是更推从的。</p>
<p>Cocoa NSRunLoop 类本身不是线程安全的。如果你使用 NSNunLoop 类来修改你的 run loop，你应该在拥有 run loop 的线程上做。添加 input source 或 timer 到一个属于另一个线程的 run loop 可能导致你的应用奔溃或有异常行为。</p>
<h4 id="配置-Run-Loop-Sources"><a href="#配置-Run-Loop-Sources" class="headerlink" title="配置 Run Loop Sources"></a>配置 Run Loop Sources</h4><p>下面的部分介绍了在 Cocoa 和 Core Foundation 中怎么配置不同类型的 input source。</p>
<h5 id="定义一个自定义-Input-Source"><a href="#定义一个自定义-Input-Source" class="headerlink" title="定义一个自定义 Input Source"></a>定义一个自定义 Input Source</h5><p>创建一个自定义 input source 涉及定义以下：</p>
<ul>
<li>你想要你的 input source 处理的信息</li>
<li>一个 scheduler routine 让感兴趣的客户知道怎样联系你的 input source</li>
<li>一个处理用户发送的 perform request 的 handler</li>
<li>一个 cancellation 函数 invalidate 你的 input source</li>
</ul>
<p>因为你创建一个自定义 input source 来处理自定义信息，真正的配置被设计得很灵活。scheduler，handler，cancellation handler 函数你创建自定义 input source 必须的关键函数。然后 input source 的部分其它行为发生这些函数之外。例如由你定义传送数据到 input source 的机制，和通知其它线程你的 input source 的存在。</p>
<p>下例展示了一个自定义 input source 的样例配置。在这个例子中，应用的主线程保持了这个 input source 的引用，给 input source 自定义的 command buffer，和 input source 被安装在哪个 run loop。当主线程有任务交付给 work 线程时，它发送一个 command 到 command buffer，command 包含 worker 线程开始工作所需的信息。(因为主线程和 worker 线程的 input source 都有 command buffer 的访问权限，它们的访问必须同步) 一旦 command 被发送，主线程给 input source 发送信号，唤醒 worker 线程的 run loop。一旦收到唤醒的命令，run loop 为 input source 调用 handler，处理 command buffer 中的 command。</p>
<p><img src="/images/custom-input-source.png" alt="image"></p>
<p>下面的部分解释了上图种的自定义 input source 的实现，展示了你需要实现的核心代码。</p>
<h5 id="定义-Input-Source"><a href="#定义-Input-Source" class="headerlink" title="定义 Input Source"></a>定义 Input Source</h5><p>定义一个自定义 input source 需要使用 Core Foundation 函数来配置你的 run loop source，并把它附着到 run loop。尽管基本的 handlers 是基于 C 的函数，但这并不阻止你使用 Objective-C 或 C++ 实现这些函数的 wrappers。</p>
<p>上图中的 input source 使用 Objective-C 对象来管理一个 command buffer，和协调 run loop。下面的代码展示了这个对象的定义。RunLoopSource 对象管理一个 command buffer 和使用 buffer 来从其它线程接受消息。代码也展示了 RunLoopContext 对象的定义，这个对象只是一个 container 对象，使用来传递 RunLoopSource 对象和一个 run loop 引用到应用的主线程。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RunLoopSource</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="built_in">CFRunLoopSourceRef</span> runLoopSource;</span><br><span class="line">    <span class="built_in">NSMutableArray</span>* commands;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)init;</span><br><span class="line">- (<span class="keyword">void</span>)addToCurrentRunLoop;</span><br><span class="line">- (<span class="keyword">void</span>)invalidate;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handler method</span></span><br><span class="line">- (<span class="keyword">void</span>)sourceFired;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Client interface for registering commands to process</span></span><br><span class="line">- (<span class="keyword">void</span>)addCommand:(<span class="built_in">NSInteger</span>)command withData:(<span class="keyword">id</span>)data;</span><br><span class="line">- (<span class="keyword">void</span>)fireAllCommandsOnRunLoop:(<span class="built_in">CFRunLoopRef</span>)runloop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// These are the CFRunLoopSourceRef callback functions.</span></span><br><span class="line"><span class="keyword">void</span> RunLoopSourceScheduleRoutine (<span class="keyword">void</span> *info, <span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFStringRef</span> mode);</span><br><span class="line"><span class="keyword">void</span> RunLoopSourcePerformRoutine (<span class="keyword">void</span> *info);</span><br><span class="line"><span class="keyword">void</span> RunLoopSourceCancelRoutine (<span class="keyword">void</span> *info, <span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFStringRef</span> mode);</span><br><span class="line"></span><br><span class="line"><span class="comment">// RunLoopContext is a container object used during registration of the input source.</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RunLoopContext</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="built_in">CFRunLoopRef</span>        runLoop;</span><br><span class="line">    RunLoopSource*        source;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">CFRunLoopRef</span> runLoop;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) RunLoopSource* source;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)initWithSource:(RunLoopSource*)src andLoop:(<span class="built_in">CFRunLoopRef</span>)loop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>尽管 Objective-C 代码管理 input source 的自定义数据，但将 input source 附着到一个 run loop 需要基于 C 的函数回调。当你添加 run loop source 到 run loop 时，这些函数中的第一个被调用。因为这个 input source 只有一个 client (主线程)，它使用 scheduler 函数使用主线程上的 application delegate 发送一个消息来注册自己。当 application delegate 想要与 input source 通讯的时候，它使用 RunLoopContext 对象中的信息来达到母的。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> RunLoopSourceScheduleRoutine (<span class="keyword">void</span> *info, <span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFStringRef</span> mode) &#123;</span><br><span class="line">    RunLoopSource* obj = (RunLoopSource*)info;</span><br><span class="line">    AppDelegate*   del = [AppDelegate sharedAppDelegate];</span><br><span class="line">    RunLoopContext* theContext = [[RunLoopContext alloc] initWithSource:obj andLoop:rl];</span><br><span class="line">    [del performSelectorOnMainThread:<span class="keyword">@selector</span>(registerSource:) withObject:theContext waitUntilDone:<span class="literal">NO</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最重要的回调函数之一是当你的 input source 被发送信号，用来处理自定义数据的那个。下例展示了与 RunLoopSource 对象关联的进行回调函数。这个函数简单的转发做相关工作的请求到 sourceFired 方法，然后处理任何在 command buffer 中的 command。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> RunLoopSourcePerformRoutine (<span class="keyword">void</span> *info) &#123;</span><br><span class="line">    RunLoopSource*  obj = (RunLoopSource*)info;</span><br><span class="line">    [obj sourceFired];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你有需要从 run loop 移除你的 input source 的话，使用 CFRunLoopSourceInvalidate 函数，系统调用你的 input source 的 cancellation 函数。你可以使用这个函数通知 input source 的使用者你的 input source 不再是 valid，并应该移除任何 input source 的引用。下例中展示 cancellation 回调函数。这个函数给 application delegate 发送另一个 RunLoopContext 对象，但是这次要求 delegate 移除这个 run loop source 的引用</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> RunLoopSourceCancelRoutine (<span class="keyword">void</span> *info, <span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFStringRef</span> mode) &#123;</span><br><span class="line">    RunLoopSource* obj = (RunLoopSource*)info;</span><br><span class="line">    AppDelegate* del = [AppDelegate sharedAppDelegate];</span><br><span class="line">    RunLoopContext* theContext = [[RunLoopContext alloc] initWithSource:obj andLoop:rl];</span><br><span class="line">    </span><br><span class="line">    [del performSelectorOnMainThread:<span class="keyword">@selector</span>(removeSource:) withObject:theContext waitUntilDone:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="安装-Input-Source-到-Run-Loop"><a href="#安装-Input-Source-到-Run-Loop" class="headerlink" title="安装 Input Source 到 Run Loop"></a>安装 Input Source 到 Run Loop</h5><p>下例展示了 RunLoopSource 的 init 和 addToCurrentRunLoop 方法。 init 方法创建真实被添加到 run loop 的 CFRunLoopSourceRef opaque type。init 方法中它将自身传递给 contextual information，以便回调函数有指向它的指针。 input source 的安装直到 worker 线程调用 addToCurrentRunLoop 方法，在这时 RunLoopSourceScheduleRoutine 回调函数被调用。一旦 input source 被添加到 run loop，跑起 run loop 的线程进入等待。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)init</span><br><span class="line">    <span class="built_in">CFRunLoopSourceContext</span></span><br><span class="line">context = &#123;<span class="number">0</span>, <span class="keyword">self</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">                &amp;RunLoopSourceScheduleRoutine,</span><br><span class="line">                RunLoopSourceCancelRoutine,</span><br><span class="line">                RunLoopSourcePerformRoutine&#125;;</span><br><span class="line">    runLoopSource = <span class="built_in">CFRunLoopSourceCreate</span>(<span class="literal">NULL</span>, <span class="number">0</span>, &amp;context);</span><br><span class="line">    commands = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addToCurrentRunLoop &#123;</span><br><span class="line">    <span class="built_in">CFRunLoopRef</span> runLoop = <span class="built_in">CFRunLoopGetCurrent</span>();</span><br><span class="line">    <span class="built_in">CFRunLoopAddSource</span>(runLoop, runLoopSource, kCFRunLoopDefaultMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Input-Source-的-Clients-间的协调"><a href="#Input-Source-的-Clients-间的协调" class="headerlink" title="Input Source 的 Clients 间的协调"></a>Input Source 的 Clients 间的协调</h5><p>为了你的 input source 是有用的，你需要从另外的线程操作它并给它发送信号。input source 的整个作用是使他关联的线程睡眠到有事可做。这样的话，让应用中其它的线程知道你的 input source 并有一种与之通讯的方式下显得很有必要。</p>
<p>一种通知 input source 用户的方式是当 input source 一开始添加到 run loop 的时候，发出注册信息。你可以注册任意多 clients，或者简单的到中心代理那里注册下，由代理向 input source 的 clients 提供它。下例中展示了由 application delegate 定义的注册方法。由 RunLoopSource 对象的 scheduler 函数调用。这个方法收到一个由 RunLoopSource 提供的 RunLoopContext 对象。下例也展示了当 input source 从 run loop 移除时用来取消注册的方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)registerSource:(RunLoopContext*)sourceInfo &#123;</span><br><span class="line">    [sourcesToPing addObject:sourceInfo];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeSource:(RunLoopContext*)sourceInfo &#123;</span><br><span class="line">    <span class="keyword">id</span>    objToRemove = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (RunLoopContext* context <span class="keyword">in</span> sourcesToPing) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([context isEqual:sourceInfo]) &#123;</span><br><span class="line">            objToRemove = context;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (objToRemove) &#123;</span><br><span class="line">        [sourcesToPing removeObject:objToRemove];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="给-Input-Source-发送信号"><a href="#给-Input-Source-发送信号" class="headerlink" title="给 Input Source 发送信号"></a>给 Input Source 发送信号</h5><p>在给 input source 传送数据后，一个 client 需要给 input source 发送信号，唤醒它的 run loop。给 input source 发送信号使得 run loop 知道 input source 准备好被处理。因为信号发生的时候线程是睡眠的，你总是应该显式唤醒 run loop。如果没这么做的话会导致处理 input source 的延迟。</p>
<p>下例中展示了 RunLoopSource 对象的 fireCommandsOnRunLoop。当 clients 已经准备好 input source 来处理它们添加到 command buffer 的 commands 的时候它们调用这个方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)fireCommandsOnRunLoop:(<span class="built_in">CFRunLoopRef</span>)runloop &#123;</span><br><span class="line">    <span class="built_in">CFRunLoopSourceSignal</span>(runLoopSource);</span><br><span class="line">    <span class="built_in">CFRunLoopWakeUp</span>(runloop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意: 你永远不应该通过给一个自定义的 input source 发送信号来处理 SIGHUP 或其它进程级别的信号。Core Foundation 唤醒 run loop 的函数并不是 signal 安全的，不应该在应用的 signal handler 函数中使用。关于 signal handler 函数更多的信息，可以参见 sigaction man page。</p>
</blockquote>
<h4 id="配置-Timer-Sources"><a href="#配置-Timer-Sources" class="headerlink" title="配置 Timer Sources"></a>配置 Timer Sources</h4><p>创建一个 timer source，所有你需要做的是创建一个 timer 对象，然后在 run loop 上 schedule 它。在 Cocoa 中，使用 NSTimer 类来创建新的 timer 对象，在 Core Foundation 中，你使用 CFRunLoopTimerRef opaque type。NSTimer 的内部只是一个 Core Foundation 的简单扩展，提供了一些易用的特性，像使用一个方法创建和 schedule 一个 timer。</p>
<p>在 Cocoa 中，你可以同时创建和 schedule 使用以下任一方法：</p>
<ul>
<li>scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:</li>
<li>scheduledTimerWithTimeInterval:invocation:repeats:</li>
</ul>
<p>这些方法创建一个 timer 并添加它们到当前线程的 run loop，与 default mode 关联。你也可以手动 schedule 一个 timer 如果你想通过创建你的 NSTimer 对象，然后使用 NSRunLoop 的 addTimer:forMode: 方法。两种技术基本上做的是同样的事情，但是给了你不同层面配置 timer 的选择。例如，如果你创建一个 timer，并手动的添加到 run loop，你可以使用一个非 default 的一个 mode。下例展示怎么使用两种技术创建 timer。第一个 timer 延迟 1s 后每隔 0.1s fire。第二个 timer 初始延迟 0.2s 后每隔 0.2s fire。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSRunLoop</span>* myRunLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create and schedule the first timer.</span></span><br><span class="line"><span class="built_in">NSDate</span>* futureDate = [<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">1.0</span>];</span><br><span class="line"><span class="built_in">NSTimer</span>* myTimer = [[<span class="built_in">NSTimer</span> alloc] initWithFireDate:futureDate interval:<span class="number">0.1</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(myDoFireTimer1:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];  </span><br><span class="line">[myRunLoop addTimer:myTimer forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create and schedule the second timer.</span></span><br><span class="line">[<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">0.2</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(myDoFireTimer2:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure>

<p>接下来看看怎么使用 Core Foundation 来配置一个 timer。尽管这个例子并没有在 context structur 中传递任何用户定义的信息，你可以使用这个结构来传递你的 timer 所需的任何自定义数据。更多的信息可以参见 <em>CFRunLoopTimer reference.</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFRunLoopRef</span> runLoop = <span class="built_in">CFRunLoopGetCurrent</span>();</span><br><span class="line"><span class="built_in">CFRunLoopTimerContext</span> context = &#123;<span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line"><span class="built_in">CFRunLoopTimerRef</span> timer = <span class="built_in">CFRunLoopTimerCreate</span>(kCFAllocatorDefault, <span class="number">0.1</span>, <span class="number">0.3</span>, <span class="number">0</span>, <span class="number">0</span>, &amp;myCFTimerCallback, &amp;context);</span><br><span class="line"><span class="built_in">CFRunLoopAddTimer</span>(runLoop, timer, kCFRunLoopCommonModes);</span><br></pre></td></tr></table></figure>

<h4 id="配置一个基于-Port-的-Input-Source"><a href="#配置一个基于-Port-的-Input-Source" class="headerlink" title="配置一个基于 Port 的 Input Source"></a>配置一个基于 Port 的 Input Source</h4><p>Cocoa 和 Core Foundation 都提供了基于 port 的对象来支持线程或进程间的通讯。下面的部分将给你展示怎么使用不同类型的 port 设置 port 通讯。</p>
<h5 id="配置一个-NSMachPort-对象"><a href="#配置一个-NSMachPort-对象" class="headerlink" title="配置一个 NSMachPort 对象"></a>配置一个 NSMachPort 对象</h5><p>为了使用 NSMachPort 对象建立一个本地连接，你创建一个 port 对象，添加它到线程的 run loop 上，当你启动你的非主线程的时候，传递同样的对象给你线程的入口函数。副线程使用同样的对象给你的主线程发送消息。</p>
<p><strong>实现主线程的代码</strong></p>
<p>下面的代码展示了主线程起一个非主线程作为 worker 线程。因为 Cocoa 框架进行许多配置 port 和 run loop 的中间步骤，launchThread 方法要比使用 Core Foundation 实现同样的功能要短很多。Core Foundation 的实现传递 local port 的名字给 worker 线程，而 Cocoa 传递一个 NSPort 对象。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)launchThread &#123;</span><br><span class="line">    <span class="built_in">NSPort</span>* myPort = [<span class="built_in">NSMachPort</span> port];</span><br><span class="line">    <span class="keyword">if</span> (myPort) &#123;</span><br><span class="line">        <span class="comment">// This class handles incoming port messages.</span></span><br><span class="line">        [myPort setDelegate:<span class="keyword">self</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Install the port as an input source on the current run loop.</span></span><br><span class="line">        [[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:myPort forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Detach the thread. Let the worker release the port.</span></span><br><span class="line">        [<span class="built_in">NSThread</span> detachNewThreadSelector:<span class="keyword">@selector</span>(LaunchThreadWithPort:) toTarget:[MyWorkerClass <span class="keyword">class</span>] withObject:myPort];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了设置成线程间双向的通讯，你也许想要 worker 线程在 check-in 的消息中把它自己的 local port 告诉主线程。收到 check-in 消息让主线程知道在启动 worker 线程的过程中一切正常，同时也给了一种方式发送进一步的消息给 worker 线程。</p>
<p>下面的代码展示了主线程的 handlePortMessage: 方法。这个方法当有数据到达线程自己的 local port 时被调用。当一个 check-in 消息到达的时候，方法直接从 port message 中获取 worker 线程的 port，然后本地保存。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> kCheckinMessage 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Handle responses from the worker thread.</span></span><br><span class="line">- (<span class="keyword">void</span>)handlePortMessage:(<span class="built_in">NSPortMessage</span> *)portMessage &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> message = [portMessage msgid];</span><br><span class="line">    <span class="built_in">NSPort</span>* distantPort = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (message == kCheckinMessage) &#123;</span><br><span class="line">        <span class="comment">// Get the worker thread’s communications port.</span></span><br><span class="line">        distantPort = [portMessage sendPort];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Retain and save the worker port for later use.</span></span><br><span class="line">        [<span class="keyword">self</span> storeDistantPort:distantPort];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Handle other messages.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实现非主线程代码</strong></p>
<p>对于非主线程，你必须配置它使用指定的 port 来传回信息给主线程。</p>
<p>下面展示了设置 worker 线程的代码。给线程创建了 autorelease pool 后，接着创建了一个 worker 对象来驱动线程的执行。worker 对象的 sendCheckinMessage: 方法给 worker 线程创建一个 local port 和发送一个 check-in 消息回主线程。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+(<span class="keyword">void</span>)LaunchThreadWithPort:(<span class="keyword">id</span>)inData &#123;</span><br><span class="line">    <span class="built_in">NSAutoreleasePool</span>*  pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Set up the connection between this thread and the main thread.</span></span><br><span class="line">    <span class="built_in">NSPort</span>* distantPort = (<span class="built_in">NSPort</span>*)inData;</span><br><span class="line">    </span><br><span class="line">    MyWorkerClass*  workerObj = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    [workerObj sendCheckinMessage:distantPort];</span><br><span class="line">    [workerObj sendCheckinMessage:distantPort];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Let the run loop process things.</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        [[<span class="built_in">NSRunLoop</span> currentRunLoop] runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br><span class="line">    &#125; <span class="keyword">while</span> (![workerObj shouldExit]);</span><br><span class="line">    </span><br><span class="line">    [workerObj release];</span><br><span class="line">    [workerObj release];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当使用 NSMachPort 时，local 和 remote 线程可以使用同一个 port 对象来进行线程间的单向通讯。也就是说，一个线程创建的 local port 成了其它线程的 remote port。</p>
<p>下面的代码展示了 worker 线程的 check-in 函数。这个方法设置好用于未来通讯的 local port，然后发送一个 check-in 的消息回主线程。发送使用 LaunchThreadWithPort: 函数收到的 port 对象作为消息的目标。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Worker thread check-in method</span></span><br><span class="line">- (<span class="keyword">void</span>)sendCheckinMessage:(<span class="built_in">NSPort</span>*)outPort &#123;</span><br><span class="line">    <span class="comment">// Retain and save the remote port for future use.</span></span><br><span class="line">    [<span class="keyword">self</span> setRemotePort:outPort];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Create and configure the worker thread port.</span></span><br><span class="line">     <span class="built_in">NSPort</span>* myPort = [<span class="built_in">NSMachPort</span> port];</span><br><span class="line">     [myPort setDelegate:<span class="keyword">self</span>];</span><br><span class="line">     [[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:myPort forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// Create the check-in message.</span></span><br><span class="line">     <span class="built_in">NSPortMessage</span>* messageObj = [[<span class="built_in">NSPortMessage</span> alloc] initWithSendPort:outPort receivePort:myPort components:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">if</span> (messageObj) &#123;</span><br><span class="line">        <span class="comment">// Finish configuring the message and send it immediately.</span></span><br><span class="line">        [messageObj setMsgId:setMsgid:kCheckinMessage];</span><br><span class="line">        [messageObj sendBeforeDate:[<span class="built_in">NSDate</span> date]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="配置一个-NSMessagePort-对象"><a href="#配置一个-NSMessagePort-对象" class="headerlink" title="配置一个 NSMessagePort 对象"></a>配置一个 NSMessagePort 对象</h5><p>要使用一个 NSMessagePort 对象创建一个本地连接，你不能简单的在线程间传递 port 对象。Remote message ports 必须通过名字来获得。在 Cocoa 中为了可能通过名字获得 message port，需要使用指定的名称注册你的 local port，然后传递给想获取合适的 port 对象进行的通讯的 remote 线程。下面的代码展示了在你想要使用 message ports 时创建和注册 port 的过程。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSPort</span>* localPort = [[<span class="built_in">NSMessagePort</span> alloc] init];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configure the object and add it to the current run loop.</span></span><br><span class="line">[localPort setDelegate:<span class="keyword">self</span>];</span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:localPort forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register the port using a specific name. The name must be unique.</span></span><br><span class="line"><span class="built_in">NSString</span>* localPortName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;MyPortName&quot;</span>];</span><br><span class="line">[[<span class="built_in">NSMessagePortNameServer</span> sharedInstance] registerPort:localPort name:localPortName];</span><br></pre></td></tr></table></figure>

<h5 id="在-Core-Foundation-中配置一个基于-Port-的-Input-Source"><a href="#在-Core-Foundation-中配置一个基于-Port-的-Input-Source" class="headerlink" title="在 Core Foundation 中配置一个基于 Port 的 Input Source"></a>在 Core Foundation 中配置一个基于 Port 的 Input Source</h5><p>这部分展示了怎么使用 Core Foundation 在应用的主线程和一个 worker 线程间设置一个双向的通讯通道。</p>
<p>下面的代码被应用的主线程调用来启动一个 worker 线程。代码做的第一件事是设置一个 CFMessagePortRef opaque type 来监听 worker 线程发送过来的消息。worker 线程需要 port 的名字来建立连接，所以名字字符串被传递给 worker 线程的入口函数。Port names 应该在当前用户的上下中是唯一的，不然你可能会遇到冲突。</p>
<p>首先添加 Core Foundation Message Port 到一个线程</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> kThreadStackSize (8 *4096)</span></span><br><span class="line"></span><br><span class="line">OSStatus MySpawnThread() &#123;</span><br><span class="line">    <span class="comment">// Create a local port for receiving responses.</span></span><br><span class="line">    <span class="built_in">CFStringRef</span> myPortName;</span><br><span class="line">    <span class="built_in">CFMessagePortRef</span> myPort;</span><br><span class="line">    <span class="built_in">CFRunLoopSourceRef</span> rlSource;</span><br><span class="line">    <span class="built_in">CFMessagePortContext</span> context = &#123;<span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    Boolean shouldFreeInfo;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Create a string with the port name.</span></span><br><span class="line">    myPortName = <span class="built_in">CFStringCreateWithFormat</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="built_in">CFSTR</span>(<span class="string">&quot;com.myapp.MainThread&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Create the port.</span></span><br><span class="line">    myPort = <span class="built_in">CFMessagePortCreateLocal</span>(<span class="literal">NULL</span>, myPortName, &amp;MainThreadResponseHandler, &amp;context, &amp;shouldFreeInfo);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (myPort != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// The port was successfully created.</span></span><br><span class="line">        <span class="comment">// Now create a run loop source for it.</span></span><br><span class="line">        </span><br><span class="line">        rlSource = <span class="built_in">CFMessagePortCreateRunLoopSource</span>(<span class="literal">NULL</span>, myPort, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (rlSource) &#123;</span><br><span class="line">            <span class="comment">// Add the source to the current run loop.</span></span><br><span class="line">            <span class="built_in">CFRunLoopAddSource</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), rlSource, kCFRunLoopDefaultMode);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Once installed, these can be freed.</span></span><br><span class="line">            <span class="built_in">CFRelease</span>(myPort);</span><br><span class="line">            <span class="built_in">CFRelease</span>(rlSource);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Create the thread and continue processing.</span></span><br><span class="line">    <span class="built_in">MPTaskID</span>        taskID;</span><br><span class="line">    <span class="keyword">return</span>(<span class="built_in">MPCreateTask</span>(&amp;ServerThreadEntryPoint, (<span class="keyword">void</span>*)myPortName, kThreadStackSize, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;taskID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>port 被安装和线程启动后，主线程在等待 check-in 消息时可以继续正常的执行。当 check-in 消息到达的时候，它被分发给主线程的 MainThreadResponseHandler 函数。函数代码如下，它取出给 work 线程的 port 名字，创建一个 conduit 以便将来通讯。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> kCheckinMessage 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Main thread port message handler</span></span><br><span class="line"><span class="built_in">CFDataRef</span> MainThreadResponseHandler(<span class="built_in">CFMessagePortRef</span> local, SInt32 msgid, <span class="built_in">CFDataRef</span> data, <span class="keyword">void</span>* info) &#123;</span><br><span class="line">    <span class="keyword">if</span> (msgid == kCheckinMessage) &#123;</span><br><span class="line">        <span class="built_in">CFMessagePortRef</span> messagePort;</span><br><span class="line">        <span class="built_in">CFStringRef</span> threadPortName;</span><br><span class="line">        <span class="built_in">CFIndex</span> bufferLength = <span class="built_in">CFDataGetLength</span>(data);</span><br><span class="line">        <span class="built_in">UInt8</span>* buffer = <span class="built_in">CFAllocatorAllocate</span>(<span class="literal">NULL</span>, bufferLength, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CFDataGetBytes</span>(data, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, bufferLength), buffer);</span><br><span class="line">        threadPortName = <span class="built_in">CFStringCreateWithBytes</span> (<span class="literal">NULL</span>, buffer, bufferLength,  kCFStringEncodingASCII, <span class="literal">FALSE</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// You must obtain a remote message port by name.</span></span><br><span class="line">        messagePort = <span class="built_in">CFMessagePortCreateRemote</span>(<span class="literal">NULL</span>, (<span class="built_in">CFStringRef</span>)threadPortName);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (messagePort) &#123;</span><br><span class="line">            <span class="comment">// Retain and save the thread’s comm port for future reference.</span></span><br><span class="line">            AddPortToListOfActiveThreads(messagePort);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Since the port is retained by the previous function, release it here</span></span><br><span class="line">            <span class="built_in">CFRelease</span>(messagePort);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Clean up.</span></span><br><span class="line">        <span class="built_in">CFRelease</span>(threadPortName);</span><br><span class="line">        <span class="built_in">CFAllocatorDeallocate</span>(<span class="literal">NULL</span>, buffer);</span><br><span class="line">    &#125;  <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Process other messages.</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主线程配置好后，剩下的唯一需要做的是给新建的线程创建它自己的 port 和 check in。下面的代码展示了 worker 线程的入口函数。函数取出主线程的 port 名称，是用来创建一个创建一个 remote 连接回主线程。然后然后给自己创建一个 local port，安装 port 到线程的 run loop 上，发送 check-in 包含 local port 的消息回主线程。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">OSStatus ServerThreadEntryPoint(<span class="keyword">void</span>* param) &#123;</span><br><span class="line">    <span class="comment">// Create the remote port to the main thread.</span></span><br><span class="line">    <span class="built_in">CFMessagePortRef</span> mainThreadPort;</span><br><span class="line">    <span class="built_in">CFStringRef</span> portName = (<span class="built_in">CFStringRef</span>)param;</span><br><span class="line">    </span><br><span class="line">    mainThreadPort = <span class="built_in">CFMessagePortCreateRemote</span>(<span class="literal">NULL</span>, portName);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Free the string that was passed in param.</span></span><br><span class="line">    <span class="built_in">CFRelease</span>(portName);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Create a port for the worker thread.</span></span><br><span class="line">    <span class="built_in">CFStringRef</span> myPortName = <span class="built_in">CFStringCreateWithFormat</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="built_in">CFSTR</span>(<span class="string">&quot;com.MyApp.Thread-%d&quot;</span>), <span class="built_in">MPCurrentTaskID</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Store the port in this thread’s context info for later reference.</span></span><br><span class="line">    <span class="built_in">CFMessagePortContext</span> context = &#123;<span class="number">0</span>, mainThreadPort, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    Boolean shouldFreeInfo;</span><br><span class="line">    Boolean shouldAbort = <span class="literal">TRUE</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CFMessagePortRef</span> myPort = <span class="built_in">CFMessagePortCreateLocal</span>(<span class="literal">NULL</span>, myPortName, &amp;ProcessClientRequest, &amp;context, &amp;shouldFreeInfo);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (shouldFreeInfo) &#123;</span><br><span class="line">        <span class="comment">// Couldn&#x27;t create a local port, so kill the thread.</span></span><br><span class="line">        <span class="built_in">MPExit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CFRunLoopSourceRef</span> rlSource = <span class="built_in">CFMessagePortCreateRunLoopSource</span>(<span class="literal">NULL</span>, myPort,</span><br><span class="line">    <span class="keyword">if</span> (!rlSource) &#123;</span><br><span class="line">        <span class="comment">// Couldn&#x27;t create a local port, so kill the thread.</span></span><br><span class="line">        <span class="built_in">MPExit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Add the source to the current run loop.</span></span><br><span class="line">    <span class="built_in">CFRunLoopAddSource</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), rlSource, kCFRunLoopDefaultMode);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Once installed, these can be freed.</span></span><br><span class="line">    <span class="built_in">CFRelease</span>(myPort);</span><br><span class="line">    <span class="built_in">CFRelease</span>(rlSource);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Package up the port name and send the check-in message.</span></span><br><span class="line">    <span class="built_in">CFDataRef</span> returnData = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">CFDataRef</span> outData;</span><br><span class="line">    <span class="built_in">CFIndex</span> stringLength = <span class="built_in">CFStringGetLength</span>(myPortName);</span><br><span class="line">    <span class="built_in">UInt8</span>* buffer = <span class="built_in">CFAllocatorAllocate</span>(<span class="literal">NULL</span>, stringLength, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CFStringGetBytes</span>(myPortName, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>,stringLength),</span><br><span class="line">    kCFStringEncodingASCII, <span class="number">0</span>, <span class="literal">FALSE</span>, buffer, stringLength, <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">    outData = <span class="built_in">CFDataCreate</span>(<span class="literal">NULL</span>, buffer, stringLength);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">CFMessagePortSendRequest</span>(mainThreadPort, kCheckinMessage, outData, <span class="number">0.1</span>, <span class="number">0.0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Clean up thread data structures.</span></span><br><span class="line">    <span class="built_in">CFRelease</span>(outData);</span><br><span class="line">    <span class="built_in">CFAllocatorDeallocate</span>(<span class="literal">NULL</span>, buffer);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Enter the run loop.</span></span><br><span class="line">    <span class="built_in">CFRunLoopRun</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer>
      
        
  
  <div class="categories">
    <a href="/categories/iOS/">iOS</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/iOS/">iOS</a>, <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a>, <a href="/tags/RunLoop/">RunLoop</a>, <a href="/tags/%E7%BF%BB%E8%AF%91/">翻译</a>
  </div>

        
  <div class="addthis addthis_toolbox addthis_default_style">
    
      <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
      <a class="addthis_button_pinterest_pinit" pi:pinit:layout="horizontal"></a>
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script src="//s7.addthis.com/js/300/addthis_widget.js"></script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h1 class="title">留言</h1>

  
      <div id="fb-root"></div>
<script>
  (function(d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0];
    if (d.getElementById(id)) return;
    js = d.createElement(s); js.id = id;
    js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=123456789012345";
    fjs.parentNode.insertBefore(js, fjs);
  }(document, 'script', 'facebook-jssdk'));
</script>

<div class="fb-comments" data-href="https://leejnull.github.io/2019/12/27/2019-12-27-02/index.html" data-num-posts="5" data-width="840" data-colorscheme="light"></div>
      
  
</section>

</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="as_sitesearch" value="leejnull.github.io">
  </form>
</div>


  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/Git/">Git</a><small>1</small></li>
  
    <li><a href="/categories/Go/">Go</a><small>4</small></li>
  
    <li><a href="/categories/Python/">Python</a><small>3</small></li>
  
    <li><a href="/categories/iOS/">iOS</a><small>24</small></li>
  
    <li><a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><small>2</small></li>
  
    <li><a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a><small>10</small></li>
  
    <li><a href="/categories/%E6%97%A5%E5%B8%B8/">日常</a><small>2</small></li>
  
    <li><a href="/categories/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/">朝花夕拾</a><small>2</small></li>
  
    <li><a href="/categories/%E8%BF%90%E7%BB%B4/">运维</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/Codable/">Codable</a><small>1</small></li>
  
    <li><a href="/tags/Crash/">Crash</a><small>1</small></li>
  
    <li><a href="/tags/Django/">Django</a><small>3</small></li>
  
    <li><a href="/tags/Event/">Event</a><small>1</small></li>
  
    <li><a href="/tags/ISA/">ISA</a><small>1</small></li>
  
    <li><a href="/tags/KVC/">KVC</a><small>1</small></li>
  
    <li><a href="/tags/KVO/">KVO</a><small>1</small></li>
  
    <li><a href="/tags/Mac%E4%BD%BF%E7%94%A8/">Mac使用</a><small>2</small></li>
  
    <li><a href="/tags/MarkDown/">MarkDown</a><small>1</small></li>
  
    <li><a href="/tags/Mysql/">Mysql</a><small>1</small></li>
  
    <li><a href="/tags/Python/">Python</a><small>2</small></li>
  
    <li><a href="/tags/RunLoop/">RunLoop</a><small>1</small></li>
  
    <li><a href="/tags/Swift/">Swift</a><small>2</small></li>
  
    <li><a href="/tags/UITextView/">UITextView</a><small>1</small></li>
  
    <li><a href="/tags/Vue/">Vue</a><small>1</small></li>
  
    <li><a href="/tags/Xcode/">Xcode</a><small>1</small></li>
  
    <li><a href="/tags/Xib/">Xib</a><small>1</small></li>
  
    <li><a href="/tags/flag/">flag</a><small>1</small></li>
  
    <li><a href="/tags/iOS/">iOS</a><small>22</small></li>
  
    <li><a href="/tags/import/">import</a><small>1</small></li>
  
    <li><a href="/tags/nginx/">nginx</a><small>1</small></li>
  
    <li><a href="/tags/package/">package</a><small>1</small></li>
  
    <li><a href="/tags/pip/">pip</a><small>1</small></li>
  
    <li><a href="/tags/runtime/">runtime</a><small>1</small></li>
  
    <li><a href="/tags/sql/">sql</a><small>2</small></li>
  
    <li><a href="/tags/uwsgi/">uwsgi</a><small>1</small></li>
  
    <li><a href="/tags/%E4%BC%98%E5%8C%96/">优化</a><small>1</small></li>
  
    <li><a href="/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/">位运算</a><small>1</small></li>
  
    <li><a href="/tags/%E5%86%85%E5%AD%98/">内存</a><small>2</small></li>
  
    <li><a href="/tags/%E5%8A%A8%E7%94%BB/">动画</a><small>1</small></li>
  
    <li><a href="/tags/%E5%8E%9F%E7%90%86/">原理</a><small>1</small></li>
  
    <li><a href="/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/">哈希表</a><small>1</small></li>
  
    <li><a href="/tags/%E5%9B%BE%E5%B1%82/">图层</a><small>1</small></li>
  
    <li><a href="/tags/%E5%9F%BA%E7%A1%80/">基础</a><small>2</small></li>
  
    <li><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a><small>2</small></li>
  
    <li><a href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/">字符串</a><small>1</small></li>
  
    <li><a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a><small>14</small></li>
  
    <li><a href="/tags/%E5%AE%9A%E6%97%B6%E5%99%A8/">定时器</a><small>1</small></li>
  
    <li><a href="/tags/%E5%AF%8C%E6%96%87%E6%9C%AC/">富文本</a><small>1</small></li>
  
    <li><a href="/tags/%E5%B0%8F%E6%84%9F%E6%83%B3/">小感想</a><small>1</small></li>
  
    <li><a href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/">小技巧</a><small>1</small></li>
  
    <li><a href="/tags/%E5%B9%B6%E5%8F%91/">并发</a><small>1</small></li>
  
    <li><a href="/tags/%E5%BA%95%E5%B1%82/">底层</a><small>2</small></li>
  
    <li><a href="/tags/%E6%80%A7%E8%83%BD/">性能</a><small>1</small></li>
  
    <li><a href="/tags/%E6%8A%A5%E9%94%99/">报错</a><small>1</small></li>
  
    <li><a href="/tags/%E6%8E%92%E5%BA%8F/">排序</a><small>5</small></li>
  
    <li><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><small>2</small></li>
  
    <li><a href="/tags/%E6%97%A5%E5%B8%B8%E5%8F%8D%E6%80%9D/">日常反思</a><small>1</small></li>
  
    <li><a href="/tags/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/">日常开发</a><small>2</small></li>
  
    <li><a href="/tags/%E6%9E%B6%E6%9E%84/">架构</a><small>1</small></li>
  
    <li><a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a><small>1</small></li>
  
    <li><a href="/tags/%E7%AE%97%E6%B3%95/">算法</a><small>8</small></li>
  
    <li><a href="/tags/%E7%BB%93%E6%9E%84%E4%BD%93/">结构体</a><small>1</small></li>
  
    <li><a href="/tags/%E7%BB%98%E5%88%B6/">绘制</a><small>2</small></li>
  
    <li><a href="/tags/%E7%BF%BB%E8%AF%91/">翻译</a><small>1</small></li>
  
    <li><a href="/tags/%E9%93%BE%E8%A1%A8/">链表</a><small>1</small></li>
  
    <li><a href="/tags/%E9%94%81/">锁</a><small>1</small></li>
  
    <li><a href="/tags/%E9%98%9F%E5%88%97/">队列</a><small>1</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2021 Lee JJ
  
</div>
<div class="clearfix"></div></footer>
  
<script src="/js/jquery-3.4.1.min.js"></script>


<script src="/js/jquery.imagesloaded.min.js"></script>


<script src="/js/gallery.js"></script>






<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script src="/fancybox/jquery.fancybox.pack.js"></script>

<script>
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>
